# Enhanced xwOBA Dashboard with Proper Model Integration and Team Mapping
library(shiny)
library(ggplot2)
library(DT)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)

# ===================================================================
# MISSING FUNCTIONS FROM ORIGINAL CODE
# ===================================================================

# Enhanced xwOBA calculation with CORRECT weights and PA handling
calculate_model_xwoba_and_full <- function(raw_data, xgb_model = NULL) {
  cat("=== CALCULATING CORRECT xwOBA AND xwOBACON ===\n")
  
  # Step 1: Classify ALL plate appearances
  all_pa <- raw_data %>% 
    filter(!is.na(Batter)) %>%
    mutate(
      pa_outcome = case_when(
        PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
        PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
        PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
        KorBB == "Walk" ~ "walk",
        KorBB == "IntentionalWalk" ~ "intentional_walk", 
        PitchCall == "HitByPitch" ~ "hit_by_pitch",
        KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
        TRUE ~ "other"
      ),
      has_tracking_data = !is.na(ExitSpeed) & !is.na(Angle) & ExitSpeed > 0
    ) %>%
    filter(pa_outcome != "other")
  
  cat("Total plate appearances:", nrow(all_pa), "\n")
  
  # Step 2: Get batted balls with tracking data for xwOBA predictions
  batted_balls_tracked <- all_pa %>%
    filter(
      pa_outcome %in% c("hit", "out") & 
      has_tracking_data == TRUE
    )
  
  cat("Batted balls with tracking data:", nrow(batted_balls_tracked), "\n")
  
  # Step 3: Calculate expected batted ball values using your model
  if (!is.null(xgb_model) && exists("dtest")) {
    # Use your actual model predictions
    test_probs <- predict(xgb_model, dtest, reshape = TRUE)
    colnames(test_probs) <- c("P_out", "P_single", "P_double", "P_triple", "P_home_run")
    
    # wOBA weights for each outcome
    woba_weights <- c(0.000, 0.888, 1.271, 1.616, 2.101)  # out, 1B, 2B, 3B, HR
    predicted_batted_ball_value <- as.vector(test_probs %*% woba_weights)
    batted_balls_tracked$predicted_batted_ball_value <- predicted_batted_ball_value
    
  } else {
    # Fallback: simple expected value based on exit velocity and angle
    batted_balls_tracked$predicted_batted_ball_value <- pmin(2.5, pmax(0, 
      0.1 + (batted_balls_tracked$ExitSpeed - 60) * 0.01 + 
      pmax(0, 30 - abs(batted_balls_tracked$Angle - 20)) * 0.005
    ))
  }
  
  cat("Expected batted ball values calculated\n")
  
  # Step 4: Calculate player-level metrics with CORRECT formulas
  player_metrics <- all_pa %>%
    left_join(
      batted_balls_tracked %>% select(Batter, Date, Inning, PAofInning, predicted_batted_ball_value),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    group_by(Batter) %>%
    summarise(
      # Count PA components
      total_pas = n(),
      batted_balls = sum(pa_outcome %in% c("hit", "out")),
      walks = sum(pa_outcome == "walk"),
      intentional_walks = sum(pa_outcome == "intentional_walk"),
      hit_by_pitch = sum(pa_outcome == "hit_by_pitch"), 
      strikeouts = sum(pa_outcome == "strikeout"),
      sacrifice_flies = sum(pa_outcome == "sacrifice_fly"),
      
      # Tracking coverage
      tracked_batted_balls = sum(!is.na(predicted_batted_ball_value)),
      tracking_coverage = round(tracked_batted_balls / batted_balls * 100, 1),
      
      # Expected batted ball value (only for tracked balls)
      total_expected_batted_ball_value = sum(predicted_batted_ball_value, na.rm = TRUE),
      mean_expected_batted_ball_value = mean(predicted_batted_ball_value, na.rm = TRUE),
      
      # CORRECT xwOBA calculation:
      # Numerator = expected batted ball value + walk value + HBP value
      # Denominator = ALL plate appearances (including strikeouts)
      walk_value = 0.690,
      hbp_value = 0.690,
      
      xwoba_numerator = total_expected_batted_ball_value + 
                        (walks - intentional_walks) * walk_value + 
                        hit_by_pitch * hbp_value,
      
      xwoba_denominator = batted_balls + walks - intentional_walks + hit_by_pitch + strikeouts + sacrifice_flies,
      
      predicted_xwoba = ifelse(xwoba_denominator > 0 & tracked_batted_balls > 0,
                              xwoba_numerator / xwoba_denominator, 
                              NA_real_),
      
      # CORRECT xwOBACON calculation:
      # Numerator = expected batted ball value only
      # Denominator = batted balls only (no walks, strikeouts, HBP)
      predicted_xwobacon = ifelse(tracked_batted_balls > 0,
                                 total_expected_batted_ball_value / tracked_batted_balls,
                                 NA_real_),
      
      .groups = "drop"
    ) %>%
    filter(!is.na(predicted_xwoba) & !is.na(predicted_xwobacon))
  
  cat("Player metrics calculated for", nrow(player_metrics), "players\n")
  
  # Step 5: Merge back to individual PA level
  enhanced_data <- all_pa %>%
    left_join(
      batted_balls_tracked %>% select(Batter, Date, Inning, PAofInning, predicted_batted_ball_value),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    left_join(
      player_metrics %>% select(Batter, predicted_xwoba, predicted_xwobacon, 
                               total_pas, tracking_coverage, tracked_batted_balls, batted_balls),
      by = "Batter"
    ) %>%
    mutate(
      predicted_xwoba_final = predicted_xwoba,
      predicted_xwobacon_final = predicted_xwobacon
    ) %>%
    filter(!is.na(predicted_xwoba_final))
  
  # Verification output
  cat("\n=== CALCULATION VERIFICATION ===\n")
  cat("Total enhanced records:", nrow(enhanced_data), "\n")
  cat("Unique players:", length(unique(enhanced_data$Batter)), "\n")
  
  # Show sample calculation for verification
  sample_player <- enhanced_data %>%
    group_by(Batter) %>%
    summarise(
      total_pas = n(),
      batted_balls = sum(pa_outcome %in% c("hit", "out")),
      walks = sum(pa_outcome == "walk"),
      strikeouts = sum(pa_outcome == "strikeout"),
      hbp = sum(pa_outcome == "hit_by_pitch"),
      xwoba = round(first(predicted_xwoba_final), 3),
      xwobacon = round(first(predicted_xwobacon_final), 3),
      .groups = "drop"
    ) %>%
    slice_head(n = 1)
  
  if (nrow(sample_player) > 0) {
    cat("\nSample calculation verification:\n")
    cat("Player:", sample_player$Batter, "\n")
    cat("- Total PAs:", sample_player$total_pas, 
        "(Batted:", sample_player$batted_balls, 
        "| Walks:", sample_player$walks, 
        "| Ks:", sample_player$strikeouts, 
        "| HBP:", sample_player$hbp, ")\n")
    cat("- xwOBA:", sample_player$xwoba, "(includes walks+HBP in num, all PAs in denom)\n")
    cat("- xwOBACON:", sample_player$xwobacon, "(batted ball values only / batted balls only)\n")
    cat("- Difference:", round(sample_player$xwobacon - sample_player$xwoba, 3), 
        "(xwOBACON should be higher)\n")
  }
  
  return(enhanced_data)
}

# ===================================================================
# ENHANCED TEAM MAPPING - Using the 83-line document structure
# ===================================================================

necbl_team_mapping <- list(
  "BRI_B" = list(
    name = "Bristol Blues", 
    abbrev = "BRI",
    team_id = "89490"
  ),
  "DAN_WES" = list(
    name = "Danbury Westerners", 
    abbrev = "DAN",
    team_id = "6402"
  ),
  "KEE_SWA" = list(
    name = "Keene SwampBats", 
    abbrev = "KSB",
    team_id = "6401"
  ),
  "MYS_SCH" = list(
    name = "Mystic Schooners", 
    abbrev = "MSC",
    team_id = "11912"
  ),
  "MAR_VIN" = list(
    name = "Martha's Vineyard Sharks", 
    abbrev = "MV",
    team_id = "142675"
  ),
  "NEW_GUL" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458"
  ),
  "NOR_ADA" = list(
    name = "North Adams Steeplecats", 
    abbrev = "NSC",
    team_id = "6404"
  ),
  "NSH_N" = list(
    name = "North Shore Navigators", 
    abbrev = "NSN",
    team_id = "154432"
  ),
  "OCE_STA" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489"
  ),
  "SAN_MAI" = list(
    name = "Sanford Mainers", 
    abbrev = "SM",
    team_id = "6459"
  ),
  "UPP_VAL" = list(
    name = "Upper Valley Nighthawks", 
    abbrev = "UVNH",
    team_id = "104040"
  ),
  "VAL_BLU" = list(
    name = "Valley Blue Sox", 
    abbrev = "VAL",
    team_id = "6403"
  ),
  "VER_MOU" = list(
    name = "Vermont Mountaineers", 
    abbrev = "VM",
    team_id = "6405"
  )
)

# Season ID mapping
necbl_season_ids <- list(
  "2021" = "32746",
  "2022" = "33205", 
  "2023" = "33589",
  "2024" = "33860",
  "2025" = "34029"
)

# ===================================================================
# ENHANCED POINTSTREAK SCRAPING WITH PROPER TEAM/SEASON HANDLING
# ===================================================================

get_necbl_woba_by_season <- function(season = "2025") {
  cat("=== SCRAPING NECBL", season, "SEASON WITH ENHANCED TEAM MAPPING ===\n")
  
  season_id <- necbl_season_ids[[season]]
  if (is.null(season_id)) {
    cat("ERROR: Season", season, "not available\n")
    return(data.frame())
  }
  
  cat("Using Season ID:", season_id, "\n")
  
  all_woba <- data.frame()
  
  for (team_code in names(necbl_team_mapping)) {
    team_info <- necbl_team_mapping[[team_code]]
    team_name <- team_info$name
    team_abbrev <- team_info$abbrev
    team_id <- team_info$team_id
    
    # Construct URL using team_id and season_id
    url <- paste0("http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=", 
                 team_id, "&seasonid=", season_id)
    
    cat("Scraping", team_name, "(", team_code, ") - Team ID:", team_id, "\n")
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0"), timeout(15))
      if (status_code(response) != 200) {
        cat("  ERROR: HTTP", status_code(response), "\n")
        next
      }
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      team_found <- FALSE
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            cat("  Found batting stats table\n")
            
            # Find required columns
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) {
              cat("  Missing required columns (AB/H)\n")
              next
            }
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                # Skip invalid rows
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                # Extract stats
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                # Extract other stats with defaults
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                # Calculate singles and metrics
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  # wOBA: weighted value / PAs (includes BB, HBP)
                  pointstreak_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                      triples_val * 1.616 + hr_val * 2.101 + 
                                      (bb_val + hbp_val) * 0.690) / PA
                  
                  # wOBACON: weighted value / Batted_Balls (excludes BB, HBP, SO)
                  pointstreak_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                         triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  # Enhanced name cleaning
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  clean_name <- str_replace_all(clean_name, "\\s*x\\s*", " ")
                  clean_name <- str_replace_all(str_trim(clean_name), "\\s+", " ")
                  
                  # Parse name with middle name handling
                  if (grepl(",", clean_name)) {
                    # Format: "Last, First Middle" 
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    first_words <- str_split(first_part, "\\s+")[[1]]
                    first_name <- first_words[1]
                    first_initial <- substr(first_name, 1, 1)
                  } else {
                    # Format: "First Middle Last"
                    words <- str_split(clean_name, "\\s+")[[1]]
                    words <- words[words != "" & words != "x"]
                    
                    if (length(words) >= 2) {
                      first_name <- words[1]
                      first_initial <- substr(first_name, 1, 1)
                      last_name <- words[length(words)]
                    } else if (length(words) == 1) {
                      last_name <- words[1]
                      first_name <- words[1]
                      first_initial <- substr(words[1], 1, 1)
                    } else {
                      next
                    }
                  }
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Name = toupper(str_trim(first_name)),
                    First_Initial = toupper(str_trim(first_initial)),
                    wOBA = round(pointstreak_wOBA, 3),
                    wOBACON = round(pointstreak_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    Team_Code = team_code,  # Add model team code mapping
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    BB = bb_val,
                    SO = so_val,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                # Skip problematic rows
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
              cat("  Found", nrow(team_stats), "players\n")
              team_found <- TRUE
            }
            break
          }
        }
      }
      
      if (!team_found) {
        cat("  No batting stats found\n")
      }
      
    }, error = function(e) {
      cat("  ERROR:", e$message, "\n")
    })
    
    Sys.sleep(1)
  }
  
  cat("Total players scraped:", nrow(all_woba), "\n")
  return(all_woba)
}

# ===================================================================
# ENHANCED MATCHING WITH PROPER TEAM MAPPING
# ===================================================================

match_necbl_data <- function(model_data, necbl_data) {
  cat("=== ENHANCED MATCHING WITH TEAM CODE MAPPING ===\n")
  cat("Model records (PRIMARY):", nrow(model_data), "\n")
  cat("NECBL records (OVERLAY):", nrow(necbl_data), "\n")
  
  # Parse model data names with enhanced team mapping
  model_with_names <- model_data %>%
    mutate(
      # Enhanced name cleaning for model data
      Original_Batter = Batter,
      Clean_Batter = str_replace_all(str_trim(Batter), "\\s*x\\s*", " "),
      Clean_Batter = str_replace_all(str_trim(Clean_Batter), "\\s+", " "),
      
      Last_Name = toupper(trimws(sub(",.*", "", Clean_Batter))),
      First_Name_Full = toupper(trimws(sub(".*,\\s*", "", Clean_Batter))),
      First_Initial = toupper(substr(First_Name_Full, 1, 1)),
      First_Name = toupper(trimws(str_split(First_Name_Full, "\\s+")[[1]][1])),
      
      # Enhanced team mapping using BatterTeam
      Model_Team_Code = BatterTeam,
      Expected_NECBL_Team = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$name else NA_character_
      }),
      Expected_NECBL_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$abbrev else NA_character_
      })
    ) %>%
    rowwise() %>%
    mutate(
      First_Name = if_else(nchar(trimws(First_Name_Full)) == 1, 
                          First_Name_Full, 
                          toupper(trimws(str_split(First_Name_Full, "\\s+")[[1]][1])))
    ) %>%
    ungroup()
  
  cat("\nModel team mapping sample:\n")
  team_mapping_sample <- model_with_names %>%
    select(Model_Team_Code, Expected_NECBL_Team, Expected_NECBL_Abbrev) %>%
    distinct() %>%
    head(5)
  print(team_mapping_sample)
  
  if (nrow(necbl_data) == 0) {
    return(model_with_names %>%
           select(-all_of(c("Original_Batter", "Clean_Batter", "Last_Name", "First_Name_Full", 
                           "First_Initial", "First_Name", "Model_Team_Code", 
                           "Expected_NECBL_Team", "Expected_NECBL_Abbrev"))) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Model Only",
             pointstreak_team_abbrev = NA_character_
           ))
  }
  
  # Enhanced matching strategies with team code priority
  
  # Strategy 1: Team Code + Last Name + First Name
  team_code_matches <- model_with_names %>%
    inner_join(necbl_data, 
               by = c("Last_Name", "First_Name", "Model_Team_Code" = "Team_Code"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "TeamCode+Name_Match")
  
  cat("Team Code + Name matches:", nrow(team_code_matches), "\n")
  
  # Strategy 2: Team Name + Last Name + First Initial
  remaining_model_1 <- model_with_names %>%
    anti_join(team_code_matches, by = c("Last_Name", "First_Initial"))
  
  remaining_necbl_1 <- necbl_data %>%
    anti_join(team_code_matches, by = c("Last_Name", "First_Initial"))
  
  team_name_matches <- remaining_model_1 %>%
    inner_join(remaining_necbl_1, 
               by = c("Last_Name", "First_Initial", "Expected_NECBL_Team" = "Team"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "TeamName+Initial_Match")
  
  cat("Team Name + Initial matches:", nrow(team_name_matches), "\n")
  
  # Strategy 3: Team Abbreviation + Last Name + First Initial
  remaining_model_2 <- remaining_model_1 %>%
    anti_join(team_name_matches, by = c("Last_Name", "First_Initial"))
  
  remaining_necbl_2 <- remaining_necbl_1 %>%
    anti_join(team_name_matches, by = c("Last_Name", "First_Initial"))
  
  team_abbrev_matches <- remaining_model_2 %>%
    inner_join(remaining_necbl_2, 
               by = c("Last_Name", "First_Initial", "Expected_NECBL_Abbrev" = "Team_Abbrev"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "TeamAbbrev+Initial_Match")
  
  cat("Team Abbrev + Initial matches:", nrow(team_abbrev_matches), "\n")
  
  # Strategy 4: Name-only fallback
  remaining_model_3 <- remaining_model_2 %>%
    anti_join(team_abbrev_matches, by = c("Last_Name", "First_Initial"))
  
  remaining_necbl_3 <- remaining_necbl_2 %>%
    anti_join(team_abbrev_matches, by = c("Last_Name", "First_Initial"))
  
  name_only_matches <- remaining_model_3 %>%
    inner_join(remaining_necbl_3, 
               by = c("Last_Name", "First_Initial"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "NameOnly_Match")
  
  cat("Name Only matches:", nrow(name_only_matches), "\n")
  
  # Combine all matches
  all_matches <- bind_rows(
    team_code_matches,
    team_name_matches,
    team_abbrev_matches,
    name_only_matches
  ) %>%
    select(Last_Name, First_Initial, wOBA, wOBACON, Team_Abbrev, Team_Code, 
           PA, Batted_Balls, BB, SO, match_quality)
  
  # Apply to ALL model data
  matched_data <- model_data %>%
    mutate(
      # Enhanced name parsing
      Clean_Batter = str_replace_all(str_trim(Batter), "\\s*x\\s*", " "),
      Last_Name = toupper(trimws(sub(",.*", "", Clean_Batter))),
      First_Name_Full = toupper(trimws(sub(".*,\\s*", "", Clean_Batter))),
      First_Initial = toupper(substr(First_Name_Full, 1, 1))
    ) %>%
    left_join(all_matches, by = c("Last_Name", "First_Initial")) %>%
    mutate(
      # OVERLAY Pointstreak data where available
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      
      # Enhanced data source tracking
      data_source = case_when(
        match_quality == "TeamCode+Name_Match" ~ "Perfect Match",
        match_quality == "TeamName+Initial_Match" ~ "Team + Name Match",
        match_quality == "TeamAbbrev+Initial_Match" ~ "Team + Name Match", 
        match_quality == "NameOnly_Match" ~ "Name Only Match",
        TRUE ~ "Model Only"
      ),
      
      # Team tracking
      pointstreak_team_abbrev = Team_Abbrev,
      pointstreak_team_code = Team_Code,
      model_team_code = BatterTeam
    ) %>%
    select(-Clean_Batter, -Last_Name, -First_Name_Full, -First_Initial, 
           -wOBA, -wOBACON, -Team_Abbrev, -Team_Code, -PA, -Batted_Balls, 
           -BB, -SO, -match_quality)
  
  # Enhanced summary
  total_records <- nrow(matched_data)
  pointstreak_records <- sum(!is.na(matched_data$actual_woba_final))
  
  match_breakdown <- matched_data %>%
    filter(!is.na(actual_woba_final)) %>%
    count(data_source, sort = TRUE)
  
  cat("\n=== ENHANCED MATCHING SUMMARY ===\n")
  cat("Total model records preserved:", total_records, "\n")
  cat("Records with Pointstreak overlay:", pointstreak_records, "(", round(pointstreak_records/total_records*100, 1), "%)\n")
  cat("\nMatch quality breakdown:\n")
  print(match_breakdown)
  
  # Show team mapping verification
  team_verification <- matched_data %>%
    filter(!is.na(actual_woba_final)) %>%
    select(model_team_code, pointstreak_team_code, pointstreak_team_abbrev) %>%
    distinct() %>%
    head(10)
  
  if (nrow(team_verification) > 0) {
    cat("\nTeam mapping verification:\n")
    print(team_verification)
  }
  
  return(matched_data)
}

# ===================================================================
# INITIALIZE WITH FULL PA DATA (NOT JUST BATTED BALLS)
# ===================================================================

initialize_app_data <- function(default_season = "2025") {
  cat("=== INITIALIZING APP DATA WITH FULL PA DATA - DEFAULT SEASON:", default_season, "===\n")
  
  # Use combined_df (all PAs) or raw_data for proper xwOBA calculation
  if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("Using combined_df data with", nrow(combined_df), "observations (ALL PAs)\n")
    base_data <- combined_df
    
    # Ensure proper xwOBA/xwOBACON separation if not already done
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("Calculating xwOBA (all PAs) and xwOBACON (batted balls) from combined_df...\n")
      base_data <- calculate_model_xwoba_and_full(base_data, if(exists("model")) model else NULL)
    }
    
  } else if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("Using raw_data with", nrow(raw_data), "observations and applying model calculations\n")
    
    # Apply your enhanced model calculation to get both xwOBA and xwOBACON
    base_data <- calculate_model_xwoba_and_full(raw_data, if(exists("model")) model else NULL)
    
  } else {
    cat("WARNING: No full PA data found (combined_df or raw_data).\n")
    cat("NOTE: app_combined_df only contains batted balls, need all PAs for xwOBA.\n")
    cat("Creating sample data with all PA types...\n")
    
    # Create comprehensive sample data with all PA types
    set.seed(42)
    n_total <- 1200  # Include walks, strikeouts, HBP
    team_codes <- names(necbl_team_mapping)
    
    # Create batted balls (70% of PAs)
    n_batted <- round(n_total * 0.7)
    batted_balls <- data.frame(
      Batter = paste(
        sample(c("Smith", "Johnson", "Williams", "Brown", "Jones", "Davis", "Miller", "Wilson"), 
               n_batted, replace = TRUE),
        sample(c("John", "Michael", "David", "James", "Robert", "Chris", "Matt", "Alex"), 
               n_batted, replace = TRUE),
        sep = ", "
      ),
      BatterTeam = sample(team_codes, n_batted, replace = TRUE),
      ExitSpeed = rnorm(n_batted, 85, 15),
      Angle = rnorm(n_batted, 15, 20),
      PlayResult = sample(c("Single", "Double", "Triple", "HomeRun", "Out"), n_batted, 
                         replace = TRUE, prob = c(0.15, 0.08, 0.02, 0.05, 0.70)),
      Date = Sys.Date() - sample(1:90, n_batted, replace = TRUE),
      Inning = sample(1:9, n_batted, replace = TRUE),
      PAofInning = sample(1:4, n_batted, replace = TRUE),
      KorBB = NA_character_,
      PitchCall = NA_character_,
      stringsAsFactors = FALSE
    )
    
    # Create walks, strikeouts, HBP (30% of PAs)
    n_other <- n_total - n_batted
    other_pas <- data.frame(
      Batter = paste(
        sample(c("Smith", "Johnson", "Williams", "Brown", "Jones", "Davis", "Miller", "Wilson"), 
               n_other, replace = TRUE),
        sample(c("John", "Michael", "David", "James", "Robert", "Chris", "Matt", "Alex"), 
               n_other, replace = TRUE),
        sep = ", "
      ),
      BatterTeam = sample(team_codes, n_other, replace = TRUE),
      ExitSpeed = NA_real_,
      Angle = NA_real_,
      PlayResult = NA_character_,
      Date = Sys.Date() - sample(1:90, n_other, replace = TRUE),
      Inning = sample(1:9, n_other, replace = TRUE),
      PAofInning = sample(1:4, n_other, replace = TRUE),
      KorBB = sample(c("Walk", "Strikeout", "StrikeoutSwinging", "StrikeoutLooking"), n_other, 
                    replace = TRUE, prob = c(0.4, 0.2, 0.2, 0.2)),
      PitchCall = ifelse(runif(n_other) < 0.05, "HitByPitch", NA_character_),
      stringsAsFactors = FALSE
    )
    
    # Combine all PA types
    sample_data <- rbind(batted_balls, other_pas)
    
    # Apply model calculations to get proper xwOBA/xwOBACON
    base_data <- calculate_model_xwoba_and_full(sample_data, NULL)
  }
  
  # Ensure all required columns exist for dashboard
  final_data <- base_data %>%
    mutate(
      # Model predictions (use existing or create defaults)
      predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) {
        predicted_xwoba_final
      } else if("predicted_xwoba" %in% names(.)) {
        predicted_xwoba  # Alternative column name
      } else {
        0.350  # Default fallback
      },
      
      predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) {
        predicted_xwobacon_final
      } else if("predicted_xwobacon" %in% names(.)) {
        predicted_xwobacon  # Alternative column name
      } else {
        0.400  # Default fallback
      },
      
      # Pointstreak overlay (initially empty)
      actual_woba_final = NA_real_,
      actual_wobacon_final = NA_real_,
      
      # Default tracking
      data_source = "Model Only",
      pointstreak_team_abbrev = NA_character_,
      season = default_season
    )
  
  cat("Final data initialized with", nrow(final_data), "records for season", default_season, "\n")
  
  # Show PA type breakdown to verify we have all PA types
  if ("KorBB" %in% names(final_data) && "PlayResult" %in% names(final_data)) {
    pa_breakdown <- final_data %>%
      mutate(
        pa_type = case_when(
          !is.na(PlayResult) ~ "Batted Ball",
          KorBB %in% c("Walk", "IntentionalWalk") ~ "Walk",
          KorBB %in% c("Strikeout", "StrikeoutSwinging", "StrikeoutLooking") ~ "Strikeout",
          PitchCall == "HitByPitch" ~ "Hit By Pitch",
          TRUE ~ "Other"
        )
      ) %>%
      count(pa_type, sort = TRUE)
    
    cat("\nPA type breakdown (verifying all PA types included):\n")
    print(pa_breakdown)
  }
  
  # Show team distribution
  if ("BatterTeam" %in% names(final_data)) {
    team_dist <- final_data %>%
      count(BatterTeam, sort = TRUE) %>%
      head(10)
    cat("\nTeam distribution:\n")
    print(team_dist)
  }
  
  # Show xwOBA vs xwOBACON difference verification
  if (all(c("predicted_xwoba_final", "predicted_xwobacon_final") %in% names(final_data))) {
    metric_comparison <- final_data %>%
      group_by(Batter) %>%
      summarise(
        avg_xwoba = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        avg_xwobacon = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        .groups = "drop"
      ) %>%
      summarise(
        mean_xwoba = round(mean(avg_xwoba, na.rm = TRUE), 3),
        mean_xwobacon = round(mean(avg_xwobacon, na.rm = TRUE), 3),
        difference = round(mean(avg_xwobacon, na.rm = TRUE) - mean(avg_xwoba, na.rm = TRUE), 3)
      )
    
    cat("\nMetric verification (xwOBACON should be higher than xwOBA):\n")
    print(metric_comparison)
  }
  
  return(final_data)
}

# ===================================================================
# SHINY UI WITH ENHANCED CONTROLS
# ===================================================================

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .header-container {
        display: flex;
        align-items: center;
        padding: 15px 20px 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        margin-bottom: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .header-container h1 {
        font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        font-weight: 700;
        color: white;
        letter-spacing: 1px;
        font-size: 32px;
        margin: 0;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }
      .necbl-status {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .action-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
      }
    "))
  ),
  
  div(class = "content-wrapper",
    div(class = "header-container",
        h1("Expected Stats Dashboard - 2025 Default")
    ),

    # Enhanced Controls
    fluidRow(
      column(12,
        div(class = "necbl-status",
          h4("Data Controls", style = "margin: 0 0 10px 0;"),
          fluidRow(
            column(3, selectInput("necbl_season", "Season:", 
                         choices = c("2025", "2024", "2023", "2022", "2021"), selected = "2025")),
            column(3, selectInput("team_filter", "Filter by Team:", 
                         choices = c("All Teams" = "All"), selected = "All")),
            column(3, selectInput("pa_threshold", "Minimum PAs:", 
                         choices = c("All Players" = 0, "10+" = 10, "20+" = 20, "30+" = 30),
                         selected = 10)),
            column(3, selectInput("metric_type", "Primary Metric:", 
                         choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                         selected = "xwoba"))
          ),
          br(),
          fluidRow(
            column(6, actionButton("refresh_necbl", "🔄 Load 2025 Pointstreak Data", class = "action-button")),
            column(6, textOutput("data_status"))
          )
        )
      )
    ),

    # Main content
    sidebarLayout(
      sidebarPanel(
        conditionalPanel(
          condition = "input.tabs == 'Performance Analysis'",
          selectInput("scatter_player", "Select Player:", 
                      choices = c("All Players" = ""), selected = "")
        ),
        
        conditionalPanel(
          condition = "input.tabs == 'Player Comparison'",
          selectInput("comp_player1", "Select Player 1:", choices = c("Choose Player" = "")),
          selectInput("comp_player2", "Select Player 2:", choices = c("Choose Player" = "")),
          dateRangeInput("comp_date_range", "Date Range:", 
                        start = Sys.Date() - 90, end = Sys.Date())
        ),
        
        conditionalPanel(
          condition = "input.tabs == 'Team & Player Browser'",
          selectInput("browser_team", "Select Team:", choices = c("All Teams" = "All")),
          selectInput("browser_player", "Select Player:", choices = c("All Players" = "All")),
          selectInput("browser_sort", "Sort by:", 
                     choices = c("xwOBA" = "Avg_xwOBA", "wOBA" = "Avg_wOBA", "xwOBACON" = "Avg_xwOBACON", "wOBACON" = "Avg_wOBACON", "PAs" = "PA_Count"),
                     selected = "Avg_xwOBA")
        )
      ),

      mainPanel(
        tabsetPanel(
          id = "tabs",
          
          tabPanel("Performance Analysis", 
                   div(
                     h3("Expected vs Actual Performance Analysis"),
                     p("Compare expected performance metrics with actual 2025 results."),
                     plotOutput("performance_plot", height = "500px")
                   )),
          
          tabPanel("Underperformers", 
                   div(
                     h3("Players Underperforming Expectations", style = "color: #28a745;"),
                     p("Players whose expected metrics exceed their actual 2025 results."),
                     DT::dataTableOutput("underperformers")
                   )),
          
          tabPanel("Overperformers", 
                   div(
                     h3("Players Exceeding Expectations", style = "color: #dc3545;"),
                     p("Players whose actual 2025 results exceed their expected metrics."),
                     DT::dataTableOutput("overperformers")
                   )),
          
          tabPanel("Player Comparison",
                   div(
                     h3("Player Performance Comparison"),
                     p("Compare cumulative performance trends between two players."),
                     plotOutput("comparison_line_chart", height = "500px"),
                     hr(),
                     DT::dataTableOutput("comparison_summary")
                   )),
          
          tabPanel("Team & Player Browser",
                   div(
                     h3("Team and Player Browser"),
                     p("Browse all players and their performance metrics by team."),
                     DT::dataTableOutput("browser_table")
                   ))
        )
      )
    )
  )
)

# ===================================================================
# ENHANCED SHINY SERVER
# ===================================================================

server <- function(input, output, session) {
  
  # Reactive values
  values <- reactiveValues(
    necbl_data = NULL,
    combined_df_enhanced = NULL,
    last_update = NULL,
    current_season = "2025"
  )
  
  # Initialize data on startup with 2025 default
  observe({
    if (is.null(values$combined_df_enhanced)) {
      values$combined_df_enhanced <- initialize_app_data("2025")
      values$current_season <- "2025"
      cat("Initialized app with", nrow(values$combined_df_enhanced), "records for 2025\n")
    }
  })
  
  # Data status output
  output$data_status <- renderText({
    if (!is.null(values$last_update)) {
      pointstreak_count <- sum(!is.na(values$combined_df_enhanced$actual_woba_final))
      paste("Last updated:", format(values$last_update, "%H:%M:%S"), 
            "| Pointstreak records:", pointstreak_count)
    } else {
      "Ready to load 2025 Pointstreak data"
    }
  })
  
  # Helper function for filtered data with enhanced team filtering
  get_filtered_data <- function() {
    req(values$combined_df_enhanced)
    
    current_data <- values$combined_df_enhanced
    
    if (is.null(current_data) || nrow(current_data) == 0) {
      return(data.frame())
    }
    
    # Apply PA threshold
    pa_threshold <- as.numeric(input$pa_threshold %||% 0)
    if (pa_threshold > 0) {
      current_data <- current_data %>%
        group_by(Batter) %>%
        filter(n() >= pa_threshold) %>%
        ungroup()
    }
    
    # Apply team filter using BatterTeam
    if (!is.null(input$team_filter) && input$team_filter != "All") {
      if ("BatterTeam" %in% names(current_data)) {
        current_data <- current_data %>%
          filter(BatterTeam == input$team_filter)
      }
    }
    
    return(current_data)
  }
  
  # Enhanced UI updates with proper team mapping
  observe({
    tryCatch({
      current_data <- get_filtered_data()
      
      if (!is.null(current_data) && nrow(current_data) > 0) {
        player_choices <- c("All Players" = "", sort(unique(current_data$Batter)))
        
        updateSelectInput(session, "scatter_player", choices = player_choices)
        updateSelectInput(session, "comp_player1", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
        updateSelectInput(session, "comp_player2", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
        updateSelectInput(session, "browser_player", choices = c("All Players" = "All", sort(unique(current_data$Batter))))
        
        # Enhanced team filter with team names
        if ("BatterTeam" %in% names(current_data)) {
          team_choices <- c("All Teams" = "All")
          
          # Add team codes with friendly names
          for (team_code in sort(unique(current_data$BatterTeam))) {
            team_info <- necbl_team_mapping[[team_code]]
            if (!is.null(team_info)) {
              team_label <- paste0(team_info$name, " (", team_code, ")")
              team_choices[team_label] <- team_code
            } else {
              team_choices[team_code] <- team_code
            }
          }
          
          updateSelectInput(session, "team_filter", choices = team_choices)
          updateSelectInput(session, "browser_team", choices = team_choices)
        }
      }
    }, error = function(e) {
      cat("Error updating UI elements:", e$message, "\n")
    })
  })
  
  # Enhanced NECBL data refresh with proper season handling
  observeEvent(input$refresh_necbl, {
    showModal(modalDialog(
      title = paste("Loading NECBL", input$necbl_season, "Data"),
      div(
        h4("Downloading Pointstreak Statistics..."),
        p(paste("Scraping", input$necbl_season, "season data from all 13 NECBL teams...")),
        p("Using enhanced team mapping and season IDs..."),
        p("This may take 2-3 minutes.")
      ),
      footer = NULL, easyClose = FALSE
    ))
    
    tryCatch({
      cat("=== STARTING ENHANCED NECBL REFRESH FOR", input$necbl_season, "===\n")
      
      # Step 1: Scrape NECBL data for selected season
      values$necbl_data <- get_necbl_woba_by_season(input$necbl_season)
      values$last_update <- Sys.time()
      values$current_season <- input$necbl_season
      
      if (!is.null(values$necbl_data) && nrow(values$necbl_data) > 0) {
        cat("NECBL", input$necbl_season, "data found:", nrow(values$necbl_data), "player records\n")
        
        # Step 2: Re-initialize base data if season changed
        if (values$current_season != input$necbl_season) {
          base_data <- initialize_app_data(input$necbl_season)
        } else {
          base_data <- values$combined_df_enhanced
        }
        
        # Step 3: Enhanced matching with team code mapping
        values$combined_df_enhanced <- match_necbl_data(base_data, values$necbl_data)
        
        # Step 4: Enhanced reporting
        if (!is.null(values$combined_df_enhanced)) {
          total_records <- nrow(values$combined_df_enhanced)
          pointstreak_records <- sum(!is.na(values$combined_df_enhanced$actual_woba_final))
          
          # Team mapping verification
          team_matches <- values$combined_df_enhanced %>%
            filter(!is.na(actual_woba_final)) %>%
            select(model_team_code, pointstreak_team_code, pointstreak_team_abbrev) %>%
            distinct() %>%
            nrow()
          
          removeModal()
          
          if (pointstreak_records > 0) {
            showNotification(
              HTML(paste0(
                "<strong>SUCCESS!</strong> ", input$necbl_season, " Pointstreak data loaded!<br>",
                "📊 ", total_records, " total model records preserved<br>",
                "🎯 ", pointstreak_records, " records enhanced with Pointstreak stats<br>",
                "🔗 ", team_matches, " team mappings verified<br>",
                "📈 Season: ", input$necbl_season
              )), 
              type = "message", duration = 15
            )
          } else {
            showNotification(
              paste("⚠️", input$necbl_season, "Pointstreak data scraped but NO MATCHES found. Check team mapping."), 
              type = "warning", duration = 15
            )
          }
        } else {
          removeModal()
          showNotification("❌ Error in matching process", type = "error")
        }
      } else {
        removeModal()
        showNotification(
          paste("❌ No NECBL data found for", input$necbl_season, "season. Check network connection or team URLs."), 
          type = "warning", duration = 10
        )
      }
    }, error = function(e) {
      removeModal()
      showNotification(paste("❌ Error loading NECBL data:", e$message), type = "error", duration = 15)
    })
  })
  
  # Enhanced Performance Analysis Plot
  output$performance_plot <- renderPlot({
    current_data <- get_filtered_data()
    
    if (nrow(current_data) == 0) {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data available"), size = 6) +
        theme_void()
      return()
    }
    
    # Filter for specific player if selected
    if (!is.null(input$scatter_player) && input$scatter_player != "") {
      current_data <- current_data %>% filter(Batter == input$scatter_player)
      plot_title <- paste("Performance Analysis:", input$scatter_player, "(", values$current_season, ")")
    } else {
      plot_title <- paste("Performance Analysis: All Players (", values$current_season, ")")
    }
    
    # Calculate player-level performance metrics
    player_performance <- current_data %>%
      group_by(Batter, BatterTeam) %>%
      summarise(
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        xwOBACON = mean(predicted_xwobacon_final, na.rm = TRUE),
        wOBACON = mean(actual_wobacon_final, na.rm = TRUE),
        Has_Pointstreak = !all(is.na(actual_woba_final)),
        Data_Source = first(data_source),
        Model_Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        .groups = "drop"
      ) %>%
      filter(Has_Pointstreak)  # Only show players with Pointstreak data
    
    if (nrow(player_performance) == 0) {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, 
                     label = paste0("No players with ", values$current_season, " actual data found\n\nClick 'Load ", values$current_season, " Pointstreak Data' to load statistics")), 
                  size = 6, color = "#667eea") +
        theme_void()
      return()
    }
    
    # Select metrics based on input
    if (input$metric_type == "xwoba") {
      plot_data <- player_performance %>%
        select(Batter, xwOBA, wOBA, Data_Source, Model_Team, Pointstreak_Team) %>%
        rename(Expected = xwOBA, Actual = wOBA)
      x_label <- paste("wOBA (Actual -", values$current_season, ")")
      y_label <- "xwOBA (Expected - Model)"
      subtitle <- paste("wOBA includes walks (0.690 weight) & HBP | Season:", values$current_season)
    } else {
      plot_data <- player_performance %>%
        select(Batter, xwOBACON, wOBACON, Data_Source, Model_Team, Pointstreak_Team) %>%
        rename(Expected = xwOBACON, Actual = wOBACON)
      x_label <- paste("wOBACON (Actual -", values$current_season, ")")
      y_label <- "xwOBACON (Expected - Model)"
      subtitle <- paste("wOBACON excludes walks, HBP, strikeouts | Season:", values$current_season)
    }
    
    # Enhanced scatter plot with team information
    p <- ggplot(plot_data, aes(x = Actual, y = Expected)) +
      geom_point(aes(color = Data_Source), size = 4, alpha = 0.7) +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "#dc3545", size = 1) +
      scale_color_manual(values = c(
        "Perfect Match" = "#28a745",
        "Team + Name Match" = "#17a2b8",
        "Name Only Match" = "#fd7e14"
      )) +
      labs(title = plot_title,
           subtitle = subtitle,
           x = x_label, y = y_label, color = "Match Quality") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 11),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "bottom"
      )
    
    # Add team mapping annotation
    unique_teams <- length(unique(plot_data$Model_Team))
    if (unique_teams > 0) {
      p <- p + annotate("text", x = min(plot_data$Actual, na.rm = TRUE), 
                       y = max(plot_data$Expected, na.rm = TRUE), 
                       label = paste0("Teams mapped: ", unique_teams, " | Season: ", values$current_season),
                       hjust = 0, vjust = 1, size = 3, color = "#495057")
    }
    
    return(p)
  })
  
  # Enhanced Underperformers Table
  output$underperformers <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    underperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Model_Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Match_Quality = first(data_source),
        Season = values$current_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      filter(wOBA_Diff > 0.025 | wOBACON_Diff > 0.025) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(underperformers, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#d4edda')
  })
  
  # Enhanced Overperformers Table
  output$overperformers <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    overperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Model_Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Match_Quality = first(data_source),
        Season = values$current_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(wOBA - xwOBA, 3),
        wOBACON_Diff = round(wOBACON - xwOBACON, 3)
      ) %>%
      filter(wOBA_Diff > 0.025 | wOBACON_Diff > 0.025) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(overperformers, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#f8d7da')
  })
  
  # Enhanced Player Comparison Line Chart
  output$comparison_line_chart <- renderPlot({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_data <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      arrange(if("Date" %in% names(.)) Date else row_number()) %>%
      group_by(Batter) %>%
      mutate(
        PA_Number = row_number(),
        Cumulative_xwOBA = cummean(predicted_xwoba_final),
        Cumulative_wOBA = cummean(actual_woba_final),
        Cumulative_xwOBACON = cummean(predicted_xwobacon_final),
        Cumulative_wOBACON = cummean(actual_wobacon_final)
      ) %>%
      ungroup()
    
    if (nrow(comparison_data) > 0) {
      line_data <- comparison_data %>%
        select(Batter, PA_Number, Cumulative_xwOBA, Cumulative_wOBA, Cumulative_xwOBACON, Cumulative_wOBACON) %>%
        pivot_longer(cols = starts_with("Cumulative"), names_to = "Metric", values_to = "Value") %>%
        mutate(
          Metric = gsub("Cumulative_", "", Metric),
          Line_Type = ifelse(grepl("x", Metric), "Expected (Model)", paste0("Actual (", values$current_season, ")")),
          Metric_Type = ifelse(grepl("OBACON", Metric), "wOBACON (Batted Balls)", "wOBA (All PAs)")
        ) %>%
        filter(!is.na(Value))
      
      # Create linetype values properly
      actual_label <- paste0("Actual (", values$current_season, ")")
      linetype_values <- c("Expected (Model)" = "solid")
      linetype_values[actual_label] <- "dashed"
      
      ggplot(line_data, aes(x = PA_Number, y = Value, color = Batter, linetype = Line_Type)) +
        geom_line(size = 1.2, alpha = 0.8) +
        facet_wrap(~Metric_Type, scales = "free_y") +
        scale_color_manual(values = c("#667eea", "#764ba2")) +
        scale_linetype_manual(values = linetype_values) +
        labs(title = paste("Performance Comparison:", input$comp_player1, "vs", input$comp_player2, "(", values$current_season, ")"),
             subtitle = "Cumulative performance over plate appearances",
             x = "Plate Appearance Number", y = "Cumulative Value",
             color = "Player", linetype = "Type") +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 16, face = "bold"),
          legend.position = "top"
        )
    } else {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data for selected players"), size = 6) +
        theme_void()
    }
  })
  
  # Enhanced Comparison Summary
  output$comparison_summary <- DT::renderDataTable({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_summary <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      group_by(Batter) %>%
      summarise(
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Model_Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Match_Quality = first(data_source),
        Season = values$current_season,
        .groups = "drop"
      )
    
    DT::datatable(comparison_summary, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3)
  })
  
  # Enhanced Team & Player Browser
  output$browser_table <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    if (!is.null(input$browser_team) && input$browser_team != "All") {
      if ("BatterTeam" %in% names(current_data)) {
        current_data <- current_data %>% filter(BatterTeam == input$browser_team)
      }
    }
    
    if (!is.null(input$browser_player) && input$browser_player != "All") {
      current_data <- current_data %>% filter(Batter == input$browser_player)
    }
    
    browser_data <- current_data %>%
      group_by(Batter) %>%
      summarise(
        PA_Count = n(),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Model_Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Match_Quality = first(data_source),
        Season = values$current_season,
        Has_Pointstreak = !all(is.na(actual_woba_final)),
        .groups = "drop"
      ) %>%
      arrange(desc(!!sym(input$browser_sort)))
    
    DT::datatable(browser_data, options = list(pageLength = 20, scrollX = TRUE)) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
      formatStyle("Has_Pointstreak", backgroundColor = styleEqual(TRUE, '#d4edda'))
  })
}

# ===================================================================
# RUN APPLICATION
# ===================================================================

shinyApp(ui = ui, server = server)

# ===================================================================
# USAGE INSTRUCTIONS
# ===================================================================
