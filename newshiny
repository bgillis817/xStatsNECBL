# Enhanced xwOBA Dashboard - Complete R Shiny Integration
# Fixes: Season-specific parsing, player disambiguation, proper PA integration

# ===================================================================
# REQUIRED LIBRARIES
# ===================================================================
library(shiny)
library(shinydashboard)
library(DT)
library(ggplot2)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)
library(plotly)
# ===================================================================
# ENHANCED CORE FUNCTIONS
# ===================================================================

# Enhanced xwOBA calculation with proper PA integration
calculate_expected_xwoba_and_full <- function(raw_data, xgb_expected = NULL) {
  cat("=== CALCULATING EXPECTED xwOBA WITH PROPER PA INTEGRATION ===\n")
  
  # Step 1: Filter to batted balls with complete data
  batted_balls <- raw_data %>%
    filter(
      PlayResult %in% c("Single", "Double", "Triple", "HomeRun", "Out",
                        "FieldersChoice", "Error", "Sacrifice") &
      !is.na(ExitSpeed) & ExitSpeed > 0 &
      !is.na(Angle) & !is.na(Batter)
    )
  
  cat("Batted balls with tracking data:", nrow(batted_balls), "\n")
  
  # Outcome classification for batted balls
  batted_balls$outcome <- case_when(
    batted_balls$PlayResult %in% c("Single") ~ "single",
    batted_balls$PlayResult %in% c("Double") ~ "double", 
    batted_balls$PlayResult %in% c("Triple") ~ "triple",
    batted_balls$PlayResult %in% c("HomeRun") ~ "home_run",
    batted_balls$PlayResult %in% c("Out", "FieldersChoice", "Error", "Sacrifice") ~ "out",
    TRUE ~ "other"
  )
  
  batted_balls <- batted_balls[batted_balls$outcome != "other", ]
  
  # wOBA weights
  woba_weights_vector <- c(0.000, 0.888, 1.271, 1.616, 2.101)
  
  # Get expected predictions for batted balls
  if (!is.null(xgb_expected) && exists("dtest")) {
    test_probs <- predict(xgb_expected, dtest, reshape = TRUE)
    colnames(test_probs) <- c("P_out", "P_single", "P_double", "P_triple", "P_home_run")
    predicted_xwobacon <- as.vector(test_probs %*% woba_weights_vector)
    batted_balls$predicted_xwobacon <- predicted_xwobacon
  } else {
    # Fallback calculation if expected objects not available
    batted_balls$predicted_xwobacon <- pmin(2.5, pmax(0, 
      0.1 + (batted_balls$ExitSpeed - 60) * 0.01 + 
      pmax(0, 30 - abs(batted_balls$Angle - 20)) * 0.005
    ))
  }
  
  cat("xwOBACON calculated for", nrow(batted_balls), "batted balls\n")
  
  # Step 2: Get ALL plate appearances for each player
  all_pa <- raw_data %>% 
    filter(!is.na(Batter)) %>%
    mutate(
      pa_outcome = case_when(
        PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
        PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
        PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
        KorBB == "Walk" ~ "walk",
        KorBB == "IntentionalWalk" ~ "intentional_walk",
        PitchCall == "HitByPitch" ~ "hit_by_pitch",
        KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
        TRUE ~ "other"
      )
    ) %>%
    filter(pa_outcome != "other")
  
  cat("Total plate appearances:", nrow(all_pa), "\n")
  
  # Step 3: Calculate player-level xwOBA (full PA denominator)
  player_xwoba_full <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    group_by(Batter) %>%
    summarise(
      hits = sum(pa_outcome == "hit"),
      outs = sum(pa_outcome == "out"),
      strikeouts = sum(pa_outcome == "strikeout"),
      BB = sum(pa_outcome == "walk"),
      IBB = sum(pa_outcome == "intentional_walk"),
      SF = sum(pa_outcome == "sacrifice_fly"),
      HBP = sum(pa_outcome == "hit_by_pitch"),
      
      batted_balls_count = hits + outs,
      AB = hits + outs + strikeouts,
      total_pa = AB + BB - IBB + SF + HBP,
      
      mean_xwobacon = mean(predicted_xwobacon, na.rm = TRUE),
      
      wBB_HBP = 0.690,
      xwoba_numerator = (mean_xwobacon * batted_balls_count) + (wBB_HBP * (BB - IBB + HBP)),
      predicted_xwoba_full = ifelse(total_pa > 0, xwoba_numerator / total_pa, NA_real_),
      
      .groups = "drop"
    )
  
  cat("Player-level xwOBA calculated for", nrow(player_xwoba_full), "players\n")
  
  # Step 4: Merge back to individual PA level
  enhanced_data <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    left_join(
      player_xwoba_full %>% select(Batter, predicted_xwoba_full, mean_xwobacon),
      by = "Batter"
    ) %>%
    mutate(
      predicted_xwoba_final = predicted_xwoba_full,
      predicted_xwobacon_final = ifelse(!is.na(predicted_xwobacon), predicted_xwobacon, mean_xwobacon)
    )
  
  cat("=== CALCULATION SUMMARY ===\n")
  cat("Total enhanced records:", nrow(enhanced_data), "\n")
  cat("Records with xwOBA:", sum(!is.na(enhanced_data$predicted_xwoba_final)), "\n")
  cat("Records with xwOBACON:", sum(!is.na(enhanced_data$predicted_xwobacon_final)), "\n")
  
  return(enhanced_data)
}
# ===================================================================
# NECBL TEAM MAPPING & SEASON-SPECIFIC SCRAPING
# ===================================================================

necbl_team_mapping <- list(
  "BRI_B" = list(name = "Bristol Blues", abbrev = "BRI"),
  "DAN_WES" = list(name = "Danbury Westerners", abbrev = "DAN"),
  "KEE_SWA" = list(name = "Keene SwampBats", abbrev = "KSB"),
  "MAR_VIN" = list(name = "Martha's Vineyard Sharks", abbrev = "MV"),
  "MYS_SCH" = list(name = "Mystic Schooners", abbrev = "MSC"),
  "NEW_GUL" = list(name = "Newport Gulls", abbrev = "NG"),
  "NOR_ADA" = list(name = "North Adams Steeplecats", abbrev = "NSC"),
  "NSH_N" = list(name = "North Shore Navigators", abbrev = "NSN"),
  "OCE_STA" = list(name = "Ocean State Waves", abbrev = "OSW"),
  "SAN_MAI" = list(name = "Sanford Mainers", abbrev = "SM"),
  "UPP_VAL" = list(name = "Upper Valley Nighthawks", abbrev = "UVNH"),
  "VAL_BLU" = list(name = "Valley Blue Sox", abbrev = "VAL"),
  "VER_MOU" = list(name = "Vermont Mountaineers", abbrev = "VM")
)

# NECBL URLs by season with proper season IDs
necbl_urls_by_season <- list(
  "2025" = list(seasonid = "34029"),
  "2024" = list(seasonid = "33860"),
  "2023" = list(seasonid = "33603"),
  "2022" = list(seasonid = "33347"),
  "2021" = list(seasonid = "33089")
)

# Team IDs for URL construction
team_ids <- list(
  "Bristol Blues" = "89490",
  "Danbury Westerners" = "6402",
  "Keene SwampBats" = "6401",
  "Martha's Vineyard Sharks" = "142675",
  "Mystic Schooners" = "11912",
  "Newport Gulls" = "6458",
  "North Adams Steeplecats" = "6404",
  "North Shore Navigators" = "154432",
  "Ocean State Waves" = "51489",
  "Sanford Mainers" = "6459",
  "Upper Valley Nighthawks" = "104040",
  "Valley Blue Sox" = "6403",
  "Vermont Mountaineers" = "6405"
)
# Enhanced scraper with season-specific parsing
get_necbl_woba_by_season <- function(season = "2025") {
  cat("=== SCRAPING NECBL", season, "SEASON ===\n")
  
  season_info <- necbl_urls_by_season[[season]]
  if (is.null(season_info)) {
    cat("ERROR: Season", season, "not available\n")
    return(data.frame())
  }
  
  seasonid <- season_info$seasonid
  all_woba <- data.frame()
  
  for (team_name in names(team_ids)) {
    team_id <- team_ids[[team_name]]
    
    # Get team abbreviation
    team_abbrev <- "UNK"
    for (team_code in names(necbl_team_mapping)) {
      if (necbl_team_mapping[[team_code]]$name == team_name) {
        team_abbrev <- necbl_team_mapping[[team_code]]$abbrev
        break
      }
    }
    
    # Construct URL
    if (team_name == "Bristol Blues") {
      url <- paste0("http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=", 
                   seasonid, "&teamid=", team_id)
    } else {
      url <- paste0("http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=", 
                   team_id, "&seasonid=", seasonid)
    }
    
    cat("Scraping", team_name, "for", season, "...\n")
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"), timeout(15))
      if (status_code(response) != 200) {
        cat("HTTP", status_code(response), "for", team_name, "\n")
        next
      }
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            # Find required columns
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) next
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                # Skip invalid rows
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                # Extract stats
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                # Extract other stats with defaults
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                # Calculate singles and metrics
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  # wOBA: weighted value / PAs
                  actual_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                  triples_val * 1.616 + hr_val * 2.101 + 
                                  (bb_val + hbp_val) * 0.690) / PA
                  
                  # wOBACON: weighted value / Batted_Balls
                  actual_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                     triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  # Enhanced player name parsing for better matching
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  
                  # Parse name more carefully
                  if (grepl(",", clean_name)) {
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    
                    # Extract first name and middle initial if present
                    first_words <- str_split(first_part, "\\s+")[[1]]
                    first_name <- first_words[1]
                    first_initial <- substr(first_name, 1, 1)
                    
                    # Get middle initial if available
                    middle_initial <- if(length(first_words) > 1) substr(first_words[2], 1, 1) else ""
                    
                  } else {
                    words <- str_split(clean_name, "\\s+")[[1]]
                    if (length(words) >= 2) {
                      first_name <- words[1]
                      first_initial <- substr(first_name, 1, 1)
                      last_name <- paste(words[2:length(words)], collapse = " ")
                      middle_initial <- if(length(words) > 2) substr(words[2], 1, 1) else ""
                    } else {
                      last_name <- clean_name
                      first_name <- substr(clean_name, 1, 1)
                      first_initial <- substr(clean_name, 1, 1)
                      middle_initial <- ""
                    }
                  }
                  
                  # Create unique player identifier with season
                  player_season_id <- paste(toupper(str_trim(last_name)), 
                                          toupper(str_trim(first_initial)), 
                                          season, 
                                          team_abbrev, sep = "_")
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Name = str_trim(first_name),
                    First_Initial = toupper(str_trim(first_initial)),
                    Middle_Initial = toupper(str_trim(middle_initial)),
                    Player_Season_ID = player_season_id,
                    wOBA = round(actual_wOBA, 3),
                    wOBACON = round(actual_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    Singles = singles_val,
                    Doubles = doubles_val,
                    Triples = triples_val,
                    HRs = hr_val,
                    BBs = bb_val,
                    HBPs = hbp_val,
                    SOs = so_val,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                cat("Error processing row", row_idx, "for", team_name, ":", e$message, "\n")
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
            }
            break
          }
        }
      }
    }, error = function(e) {
      cat("ERROR scraping", team_name, ":", e$message, "\n")
    })
    
    Sys.sleep(1.5)  # Be respectful to the server
  }
  
  cat("Total players with calculated wOBA/wOBACON for", season, ":", nrow(all_woba), "\n")
  return(all_woba)
}
# Enhanced matching function with 4-tier strategy
match_necbl_data <- function(expected_data, necbl_data, selected_season = "2025") {
  cat("=== MATCHING EXPECTED DATA WITH ACTUAL OVERLAY ===\n")
  cat("Expected records (PRIMARY):", nrow(expected_data), "\n")
  cat("NECBL records (OVERLAY):", nrow(necbl_data), "\n")
  cat("Selected season:", selected_season, "\n")
  
  # Filter NECBL data to selected season ONLY
  necbl_season_data <- necbl_data %>%
    filter(Season == selected_season)
  
  cat("NECBL records for", selected_season, ":", nrow(necbl_season_data), "\n")
  
  # Parse expected data names: "Last Name, First Name" format
  expected_with_names <- expected_data %>%
    mutate(
      # Enhanced name parsing for expected data
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Name_Full = trimws(sub(".*,\\s*", "", Batter)),
      First_Initial = toupper(substr(First_Name_Full, 1, 1)),
      
      # Handle middle names/initials in expected data
      First_Name_Parts = strsplit(First_Name_Full, "\\s+"),
      First_Name = sapply(First_Name_Parts, function(x) if(length(x) > 0) x[1] else ""),
      Middle_Initial = sapply(First_Name_Parts, function(x) {
        if(length(x) > 1) substr(x[2], 1, 1) else ""
      }),
      
      # Expected NECBL team from BatterTeam mapping
      Expected_NECBL_Team = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$name else NA_character_
      }),
      Expected_NECBL_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$abbrev else NA_character_
      }),
      
      # Create expected player identifier
      Expected_Player_ID = paste(Last_Name, First_Initial, Expected_NECBL_Abbrev, sep = "_")
    )
  
  # If no NECBL data for selected season, return expected-only
  if (nrow(necbl_season_data) == 0) {
    return(expected_with_names %>%
           select(-Last_Name, -First_Initial, -First_Name_Full, -First_Name_Parts, 
                  -First_Name, -Middle_Initial, -Expected_NECBL_Team, 
                  -Expected_NECBL_Abbrev, -Expected_Player_ID) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Expected Only",
             actual_team_abbrev = NA_character_,
             actual_season = NA_character_
           ))
  }
  
  # 4-tier matching strategy
  
  # Tier 1: Exact match (Last + First + Team + Season)
  tier1_matches <- expected_with_names %>%
    left_join(
      necbl_season_data %>% 
      select(Last_Name, First_Initial, Team_Abbrev, wOBA, wOBACON, Season, Team, Player_Season_ID), 
      by = c("Last_Name", "First_Initial", "Expected_NECBL_Abbrev" = "Team_Abbrev")
    ) %>%
    mutate(match_tier = ifelse(!is.na(wOBA), "Tier1_Exact", NA_character_))
  
  # Tier 2: Team + Name match (for team name vs abbrev mismatches)
  tier2_matches <- tier1_matches %>%
    filter(is.na(match_tier)) %>%
    select(-wOBA, -wOBACON, -Season, -Team, -Player_Season_ID, -match_tier) %>%
    left_join(
      necbl_season_data %>% 
      select(Last_Name, First_Initial, Team, wOBA, wOBACON, Season, Team_Abbrev, Player_Season_ID), 
      by = c("Last_Name", "First_Initial", "Expected_NECBL_Team" = "Team")
    ) %>%
    mutate(match_tier = ifelse(!is.na(wOBA), "Tier2_Team", NA_character_))
  
  # Tier 3: Full name match (for players who might have switched teams)
  tier3_matches <- tier2_matches %>%
    filter(is.na(match_tier)) %>%
    select(-wOBA, -wOBACON, -Season, -Team_Abbrev, -Player_Season_ID, -match_tier) %>%
    left_join(
      necbl_season_data %>% 
      select(Last_Name, First_Name, wOBA, wOBACON, Season, Team, Team_Abbrev, Player_Season_ID), 
      by = c("Last_Name", "First_Name" = "First_Name")
    ) %>%
    mutate(match_tier = ifelse(!is.na(wOBA), "Tier3_FullName", NA_character_))
  
  # Tier 4: Name + Initial only (fallback for name variations)
  tier4_matches <- tier3_matches %>%
    filter(is.na(match_tier)) %>%
    select(-wOBA, -wOBACON, -Season, -Team, -Team_Abbrev, -Player_Season_ID, -match_tier) %>%
    left_join(
      necbl_season_data %>% 
      group_by(Last_Name, First_Initial) %>%
      # For duplicate Last+Initial, prefer current team match
      arrange(desc(ifelse(Team_Abbrev %in% unique(expected_with_names$Expected_NECBL_Abbrev), 1, 0))) %>%
      slice_head(n = 1) %>%
      ungroup() %>%
      select(Last_Name, First_Initial, wOBA, wOBACON, Season, Team, Team_Abbrev, Player_Season_ID), 
      by = c("Last_Name", "First_Initial")
    ) %>%
    mutate(match_tier = ifelse(!is.na(wOBA), "Tier4_Initial", NA_character_))
  
  # Combine all matches with priority order
  final_matches <- bind_rows(
    tier1_matches %>% filter(!is.na(match_tier)),
    tier2_matches %>% filter(!is.na(match_tier)),
    tier3_matches %>% filter(!is.na(match_tier)),
    tier4_matches %>% filter(!is.na(match_tier))
  ) %>%
    group_by(Last_Name, First_Initial, Expected_NECBL_Abbrev) %>%
    arrange(match(match_tier, c("Tier1_Exact", "Tier2_Team", "Tier3_FullName", "Tier4_Initial"))) %>%
    slice_head(n = 1) %>%
    ungroup()
  
  # Apply matches to ALL expected data - PRESERVE EVERYTHING
  matched_data <- expected_with_names %>%
    left_join(
      final_matches %>% 
      select(Last_Name, First_Initial, Expected_NECBL_Abbrev, wOBA, wOBACON, 
             Season, Team, Team_Abbrev, Player_Season_ID, match_tier), 
      by = c("Last_Name", "First_Initial", "Expected_NECBL_Abbrev")
    ) %>%
    mutate(
      # OVERLAY Actual data where available
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      
      # Enhanced data source tracking
      data_source = case_when(
        match_tier == "Tier1_Exact" ~ paste0("Expected + Actual (", selected_season, " Exact)"),
        match_tier == "Tier2_Team" ~ paste0("Expected + Actual (", selected_season, " Team)"),
        match_tier == "Tier3_FullName" ~ paste0("Expected + Actual (", selected_season, " Name)"),
        match_tier == "Tier4_Initial" ~ paste0("Expected + Actual (", selected_season, " Initial)"),
        TRUE ~ "Expected Only"
      ),
      
      # Team and season info
      actual_team_abbrev = Team_Abbrev,
      actual_season = Season
    ) %>%
    select(-Last_Name, -First_Initial, -First_Name_Full, -First_Name_Parts, 
           -First_Name, -Middle_Initial, -Expected_NECBL_Team, -Expected_NECBL_Abbrev, 
           -Expected_Player_ID, -wOBA, -wOBACON, -Season, -Team, -Team_Abbrev, 
           -Player_Season_ID, -match_tier)
  
  # Summary with match quality breakdown
  total_records <- nrow(matched_data)
  actual_overlay <- sum(!is.na(matched_data$actual_woba_final))
  
  match_summary <- matched_data %>%
    filter(!is.na(actual_woba_final)) %>%
    count(data_source, name = "matches")
  
  cat("=== MATCHING SUMMARY FOR", selected_season, "===\n")
  cat("- TOTAL EXPECTED RECORDS PRESERVED:", total_records, "(100%)\n")
  cat("- Records with Actual overlay:", actual_overlay, "\n")
  cat("- Overlay rate:", round(actual_overlay / total_records * 100, 1), "%\n")
  
  if (nrow(match_summary) > 0) {
    cat("- Match quality breakdown:\n")
    for (i in 1:nrow(match_summary)) {
      cat("  *", match_summary$data_source[i], ":", match_summary$matches[i], "\n")
    }
  }
  
  return(matched_data)
}
# Load all seasons with progress tracking
get_all_necbl_seasons <- function(progress_callback = NULL) {
  cat("=== LOADING ALL NECBL SEASONS (2021-2025) ===\n")
  
  all_seasons_data <- data.frame()
  seasons <- c("2021", "2022", "2023", "2024", "2025")
  
  for (i in seq_along(seasons)) {
    if (!is.null(progress_callback)) {
      progress_callback(detail = paste("Loading", seasons[i], "season..."), 
                       value = i / length(seasons))
    }
    
    cat("\nScraping", seasons[i], "season...\n")
    season_data <- get_necbl_woba_by_season(seasons[i])
    
    if (nrow(season_data) > 0) {
      all_seasons_data <- rbind(all_seasons_data, season_data)
      cat("Added", nrow(season_data), "records for", seasons[i], "\n")
    }
    
    # Small delay between seasons
    Sys.sleep(2)
  }
  
  cat("\n=== TOTAL NECBL DATA LOADED ===\n")
  cat("Total records across all seasons:", nrow(all_seasons_data), "\n")
  
  season_summary <- all_seasons_data %>%
    group_by(Season) %>%
    summarise(
      Players = n(),
      Teams = n_distinct(Team_Abbrev),
      .groups = "drop"
    )
  
  print(season_summary)
  
  return(all_seasons_data)
}

# Initialize with your existing data
initialize_enhanced_data <- function() {
  cat("=== INITIALIZING ENHANCED DATA ===\n")
  
  # Try to use your existing data
  if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("Using existing combined_df data\n")
    base_data <- combined_df
    
    # Ensure proper xwOBA/xwOBACON separation
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_expected_xwoba_and_full(base_data, if(exists("expected")) expected else NULL)
    }
    
  } else if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("Using raw_data and applying expected calculations\n")
    base_data <- calculate_expected_xwoba_and_full(raw_data, if(exists("expected")) expected else NULL)
    
  } else {
    cat("No existing data found - create sample data first\n")
    return(NULL)
  }
  
  # Ensure all required columns exist
  final_data <- base_data %>%
    mutate(
      predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else 0.350,
      predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else 0.400,
      
      # Initialize Actual overlay columns
      actual_woba_final = NA_real_,
      actual_wobacon_final = NA_real_,
      data_source = "Expected Only",
      actual_team_abbrev = NA_character_,
      actual_season = NA_character_
    )
  
  cat("Enhanced data initialized with", nrow(final_data), "total records\n")
  return(final_data)
}
# ===================================================================
# SHINY UI
# ===================================================================

ui <- dashboardPage(
  dashboardHeader(title = "Enhanced xwOBA Dashboard"),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Performance Analysis", tabName = "performance", icon = icon("chart-line")),
      menuItem("Underperformers", tabName = "underperform", icon = icon("arrow-down")),
      menuItem("Overperformers", tabName = "overperform", icon = icon("arrow-up")),
      menuItem("Player Comparison", tabName = "comparison", icon = icon("balance-scale")),
      menuItem("Team Browser", tabName = "browser", icon = icon("table"))
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .content-wrapper, .right-side {
          background-color: #f4f4f4;
        }
        .season-highlight {
          background-color: #fff3cd !important;
        }
        .actual-match {
          background-color: #d4edda !important;
        }
        .box-solid > .box-header {
          color: #fff;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .progress-bar {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
      "))
    ),
    
    tabItems(
      # Performance Analysis Tab
      tabItem(tabName = "performance",
        fluidRow(
          box(
            title = "Season & Filter Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, 
                selectInput("primary_season", "Primary Season:", 
                           choices = c("2025", "2024", "2023", "2022", "2021"), 
                           selected = "2025")
              ),
              column(3, 
                selectInput("season_scope", "Show Players:", 
                           choices = c("Selected Season Only" = "selected", 
                                     "All Available Seasons" = "all"), 
                           selected = "selected")
              ),
              column(3, 
                selectInput("pa_threshold", "Minimum PAs:", 
                           choices = c("All Players" = 0, "10+" = 10, "20+" = 20, "30+" = 30),
                           selected = 20)
              ),
              column(3, 
                selectInput("metric_type", "Primary Metric:", 
                           choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                           selected = "xwoba")
              )
            ),
            hr(),
            fluidRow(
              column(4,
                actionButton("load_season", "Load Selected Season", 
                            class = "btn btn-primary", icon = icon("download"))
              ),
              column(4,
                actionButton("load_all", "Load All Seasons (2021-2025)", 
                            class = "btn btn-info", icon = icon("database"))
              ),
              column(4,
                div(id = "data_status", 
                    textOutput("current_data_status", inline = TRUE))
              )
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Expected vs Actual Performance", status = "primary", solidHeader = TRUE, width = 12,
            plotlyOutput("performance_plotly", height = "600px")
          )
        ),
        
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 4,
            selectInput("focus_player", "Focus on Player:", 
                       choices = c("All Players" = ""), selected = "")
          ),
          box(
            title = "Performance Summary", status = "info", solidHeader = TRUE, width = 8,
            DT::dataTableOutput("performance_summary")
          )
        )
      ),
      
      # Underperformers Tab
      tabItem(tabName = "underperform",
        fluidRow(
          box(
            title = "Players Getting Unlucky (Expected > Actual)", 
            status = "success", solidHeader = TRUE, width = 12,
            p(paste("Players whose expected predictions exceed their actual results.",
                   "These players may be due for positive regression.")),
            DT::dataTableOutput("underperformers_table")
          )
        )
      ),
      
      # Overperformers Tab
      tabItem(tabName = "overperform",
        fluidRow(
          box(
            title = "Players Getting Lucky (Actual > Expected)", 
            status = "warning", solidHeader = TRUE, width = 12,
            p(paste("Players whose actual results exceed their expected predictions.",
                   "These players may be due for negative regression.")),
            DT::dataTableOutput("overperformers_table")
          )
        )
      ),
      
      # Player Comparison Tab
      tabItem(tabName = "comparison",
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(4, selectInput("comp_player1", "Player 1:", choices = c("Choose Player" = ""))),
              column(4, selectInput("comp_player2", "Player 2:", choices = c("Choose Player" = ""))),
              column(4, dateRangeInput("comp_date_range", "Date Range:", 
                                      start = Sys.Date() - 90, end = Sys.Date()))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Performance Comparison", status = "primary", solidHeader = TRUE, width = 12,
            plotOutput("comparison_plot", height = "500px")
          )
        ),
        
        fluidRow(
          box(
            title = "Comparison Summary", status = "info", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("comparison_summary_table")
          )
        )
      ),
      
      # Team Browser Tab
      tabItem(tabName = "browser",
        fluidRow(
          box(
            title = "Browser Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, selectInput("browser_team", "Filter by Team:", 
                                   choices = c("All Teams" = "All"))),
              column(3, selectInput("browser_player", "Filter by Player:", 
                                   choices = c("All Players" = "All"))),
              column(3, selectInput("browser_sort", "Sort by:", 
                                   choices = c("xwOBA" = "Avg_xwOBA", "wOBA" = "Avg_wOBA", 
                                             "xwOBACON" = "Avg_xwOBACON", "wOBACON" = "Avg_wOBACON", 
                                             "PAs" = "PA_Count"),
                                   selected = "Avg_xwOBA")),
              column(3, checkboxInput("show_only_matched", "Show Only Actual Matches", value = FALSE))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Team & Player Browser", status = "primary", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("browser_table")
          )
        )
      )
    )
  )
)
# ===================================================================
# SHINY SERVER
# ===================================================================

server <- function(input, output, session) {
  
  # Enhanced reactive values with proper season management
  values <- reactiveValues(
    expected_data = NULL,
    necbl_data_all = NULL,
    necbl_data_current = NULL,
    enhanced_data = NULL,
    available_seasons = character(0),
    last_update = NULL,
    loading_progress = NULL
  )
  
  # Initialize with your existing data
  observe({
    if (is.null(values$expected_data)) {
      values$expected_data <- initialize_enhanced_data()
      if (!is.null(values$expected_data)) {
        values$enhanced_data <- values$expected_data
        cat("Initialized with", nrow(values$enhanced_data), "expected records\n")
      }
    }
  })
  
  # Helper function for filtered data with season awareness
  get_filtered_data <- function() {
    req(values$enhanced_data)
    
    current_data <- values$enhanced_data
    
    if (is.null(current_data) || nrow(current_data) == 0) {
      return(data.frame())
    }
    
    # Apply season filter - FIXED to properly filter by selected season
    if (!is.null(input$season_scope) && input$season_scope == "selected" && 
        !is.null(input$primary_season)) {
      
      # For browser and other tabs, show only players with actual data from selected season
      if ("actual_season" %in% names(current_data)) {
        current_data <- current_data %>%
          filter(actual_season == input$primary_season | is.na(actual_season)) %>%
          # If they have actual data, it must be from the selected season
          filter(is.na(actual_woba_final) | actual_season == input$primary_season)
      }
    }
    
    # Apply PA threshold
    pa_threshold <- as.numeric(input$pa_threshold %||% 0)
    if (pa_threshold > 0) {
      current_data <- current_data %>%
        group_by(Batter) %>%
        filter(n() >= pa_threshold) %>%
        ungroup()
    }
    
    return(current_data)
  }
  
  # Update UI choices dynamically
  observe({
    current_data <- get_filtered_data()
    
    if (!is.null(current_data) && nrow(current_data) > 0) {
      player_choices <- c("All Players" = "", sort(unique(current_data$Batter)))
      
      updateSelectInput(session, "focus_player", choices = player_choices)
      updateSelectInput(session, "comp_player1", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "comp_player2", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "browser_player", choices = c("All Players" = "All", sort(unique(current_data$Batter))))
      
      if ("BatterTeam" %in% names(current_data)) {
        team_choices <- c("All Teams" = "All", sort(unique(current_data$BatterTeam)))
        updateSelectInput(session, "browser_team", choices = team_choices)
      }
    }
  })
  
  # Data status output
  output$current_data_status <- renderText({
    if (!is.null(values$enhanced_data) && !is.null(values$necbl_data_current)) {
      total_players <- values$enhanced_data %>% 
        distinct(Batter) %>% 
        nrow()
      matched_players <- sum(!is.na(values$enhanced_data$actual_woba_final))
      
      paste("✓", total_players, "players,", matched_players, "with actual data")
    } else if (!is.null(values$enhanced_data)) {
      total_players <- values$enhanced_data %>% 
        distinct(Batter) %>% 
        nrow()
      paste("Expected only:", total_players, "players")
    } else {
      "No data loaded"
    }
  })
# Load selected season
  observeEvent(input$load_season, {
    withProgress(message = paste('Loading', input$primary_season, 'season...'), value = 0, {
      
      incProgress(0.3, detail = "Scraping actual data...")
      
      tryCatch({
        # Scrape selected season
        season_data <- get_necbl_woba_by_season(input$primary_season)
        
        if (!is.null(season_data) && nrow(season_data) > 0) {
          values$necbl_data_current <- season_data
          
          # Update all seasons cache if it exists
          if (!is.null(values$necbl_data_all)) {
            values$necbl_data_all <- values$necbl_data_all %>%
              filter(Season != input$primary_season) %>%
              rbind(season_data)
          } else {
            values$necbl_data_all <- season_data
          }
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.6, detail = "Matching with expected data...")
          
          # Re-match with expected data
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data(values$expected_data, values$necbl_data_all, input$primary_season)
          }
          
          incProgress(1.0, detail = "Complete!")
          
          total_records <- nrow(values$enhanced_data)
          actual_records <- sum(!is.na(values$enhanced_data$actual_woba_final))
          
          showNotification(
            paste("✅", input$primary_season, "season loaded!", actual_records, "players matched"),
            type = "message", duration = 8 
          )
        } else {
          showNotification(
            paste("❌ No data found for", input$primary_season, "season"),
            type = "error", duration = 10
          )
        }
      }, error = function(e) {
        showNotification(
          paste("❌ Error loading", input$primary_season, ":", e$message),
          type = "error", duration = 15
        )
      })
    })
  })
  
  # Load all seasons
  observeEvent(input$load_all, {
    withProgress(message = 'Loading all NECBL seasons (2021-2025)...', value = 0, {
      
      tryCatch({
        # Use progress callback
        progress_func <- function(detail = "", value = 0) {
          incProgress(value * 0.8, detail = detail)
        }
        
        values$necbl_data_all <- get_all_necbl_seasons(progress_func)
        
        if (!is.null(values$necbl_data_all) && nrow(values$necbl_data_all) > 0) {
          values$necbl_data_current <- values$necbl_data_all %>%
            filter(Season == input$primary_season)
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.9, detail = "Matching with expected data...")
          
          # Re-match with expected data
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data(values$expected_data, values$necbl_data_all, input$primary_season)
          }
          
          incProgress(1.0, detail = "All seasons loaded!")
          
          total_records <- nrow(values$necbl_data_all)
          matched_records <- sum(!is.na(values$enhanced_data$actual_woba_final))
          n_seasons <- length(values$available_seasons)
          
          showNotification(
            paste("✅ All seasons loaded!", total_records, "total records,", matched_records, "matched,", n_seasons, "seasons"),
            type = "message", duration = 12
          )
        } else {
          showNotification("❌ Error loading season data", type = "error", duration = 10)
        }
      }, error = function(e) {
        showNotification(paste("❌ Error loading all seasons:", e$message), type = "error", duration = 15)
      })
    })
  })
# Enhanced performance plot with plotly
  output$performance_plotly <- renderPlotly({
    current_data <- get_filtered_data()
    
    if (nrow(current_data) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data available\nLoad season data first"), size = 6) +
        theme_void()
      return(ggplotly(p))
    }
    
    # Filter for specific player if selected
    if (!is.null(input$focus_player) && input$focus_player != "") {
      current_data <- current_data %>% filter(Batter == input$focus_player)
      plot_title <- paste("Performance Analysis:", input$focus_player)
    } else {
      plot_title <- paste("Performance Analysis:", input$primary_season, "Season")
    }
    
    # Calculate player-level performance metrics
    player_performance <- current_data %>%
      group_by(Batter) %>%
      summarise(
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        xwOBACON = mean(predicted_xwobacon_final, na.rm = TRUE),
        wOBACON = mean(actual_wobacon_final, na.rm = TRUE),
        PA_Count = n(),
        Has_Actual = !all(is.na(actual_woba_final)),
        Data_Source = first(data_source),
        Team = first(BatterTeam),
        Actual_Season = first(actual_season),
        .groups = "drop"
      ) %>%
      filter(Has_Actual)
    
    if (nrow(player_performance) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, 
                     label = paste0("No players with ", input$primary_season, " actual data\n\nClick 'Load Selected Season' or 'Load All Seasons'")), 
                  size = 6, color = "#667eea") +
        theme_void()
      return(ggplotly(p))
    }
    
    # Select metrics based on input
    if (input$metric_type == "xwoba") {
      plot_data <- player_performance %>%
        select(Batter, xwOBA, wOBA, PA_Count, Data_Source, Team, Actual_Season) %>%
        rename(Expected = xwOBA, Actual = wOBA)
      x_label <- paste("wOBA (Actual", input$primary_season, ")")
      y_label <- "xwOBA (Expected)"
    } else {
      plot_data <- player_performance %>%
        select(Batter, xwOBACON, wOBACON, PA_Count, Data_Source, Team, Actual_Season) %>%
        rename(Expected = xwOBACON, Actual = wOBACON)
      x_label <- paste("wOBACON (Actual", input$primary_season, ")")
      y_label <- "xwOBACON (Expected)"
    }
    
    # Create enhanced scatter plot
    p <- ggplot(plot_data, aes(x = Actual, y = Expected, text = paste(
      "Player:", Batter,
      "<br>Team:", Team,
      "<br>PAs:", PA_Count,
      "<br>Expected:", round(Expected, 3),
      "<br>Actual:", round(Actual, 3),
      "<br>Difference:", round(Expected - Actual, 3)
    ))) +
      geom_point(aes(color = Data_Source), size = 4, alpha = 0.7) +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "#dc3545", size = 1) +
      scale_color_manual(values = setNames(
        c("#28a745", "#20c997", "#fd7e14", "#ffc107"),
        c(paste0("Expected + Actual (", input$primary_season, " Exact)"),
          paste0("Expected + Actual (", input$primary_season, " Team)"),
          paste0("Expected + Actual (", input$primary_season, " Name)"),
          paste0("Expected + Actual (", input$primary_season, " Initial)"))
      )) +
      labs(title = plot_title,
           x = x_label, y = y_label, color = "Match Quality") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        title = list(text = plot_title, font = list(size = 16)),
        showlegend = TRUE
      )
  })
# Performance summary table
  output$performance_summary <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    if (nrow(current_data) == 0) return(data.frame())
    
    summary_data <- current_data %>%
      filter(!is.na(actual_woba_final)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Actual_Season = first(actual_season),
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      arrange(desc(abs(wOBA_Diff)))
    
    DT::datatable(
      summary_data,
      options = list(pageLength = 10, scrollX = TRUE),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle('Actual_Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd')) %>%
      formatStyle(columns = c('wOBA_Diff', 'wOBACON_Diff'), 
                  backgroundColor = styleInterval(c(-0.025, 0.025), c('#f8d7da', '#ffffff', '#d4edda')))
  })
  
  # Underperformers table
  output$underperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    underperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        Actual_Team = first(actual_team_abbrev),
        Actual_Season = first(actual_season),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      underperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Unlucky -", input$primary_season, "Season Focus"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#d4edda') %>%
      formatStyle('Actual_Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd'))
  })
# Overperformers table
  output$overperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    overperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        Actual_Team = first(actual_team_abbrev),
        Actual_Season = first(actual_season),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(wOBA - xwOBA, 3),
        wOBACON_Diff = round(wOBACON - xwOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      overperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Lucky -", input$primary_season, "Season Focus"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#f8d7da') %>%
      formatStyle('Actual_Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd'))
  })
  
  # Player comparison plot
  output$comparison_plot <- renderPlot({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_data <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      arrange(if("Date" %in% names(.)) Date else row_number()) %>%
      group_by(Batter) %>%
      mutate(
        PA_Number = row_number(),
        Cumulative_xwOBA = cummean(predicted_xwoba_final),
        Cumulative_wOBA = cummean(actual_woba_final),
        Cumulative_xwOBACON = cummean(predicted_xwobacon_final),
        Cumulative_wOBACON = cummean(actual_wobacon_final)
      ) %>%
      ungroup()
    
    if (nrow(comparison_data) > 0) {
      line_data <- comparison_data %>%
        select(Batter, PA_Number, Cumulative_xwOBA, Cumulative_wOBA, Cumulative_xwOBACON, Cumulative_wOBACON) %>%
        pivot_longer(cols = starts_with("Cumulative"), names_to = "Metric", values_to = "Value") %>%
        mutate(
          Metric = gsub("Cumulative_", "", Metric),
          Line_Type = ifelse(grepl("x", Metric), "Expected", paste("Actual (", input$primary_season, ")")),
          Metric_Type = ifelse(grepl("OBACON", Metric), "wOBACON (Batted Balls)", "wOBA (All PAs)")
        ) %>%
        filter(!is.na(Value))
      
      ggplot(line_data, aes(x = PA_Number, y = Value, color = Batter, linetype = Line_Type)) +
        geom_line(size = 1.2, alpha = 0.8) +
        facet_wrap(~Metric_Type, scales = "free_y") +
        scale_color_manual(values = c("#667eea", "#764ba2")) +
        scale_linetype_manual(values = setNames(
          c("solid", "dashed"),
          c("Expected", paste0("Actual (", input$primary_season, ")"))
        )) +
        labs(title = paste("Performance Comparison:", input$comp_player1, "vs", input$comp_player2),
             subtitle = paste("Cumulative performance -", input$primary_season, "season focus"),
             x = "Plate Appearance Number", y = "Cumulative Value",
             color = "Player", linetype = "Type") +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 16, face = "bold"),
          legend.position = "top"
        )
    } else {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data for selected players"), size = 6) +
        theme_void()
    }
  })
# Comparison summary table
  output$comparison_summary_table <- DT::renderDataTable({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_summary <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        Actual_Team = first(actual_team_abbrev),
        Actual_Season = first(actual_season),
        Data_Source = first(data_source),
        .groups = "drop"
      )
    
    DT::datatable(
      comparison_summary,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Player Comparison Summary -", input$primary_season, "Season Focus"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
      formatStyle('Actual_Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd'))
  })
  
  # Team browser table
  output$browser_table <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    if (!is.null(input$browser_team) && input$browser_team != "All") {
      if ("BatterTeam" %in% names(current_data)) {
        current_data <- current_data %>% filter(BatterTeam == input$browser_team)
      }
    }
    
    if (!is.null(input$browser_player) && input$browser_player != "All") {
      current_data <- current_data %>% filter(Batter == input$browser_player)
    }
    
    browser_data <- current_data %>%
      group_by(Batter) %>%
      summarise(
        PA_Count = n(),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        Actual_Team = first(actual_team_abbrev),
        Actual_Season = first(actual_season),
        Data_Source = first(data_source),
        Has_Actual = !all(is.na(actual_woba_final)),
        .groups = "drop"
      )
    
    # Apply actual filter if requested
    if (!is.null(input$show_only_matched) && input$show_only_matched) {
      browser_data <- browser_data %>% filter(Has_Actual)
    }
    
    # IMPORTANT: Only show players with actual data from the selected season
    if (!is.null(input$season_scope) && input$season_scope == "selected") {
      browser_data <- browser_data %>% 
        filter(Has_Actual & Actual_Season == input$primary_season)
    }
    
    browser_data <- browser_data %>%
      arrange(desc(!!sym(input$browser_sort)))
    
    DT::datatable(
      browser_data,
      options = list(pageLength = 25, scrollX = TRUE),
      caption = paste("Team & Player Browser -", input$primary_season, "Season Focus"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
      formatStyle("Has_Actual", backgroundColor = styleEqual(TRUE, '#d4edda')) %>%
      formatStyle('Actual_Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd'))
  })
}

# ===================================================================
# RUN APPLICATION
# ===================================================================

# Function to launch the dashboard
launch_xwoba_dashboard <- function() {
  # Check if required data exists
  if (!exists("combined_df") && !exists("raw_data")) {
    stop("No expected data found. Please ensure 'combined_df' or 'raw_data' exists in your environment.")
  }
  
  cat("🎯 Launching Enhanced xwOBA Dashboard...\n")
  cat("✅ Season-specific player parsing\n")
  cat("✅ 4-tier player matching system\n") 
  cat("✅ Interactive Plotly visualizations\n")
  cat("✅ Comprehensive performance analysis\n")
  
  shinyApp(ui = ui, server = server)
}

# Usage instructions
cat("=== ENHANCED xwOBA DASHBOARD INTEGRATION READY! ===\n\n")
cat("🚀 LAUNCH COMMAND:\n")
cat("   launch_xwoba_dashboard()\n\n")
cat("📋 KEY FEATURES:\n")
cat("✅ Season-Specific Parsing: Each player-season treated as unique\n")
cat("✅ 4-Tier Matching: Exact > Team > Name > Initial fallback\n")
cat("✅ Default 2025 Focus: Shows current season by default\n")
cat("✅ Interactive Plots: Plotly integration for better exploration\n")
cat("✅ Enhanced Tables: Color-coded by season and match quality\n\n")
cat("🔧 FIXED ISSUES:\n")
cat("❌ No more multi-season player contamination\n")
cat("❌ Better disambiguation of same name players\n")
cat("❌ Season-aware filtering and display\n")
cat("❌ Proper PA integration (walks, HBP, strikeouts)\n\n")
cat("📖 USAGE:\n")
cat("1. Run: launch_xwoba_dashboard()\n")
cat("2. Click 'Load Selected Season' for quick 2025 data\n")
cat("3. Or 'Load All Seasons' for comprehensive analysis\n")
cat("4. Use season controls to focus analysis\n")
cat("5. Explore tabs for different analytical views\n\n")
cat("💡 REQUIREMENTS:\n")
cat("- Your expected data must exist as 'combined_df' or 'raw_data'\n")
cat("- Internet connection for actual data scraping\n")
cat("- Required packages: shiny, shinydashboard, DT, ggplot2, dplyr, tidyr, rvest, httr, stringr, xml2, plotly\n")
