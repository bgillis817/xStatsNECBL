# Enhanced xwOBA Dashboard - Complete R Shiny Integration
# SECTION 1: REQUIRED LIBRARIES
# ===================================================================

library(shiny)
library(shinydashboard)
library(DT)
library(ggplot2)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)
library(plotly)
# ===================================================================
# SECTION 2: ENHANCED CORE FUNCTIONS - FIXED FOR DATE COLUMN
# ===================================================================

# Enhanced xwOBA calculation with proper PA integration - SEASON-AWARE VERSION
calculate_expected_xwoba_and_full <- function(raw_data, xgb_expected = NULL) {
  cat("=== CALCULATING EXPECTED xwOBA WITH PROPER PA INTEGRATION (SEASON-AWARE) ===\n")
  
  # CRITICAL FIX: Add season extraction BEFORE any processing
  if ("Date" %in% names(raw_data)) {
    raw_data <- raw_data %>%
      mutate(
        Expected_Season = as.character(year(as.Date(Date)))
      )
    cat("Season extraction complete. Seasons found:", paste(unique(raw_data$Expected_Season), collapse = ", "), "\n")
  } else {
    # If no Date column, assume current year or add a default
    raw_data <- raw_data %>%
      mutate(Expected_Season = "2025")
    cat("No Date column found - using default season 2025\n")
  }
  
  # Step 1: Filter to batted balls with complete data
  batted_balls <- raw_data %>%
    filter(
      PlayResult %in% c("Single", "Double", "Triple", "HomeRun", "Out",
                        "FieldersChoice", "Error", "Sacrifice") &
      !is.na(ExitSpeed) & ExitSpeed > 0 &
      !is.na(Angle) & !is.na(Batter)
    )
  
  cat("Batted balls with tracking data:", nrow(batted_balls), "\n")
  
  # Outcome classification for batted balls
  batted_balls$outcome <- case_when(
    batted_balls$PlayResult %in% c("Single") ~ "single",
    batted_balls$PlayResult %in% c("Double") ~ "double", 
    batted_balls$PlayResult %in% c("Triple") ~ "triple",
    batted_balls$PlayResult %in% c("HomeRun") ~ "home_run",
    batted_balls$PlayResult %in% c("Out", "FieldersChoice", "Error", "Sacrifice") ~ "out",
    TRUE ~ "other"
  )
  
  batted_balls <- batted_balls[batted_balls$outcome != "other", ]
  
  # wOBA weights
  woba_weights_vector <- c(0.000, 0.888, 1.271, 1.616, 2.101)
  
  # Get expected predictions for batted balls
  if (!is.null(xgb_expected) && exists("dtest")) {
    test_probs <- predict(xgb_expected, dtest, reshape = TRUE)
    colnames(test_probs) <- c("P_out", "P_single", "P_double", "P_triple", "P_home_run")
    predicted_xwobacon <- as.vector(test_probs %*% woba_weights_vector)
    batted_balls$predicted_xwobacon <- predicted_xwobacon
  } else {
    # Fallback calculation if expected objects not available
    batted_balls$predicted_xwobacon <- pmin(2.5, pmax(0, 
      0.1 + (batted_balls$ExitSpeed - 60) * 0.01 + 
      pmax(0, 30 - abs(batted_balls$Angle - 20)) * 0.005
    ))
  }
  
  cat("xwOBACON calculated for", nrow(batted_balls), "batted balls\n")
  
  # Step 2: Get ALL plate appearances for each player BY SEASON
  all_pa <- raw_data %>% 
    filter(!is.na(Batter)) %>%
    mutate(
      pa_outcome = case_when(
        PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
        PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
        PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
        KorBB == "Walk" ~ "walk",
        KorBB == "IntentionalWalk" ~ "intentional_walk",
        PitchCall == "HitByPitch" ~ "hit_by_pitch",
        KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
        TRUE ~ "other"
      )
    ) %>%
    filter(pa_outcome != "other")
  
  cat("Total plate appearances:", nrow(all_pa), "\n")
  
  # Step 3: Calculate player-level xwOBA BY SEASON (critical fix)
  player_xwoba_full <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon, Expected_Season),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    # CRITICAL FIX: Use Expected_Season.x (from all_pa) for grouping
    mutate(
      Expected_Season = coalesce(Expected_Season.x, Expected_Season.y)
    ) %>%
    group_by(Batter, Expected_Season) %>%  # GROUP BY SEASON TOO!
    summarise(
      hits = sum(pa_outcome == "hit"),
      outs = sum(pa_outcome == "out"),
      strikeouts = sum(pa_outcome == "strikeout"),
      BB = sum(pa_outcome == "walk"),
      IBB = sum(pa_outcome == "intentional_walk"),
      SF = sum(pa_outcome == "sacrifice_fly"),
      HBP = sum(pa_outcome == "hit_by_pitch"),
      
      batted_balls_count = hits + outs,
      AB = hits + outs + strikeouts,
      total_pa = AB + BB - IBB + SF + HBP,
      
      mean_xwobacon = mean(predicted_xwobacon, na.rm = TRUE),
      
      wBB_HBP = 0.690,
      xwoba_numerator = (mean_xwobacon * batted_balls_count) + (wBB_HBP * (BB - IBB + HBP)),
      predicted_xwoba_full = ifelse(total_pa > 0, xwoba_numerator / total_pa, NA_real_),
      
      .groups = "drop"
    )
  
  cat("Player-level xwOBA calculated for", nrow(player_xwoba_full), "player-season combinations\n")
  
  # Step 4: Merge back to individual PA level WITH SEASON AWARENESS
  enhanced_data <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    left_join(
      player_xwoba_full %>% select(Batter, Expected_Season, predicted_xwoba_full, mean_xwobacon),
      by = c("Batter", "Expected_Season")  # JOIN ON BOTH PLAYER AND SEASON
    ) %>%
    mutate(
      predicted_xwoba_final = predicted_xwoba_full,
      predicted_xwobacon_final = ifelse(!is.na(predicted_xwobacon), predicted_xwobacon, mean_xwobacon)
    )
  
  cat("=== CALCULATION SUMMARY ===\n")
  cat("Total enhanced records:", nrow(enhanced_data), "\n")
  cat("Records with xwOBA:", sum(!is.na(enhanced_data$predicted_xwoba_final)), "\n")
  cat("Records with xwOBACON:", sum(!is.na(enhanced_data$predicted_xwobacon_final)), "\n")
  
  # Show season breakdown
  if ("Expected_Season" %in% names(enhanced_data)) {
    season_summary <- enhanced_data %>%
      group_by(Expected_Season) %>%
      summarise(
        Players = n_distinct(Batter),
        Records = n(),
        .groups = "drop"
      )
    cat("Season breakdown:\n")
    print(season_summary)
  }
  
  return(enhanced_data)
}
# ===================================================================
# SECTION 3: NECBL TEAM MAPPING & SEASON-SPECIFIC SCRAPING
# ===================================================================

# Complete team mapping with roster URLs and season IDs - FIXED VERSION
necbl_team_mapping_enhanced <- list(
  "BRI_B" = list(
    name = "Bristol Blues", 
    abbrev = "BRI",
    team_id = "89490"
  ),
  "DAN_WES" = list(
    name = "Danbury Westerners", 
    abbrev = "DAN",
    team_id = "6402"
  ),
  "KEE_SWA" = list(
    name = "Keene SwampBats", 
    abbrev = "KSB",
    team_id = "6401"
  ),
  "MAR_VIN" = list(
    name = "Martha's Vineyard Sharks", 
    abbrev = "MV",
    team_id = "142675"
  ),
  "MYS_SCH" = list(
    name = "Mystic Schooners", 
    abbrev = "MSC",
    team_id = "11912"
  ),
  "NEW_GUL" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458"
  ),
  "NOR_ADA" = list(
    name = "North Adams Steeplecats", 
    abbrev = "NSC",
    team_id = "6404"
  ),
  # FIXED: Added NSH_N mapping
  "NSH_N" = list(
    name = "North Shore Navigators", 
    abbrev = "NSN",
    team_id = "154432"
  ),
  # Ocean State Waves - handles both OCE_STA and OCE_STA6
  "OCE_STA" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489"
  ),
  "OCE_STA6" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489"
  ),
  "SAN_MAI" = list(
    name = "Sanford Mainers", 
    abbrev = "SM",
    team_id = "6459"
  ),
  "UPP_VAL" = list(
    name = "Upper Valley Nighthawks", 
    abbrev = "UVNH",
    team_id = "104040"
  ),
  "VAL_BLU" = list(
    name = "Valley Blue Sox", 
    abbrev = "VAL",
    team_id = "6403"
  ),
  "VER_MOU" = list(
    name = "Vermont Mountaineers", 
    abbrev = "VM",
    team_id = "6405"
  ),
  # Additional mappings for unmapped teams
  "WIN_MUS" = list(
    name = "Winnipesaukee Muskrats", 
    abbrev = "WM",
    team_id = "6406"
  ),
  "NWL_WB" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458"
  ),
  "NEC_EAS" = list(
    name = "NECBL East", 
    abbrev = "NE",
    team_id = "unknown"
  ),
  "NEC_WES" = list(
    name = "NECBL West", 
    abbrev = "NW", 
    team_id = "unknown"
  )
)

# NECBL URLs by season with proper season IDs
necbl_urls_by_season <- list(
  "2025" = list(seasonid = "34029"),
  "2024" = list(seasonid = "33860"),
  "2023" = list(seasonid = "33589"),
  "2022" = list(seasonid = "33205"),
  "2021" = list(seasonid = "32746")
)

# Helper function to create composite keys
create_composite_key <- function(last_name, first_initial, team_abbrev, season) {
  paste(
    toupper(trimws(last_name)),
    toupper(trimws(first_initial)),
    toupper(trimws(team_abbrev)),
    season,
    sep = "_"
  )
}

# Helper function to extract team info from model team codes
get_team_info_from_model_code <- function(model_team_code) {
  team_info <- necbl_team_mapping_enhanced[[model_team_code]]
  if (!is.null(team_info)) {
    return(list(
      name = team_info$name,
      abbrev = team_info$abbrev,
      team_id = team_info$team_id
    ))
  } else {
    return(list(name = NA_character_, abbrev = "UNK", team_id = NA_character_))
  }
}
# ===================================================================
# SECTION 4: ENHANCED SCRAPER WITH COMPOSITE KEY GENERATION & FIXES
# ===================================================================

# Enhanced scraper with composite key generation for exact matching
get_necbl_woba_by_season <- function(season = "2025") {
  cat("=== SCRAPING NECBL", season, "SEASON WITH COMPOSITE KEYS ===\n")
  
  season_info <- necbl_urls_by_season[[season]]
  if (is.null(season_info)) {
    cat("ERROR: Season", season, "not available\n")
    return(data.frame())
  }
  
  seasonid <- season_info$seasonid
  all_woba <- data.frame()
  
  cat("Using UNIVERSAL URL format with leagueid=204 for all teams\n")
  
  for (team_code in names(necbl_team_mapping_enhanced)) {
    team_info <- necbl_team_mapping_enhanced[[team_code]]
    team_name <- team_info$name
    team_abbrev <- team_info$abbrev
    team_id <- team_info$team_id
    
    # Skip duplicate Ocean State entries (we only need to scrape once)
    if (team_code == "OCE_STA6") next
    # Skip other duplicate entries
    if (team_code %in% c("NWL_WB", "WIN_MUS", "NEC_EAS", "NEC_WES")) next
    
    # UNIVERSAL FORMAT: ALL seasons and ALL teams use leagueid=204
    url <- paste0("http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=", 
                 seasonid, "&teamid=", team_id)
    
    cat("Scraping", team_name, "(", team_abbrev, ") for", season, "...\n")
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"), timeout(15))
      if (status_code(response) != 200) {
        cat("HTTP", status_code(response), "for", team_name, "\n")
        next
      }
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            # Find required columns
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) next
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                # Skip invalid rows
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                # Extract stats
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                # Extract other stats with defaults
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                # Calculate singles and metrics
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  # wOBA: weighted value / PAs
                  actual_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                  triples_val * 1.616 + hr_val * 2.101 + 
                                  (bb_val + hbp_val) * 0.690) / PA
                  
                  # wOBACON: weighted value / Batted_Balls
                  actual_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                     triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  # Enhanced player name parsing for composite key generation
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  
                  # CRITICAL FIX: Remove unwanted "X" characters from pointstreak names
                  # Remove leading "X " or "x " that appears in some NECBL data
                  clean_name <- str_trim(gsub("^[Xx]\\s+", "", clean_name))
                  
                  # Parse name more carefully
                  if (grepl(",", clean_name)) {
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    
                    # Extract first name and first initial
                    first_words <- str_split(first_part, "\\s+")[[1]]
                    first_name <- first_words[1]
                    first_initial <- substr(first_name, 1, 1)
                    
                  } else {
                    words <- str_split(clean_name, "\\s+")[[1]]
                    if (length(words) >= 2) {
                      first_name <- words[1]
                      first_initial <- substr(first_name, 1, 1)
                      last_name <- paste(words[2:length(words)], collapse = " ")
                    } else {
                      last_name <- clean_name
                      first_name <- substr(clean_name, 1, 1)
                      first_initial <- substr(clean_name, 1, 1)
                    }
                  }
                  
                  # COMPOSITE KEY GENERATION - This is the key improvement!
                  composite_key <- create_composite_key(last_name, first_initial, team_abbrev, season)
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Name = str_trim(first_name),
                    First_Initial = toupper(str_trim(first_initial)),
                    Player_Team_Season_Key = composite_key,  # NEW: Composite key for exact matching
                    wOBA = round(actual_wOBA, 3),
                    wOBACON = round(actual_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    Singles = singles_val,
                    Doubles = doubles_val,
                    Triples = triples_val,
                    HRs = hr_val,
                    BBs = bb_val,
                    HBPs = hbp_val,
                    SOs = so_val,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                cat("Error processing row", row_idx, "for", team_name, ":", e$message, "\n")
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
            }
            break
          }
        }
      }
    }, error = function(e) {
      cat("ERROR scraping", team_name, ":", e$message, "\n")
    })
    
    Sys.sleep(1.5)  # Be respectful to the server
  }
  
  # Verify composite key uniqueness and handle duplicates
  if (nrow(all_woba) > 0) {
    duplicate_keys <- all_woba %>%
      group_by(Player_Team_Season_Key) %>%
      filter(n() > 1) %>%
      ungroup()
    
    if (nrow(duplicate_keys) > 0) {
      cat("WARNING: Found", nrow(duplicate_keys), "duplicate composite keys - removing duplicates:\n")
      print(duplicate_keys %>% select(Player, Player_Team_Season_Key, Team))
      
      # Keep only the first occurrence of each duplicate key
      all_woba <- all_woba %>%
        group_by(Player_Team_Season_Key) %>%
        slice_head(n = 1) %>%
        ungroup()
      
      cat("‚úÖ Duplicates removed -", nrow(all_woba), "unique records remaining\n")
    } else {
      cat("‚úÖ All composite keys are unique!\n")
    }
  }
  
  cat("Total players with calculated wOBA/wOBACON for", season, ":", nrow(all_woba), "\n")
  cat("Sample composite keys:\n")
  if (nrow(all_woba) > 0) {
    print(head(all_woba %>% select(Player, Player_Team_Season_Key), 3))
  }
  
  return(all_woba)
}
# ===================================================================
# SECTION 5: SIMPLIFIED MATCHING FUNCTION WITH COMPOSITE KEYS - SEASON-AWARE VERSION
# ===================================================================

# MASSIVELY SIMPLIFIED: No more 4-tier matching - just exact composite key joins! - NOW SEASON-AWARE
match_necbl_data_composite <- function(expected_data, necbl_data, selected_season = "2025") {
  cat("=== MATCHING WITH COMPOSITE KEYS (EXACT JOINS ONLY) - SEASON-AWARE ===\n")
  cat("Expected records (PRIMARY):", nrow(expected_data), "\n")
  cat("NECBL records (OVERLAY):", nrow(necbl_data), "\n")
  cat("Selected season:", selected_season, "\n")
  
  # CRITICAL FIX: Filter expected data to selected season FIRST - HANDLE BOTH DATE AND EXPECTED_SEASON
  if ("Expected_Season" %in% names(expected_data)) {
    expected_season_data <- expected_data %>%
      filter(Expected_Season == selected_season)
    cat("Expected records filtered to", selected_season, ":", nrow(expected_season_data), "\n")
  } else if ("Date" %in% names(expected_data)) {
    # Extract season from Date if Expected_Season doesn't exist
    expected_season_data <- expected_data %>%
      mutate(Expected_Season = as.character(year(as.Date(Date)))) %>%
      filter(Expected_Season == selected_season)
    cat("Expected records filtered to", selected_season, "via Date:", nrow(expected_season_data), "\n")
  } else {
    # If no season info, return all expected data but warn
    cat("WARNING: No season information in expected data - using all records\n")
    expected_season_data <- expected_data %>%
      mutate(Expected_Season = selected_season)
  }
  
  # Filter NECBL data to selected season ONLY
  necbl_season_data <- necbl_data %>%
    filter(Season == selected_season)
  
  cat("NECBL records for", selected_season, ":", nrow(necbl_season_data), "\n")
  
  # Generate composite keys for expected data - USING THE SELECTED SEASON
  expected_with_keys <- expected_season_data %>%
    mutate(
      # Parse expected data names: "Last Name, First Name" format
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Name_Full = trimws(sub(".*,\\s*", "", Batter)),
      First_Initial = toupper(substr(First_Name_Full, 1, 1)),
      
      # Get team abbreviation from BatterTeam using enhanced mapping
      Team_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      }),
      
      # Generate composite key for expected data - CRITICAL: USE SELECTED SEASON
      Expected_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, selected_season)
    )
  
  cat("Generated", nrow(expected_with_keys), "composite keys for expected data in", selected_season, "\n")
  
  # Show sample expected keys for verification
  cat("Sample expected composite keys for", selected_season, ":\n")
  sample_keys <- expected_with_keys %>% 
    distinct(Batter, Expected_Composite_Key, BatterTeam) %>% 
    head(3)
  print(sample_keys)
  
  # If no NECBL data for selected season, return expected-only
  if (nrow(necbl_season_data) == 0) {
    cat("No NECBL data for", selected_season, "- returning expected data only\n")
    return(expected_with_keys %>%
           select(-Last_Name, -First_Initial, -First_Name_Full, -Team_Abbrev, -Expected_Composite_Key) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Expected Only",
             necbl_composite_key = NA_character_,
             match_quality = "No NECBL Data"
           ))
  }
  
  # If no expected data for selected season, return empty
  if (nrow(expected_with_keys) == 0) {
    cat("No expected data for", selected_season, "- returning empty dataset\n")
    return(data.frame())
  }
  
  # SIMPLE EXACT JOIN ON COMPOSITE KEYS - No complex tiers!
  joined_data <- expected_with_keys %>%
    left_join(
      necbl_season_data %>% 
      select(Player_Team_Season_Key, Player, wOBA, wOBACON, Team, Team_Abbrev, PA, Batted_Balls), 
      by = c("Expected_Composite_Key" = "Player_Team_Season_Key")
    )
  
  # Check what columns we actually have after the join
  cat("Columns after join:", paste(names(joined_data), collapse = ", "), "\n")
  
  matched_data <- joined_data %>%
    mutate(
      # Overlay actual data where available
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      necbl_composite_key = Expected_Composite_Key,
      
      # Simple match quality
      match_quality = case_when(
        !is.na(wOBA) ~ paste0("Exact Match (", selected_season, ")"),
        TRUE ~ "No Match"
      ),
      
      # Data source
      data_source = case_when(
        !is.na(wOBA) ~ paste0("Expected + Actual (", selected_season, ")"),
        TRUE ~ "Expected Only"
      ),
      
      # NECBL player info - SAFELY HANDLE COLUMN NAMES
      necbl_player_name = if("Player" %in% names(.)) Player else NA_character_,
      necbl_team = if("Team" %in% names(.)) Team else NA_character_,
      necbl_team_abbrev = if("Team_Abbrev" %in% names(.)) Team_Abbrev else NA_character_,
      necbl_pa = if("PA" %in% names(.)) PA else NA_integer_,
      necbl_batted_balls = if("Batted_Balls" %in% names(.)) Batted_Balls else NA_integer_
    ) %>%
    # Clean up temporary columns - ONLY REMOVE COLUMNS THAT WE CREATED
    select(-Last_Name, -First_Initial, -First_Name_Full, -Expected_Composite_Key) %>%
    # Remove the joined columns that we've copied to new names
    select(-any_of(c("Player", "wOBA", "wOBACON", "Team", "Team_Abbrev", "PA", "Batted_Balls")))
  
  # MATCHING SUMMARY
  total_records <- nrow(matched_data)
  exact_matches <- sum(!is.na(matched_data$actual_woba_final))
  match_rate <- round(exact_matches / total_records * 100, 1)
  
  cat("\n=== SEASON-AWARE COMPOSITE KEY MATCHING SUMMARY ===\n")
  cat("üéØ SEASON FOCUS:", selected_season, "\n")
  cat("‚úÖ EXPECTED RECORDS FOR", selected_season, ":", total_records, "(100%)\n")
  cat("üéØ EXACT MATCHES FOUND:", exact_matches, "\n")
  cat("üìä MATCH RATE:", match_rate, "%\n")
  
  # Show match quality breakdown
  match_breakdown <- matched_data %>%
    count(match_quality, name = "count") %>%
    mutate(percentage = round(count / total_records * 100, 1))
  
  cat("üìà MATCH QUALITY BREAKDOWN:\n")
  for (i in 1:nrow(match_breakdown)) {
    cat("   ", match_breakdown$match_quality[i], ":", match_breakdown$count[i], 
        "(", match_breakdown$percentage[i], "%)\n")
  }
  
  # Show some successful matches for verification
  successful_matches <- matched_data %>%
    filter(!is.na(actual_woba_final)) %>%
    select(Batter, BatterTeam, necbl_player_name, necbl_team_abbrev, 
           actual_woba_final, necbl_composite_key) %>%
    head(3)
  
  if (nrow(successful_matches) > 0) {
    cat("\nüîç SAMPLE SUCCESSFUL MATCHES FOR", selected_season, ":\n")
    print(successful_matches)
  }
  
  return(matched_data)
}

# Helper function to analyze match quality - UPDATED FOR SEASON AWARENESS
analyze_match_quality <- function(matched_data) {
  cat("=== DETAILED MATCH QUALITY ANALYSIS (SEASON-AWARE) ===\n")
  
  # Overall statistics
  total <- nrow(matched_data)
  matched <- sum(!is.na(matched_data$actual_woba_final))
  
  cat("Total Expected Players:", total, "\n")
  cat("Successfully Matched:", matched, "\n")
  cat("Match Rate:", round(matched/total * 100, 1), "%\n")
  
  # Show season info if available
  if ("Expected_Season" %in% names(matched_data)) {
    season_info <- matched_data %>%
      count(Expected_Season, name = "Records") %>%
      arrange(Expected_Season)
    cat("Expected data by season:\n")
    print(season_info)
  }
  
  cat("\n")
  
  # By team analysis
  team_analysis <- matched_data %>%
    group_by(BatterTeam) %>%
    summarise(
      Total_Players = n(),
      Matched_Players = sum(!is.na(actual_woba_final)),
      Match_Rate = round(Matched_Players / Total_Players * 100, 1),
      .groups = "drop"
    ) %>%
    arrange(desc(Match_Rate))
  
  cat("MATCH RATE BY TEAM:\n")
  print(team_analysis)
  
  return(team_analysis)
}
# ===================================================================
# SECTION 6: LOAD ALL SEASONS WITH COMPOSITE KEY TRACKING
# ===================================================================

# Load all seasons with progress tracking and composite key verification
get_all_necbl_seasons_composite <- function(progress_callback = NULL) {
  cat("=== LOADING ALL NECBL SEASONS (2021-2025) WITH COMPOSITE KEYS ===\n")
  
  all_seasons_data <- data.frame()
  seasons <- c("2021", "2022", "2023", "2024", "2025")
  total_composite_keys <- 0
  
  for (i in seq_along(seasons)) {
    if (!is.null(progress_callback)) {
      progress_callback(detail = paste("Loading", seasons[i], "season..."), 
                       value = i / length(seasons))
    }
    
    cat("\nüìÖ Scraping", seasons[i], "season...\n")
    season_data <- get_necbl_woba_by_season(seasons[i])
    
    if (nrow(season_data) > 0) {
      # Verify composite keys for this season
      season_keys <- unique(season_data$Player_Team_Season_Key)
      duplicate_check <- season_data %>%
        group_by(Player_Team_Season_Key) %>%
        filter(n() > 1)
      
      if (nrow(duplicate_check) > 0) {
        cat("‚ö†Ô∏è  WARNING:", nrow(duplicate_check), "duplicate composite keys in", seasons[i], "\n")
        print(duplicate_check %>% select(Player, Player_Team_Season_Key, Team))
      } else {
        cat("‚úÖ All", length(season_keys), "composite keys unique for", seasons[i], "\n")
      }
      
      all_seasons_data <- rbind(all_seasons_data, season_data)
      total_composite_keys <- total_composite_keys + length(season_keys)
      cat("üìä Added", nrow(season_data), "records for", seasons[i], "\n")
    } else {
      cat("‚ùå No data found for", seasons[i], "\n")
    }
    
    # Small delay between seasons
    Sys.sleep(2)
  }
  
  cat("\n=== FINAL COMPOSITE KEY VERIFICATION ===\n")
  
  if (nrow(all_seasons_data) > 0) {
    # Check for any cross-season duplicates (shouldn't happen with season in key)
    all_keys <- all_seasons_data$Player_Team_Season_Key
    duplicate_keys <- all_seasons_data %>%
      group_by(Player_Team_Season_Key) %>%
      filter(n() > 1)
    
    if (nrow(duplicate_keys) > 0) {
      cat("‚ùå CRITICAL ERROR:", nrow(duplicate_keys), "duplicate composite keys across all seasons!\n")
      print(duplicate_keys %>% select(Player, Player_Team_Season_Key, Season, Team))
    } else {
      cat("‚úÖ ALL", length(unique(all_keys)), "COMPOSITE KEYS ARE GLOBALLY UNIQUE!\n")
    }
    
    # Summary statistics
    cat("\nüìà COMPOSITE KEY SUMMARY:\n")
    season_summary <- all_seasons_data %>%
      group_by(Season) %>%
      summarise(
        Players = n(),
        Unique_Keys = n_distinct(Player_Team_Season_Key),
        Teams = n_distinct(Team_Abbrev),
        Avg_wOBA = round(mean(wOBA, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(wOBACON, na.rm = TRUE), 3),
        .groups = "drop"
      ) %>%
      arrange(Season)
    
    print(season_summary)
    
    # Show sample composite keys from each season
    cat("\nüîç SAMPLE COMPOSITE KEYS BY SEASON:\n")
    sample_keys <- all_seasons_data %>%
      group_by(Season) %>%
      slice_head(n = 2) %>%
      select(Season, Player, Player_Team_Season_Key, Team_Abbrev) %>%
      ungroup()
    
    print(sample_keys)
    
  } else {
    cat("‚ùå NO DATA LOADED FROM ANY SEASON\n")
  }
  
  cat("\n=== TOTAL NECBL DATA LOADED ===\n")
  cat("üìä Total records across all seasons:", nrow(all_seasons_data), "\n")
  cat("üîë Total unique composite keys:", length(unique(all_seasons_data$Player_Team_Season_Key)), "\n")
  cat("üìÖ Seasons loaded:", paste(unique(all_seasons_data$Season), collapse = ", "), "\n")
  cat("üèüÔ∏è  Teams represented:", length(unique(all_seasons_data$Team_Abbrev)), "\n")
  
  return(all_seasons_data)
}

# Enhanced initialization with composite key support - FIXED VERSION
initialize_enhanced_data_composite <- function() {
  cat("=== INITIALIZING ENHANCED DATA WITH COMPOSITE KEY SUPPORT ===\n")
  
  # Try to use your existing data - check multiple possible names
  if (exists("pipeline_results") && is.data.frame(pipeline_results) && nrow(pipeline_results) > 0) {
    cat("‚úÖ Using existing pipeline_results data\n")
    base_data <- pipeline_results
    
    # Ensure proper xwOBA/xwOBACON separation
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("üîÑ Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_expected_xwoba_and_full(base_data, if(exists("expected")) expected else NULL)
    }
    
  } else if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("‚úÖ Using existing combined_df data\n")
    base_data <- combined_df
    
    # Ensure proper xwOBA/xwOBACON separation
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("üîÑ Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_expected_xwoba_and_full(base_data, if(exists("expected")) expected else NULL)
    }
    
  } else if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("‚úÖ Using raw_data and applying expected calculations\n")
    base_data <- calculate_expected_xwoba_and_full(raw_data, if(exists("expected")) expected else NULL)
    
  } else {
    cat("‚ùå No existing data found - create sample data first\n")
    return(NULL)
  }
  
  # Verify required columns exist
  required_cols <- c("Batter", "BatterTeam")
  missing_cols <- required_cols[!required_cols %in% names(base_data)]
  
  if (length(missing_cols) > 0) {
    cat("‚ùå MISSING REQUIRED COLUMNS:", paste(missing_cols, collapse = ", "), "\n")
    return(NULL)
  }
  
  # Check BatterTeam values against mapping
  unique_teams <- unique(base_data$BatterTeam)
  mapped_teams <- names(necbl_team_mapping_enhanced)
  unmapped_teams <- unique_teams[!unique_teams %in% mapped_teams]
  
  cat("üèüÔ∏è  TEAM CODE VERIFICATION:\n")
  cat("   Expected teams found:", paste(intersect(unique_teams, mapped_teams), collapse = ", "), "\n")
  
  if (length(unmapped_teams) > 0) {
    cat("‚ö†Ô∏è  UNMAPPED TEAM CODES:", paste(unmapped_teams, collapse = ", "), "\n")
    cat("   These will get 'UNK' abbreviation in composite keys\n")
  }
  
  # Ensure all required columns exist with proper defaults
  final_data <- base_data %>%
    mutate(
      predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else 0.350,
      predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else 0.400,
      
      # Initialize actual overlay columns for composite key matching
      actual_woba_final = NA_real_,
      actual_wobacon_final = NA_real_,
      data_source = "Expected Only",
      necbl_composite_key = NA_character_,
      match_quality = "No NECBL Data",
      necbl_player_name = NA_character_,
      necbl_team = NA_character_,
      necbl_team_abbrev = NA_character_,
      necbl_pa = NA_integer_,
      necbl_batted_balls = NA_integer_
    )
  
  # Generate sample composite keys for verification
  sample_expected_keys <- final_data %>%
    mutate(
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
      Team_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      }),
      Sample_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, "2025")
    ) %>%
    distinct(Batter, BatterTeam, Sample_Composite_Key) %>%
    head(5)
  
  cat("\nüîç SAMPLE EXPECTED COMPOSITE KEYS (for 2025):\n")
  print(sample_expected_keys)
  
  cat("\n‚úÖ Enhanced data initialized with", nrow(final_data), "total records\n")
  cat("üîë Ready for composite key matching!\n")
  
  return(final_data)
}
# ===================================================================
# SECTION 7: ENHANCED SHINY UI WITH COMPOSITE KEY FEATURES
# ===================================================================

ui <- dashboardPage(
  dashboardHeader(title = "Enhanced xwOBA Dashboard - Composite Key Edition"),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Performance Analysis", tabName = "performance", icon = icon("chart-line")),
      menuItem("Underperformers", tabName = "underperform", icon = icon("arrow-down")),
      menuItem("Overperformers", tabName = "overperform", icon = icon("arrow-up")),
      menuItem("Player Comparison", tabName = "comparison", icon = icon("balance-scale")),
      menuItem("Team Browser", tabName = "browser", icon = icon("table")),
      menuItem("Match Quality", tabName = "match_quality", icon = icon("key"))  # NEW: Match Quality tab
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .content-wrapper, .right-side {
          background-color: #f4f4f4;
        }
        .season-highlight {
          background-color: #fff3cd !important;
        }
        .exact-match {
          background-color: #d4edda !important;
        }
        .no-match {
          background-color: #f8d7da !important;
        }
        .composite-key {
          font-family: 'Courier New', monospace;
          background-color: #e9ecef;
          padding: 2px 4px;
          border-radius: 3px;
        }
        .box-solid > .box-header {
          color: #fff;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .progress-bar {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .match-rate {
          font-size: 18px;
          font-weight: bold;
        }
      "))
    ),
    
    tabItems(
      # Performance Analysis Tab
      tabItem(tabName = "performance",
        fluidRow(
          box(
            title = "Season & Filter Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, 
                selectInput("primary_season", "Primary Season:", 
                           choices = c("2025", "2024", "2023", "2022", "2021"), 
                           selected = "2025")
              ),
              column(3, 
                selectInput("season_scope", "Show Players:", 
                           choices = c("Selected Season Only" = "selected", 
                                     "All Available Seasons" = "all"), 
                           selected = "selected")
              ),
              column(3, 
                selectInput("pa_threshold", "Minimum PAs:", 
                           choices = c("All Players" = 0, "10+" = 10, "20+" = 20, "30+" = 30),
                           selected = 20)
              ),
              column(3, 
                selectInput("metric_type", "Primary Metric:", 
                           choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                           selected = "xwoba")
              )
            ),
            hr(),
            fluidRow(
              column(3,
                actionButton("load_season", "Load Selected Season", 
                            class = "btn btn-primary", icon = icon("download"))
              ),
              column(3,
                actionButton("load_all", "Load All Seasons (2021-2025)", 
                            class = "btn btn-info", icon = icon("database"))
              ),
              column(3,
                div(id = "data_status", 
                    textOutput("current_data_status", inline = TRUE))
              ),
              column(3,
                div(id = "match_rate_display",
                    textOutput("match_rate_display", inline = TRUE),
                    class = "match-rate")
              )
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Expected vs Actual Performance", status = "primary", solidHeader = TRUE, width = 12,
            plotlyOutput("performance_plotly", height = "600px")
          )
        ),
        
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 4,
            selectInput("focus_player", "Focus on Player:", 
                       choices = c("All Players" = ""), selected = "")
          ),
          box(
            title = "Performance Summary", status = "info", solidHeader = TRUE, width = 8,
            DT::dataTableOutput("performance_summary")
          )
        )
      ),
      
      # Underperformers Tab
      tabItem(tabName = "underperform",
        fluidRow(
          box(
            title = "Players Getting Unlucky (Expected > Actual)", 
            status = "success", solidHeader = TRUE, width = 12,
            p(paste("Players whose expected predictions exceed their actual results.",
                   "These players may be due for positive regression.")),
            DT::dataTableOutput("underperformers_table")
          )
        )
      ),
      
      # Overperformers Tab
      tabItem(tabName = "overperform",
        fluidRow(
          box(
            title = "Players Getting Lucky (Actual > Expected)", 
            status = "warning", solidHeader = TRUE, width = 12,
            p(paste("Players whose actual results exceed their expected predictions.",
                   "These players may be due for negative regression.")),
            DT::dataTableOutput("overperformers_table")
          )
        )
      ),
      
      # Player Comparison Tab
      tabItem(tabName = "comparison",
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(4, selectInput("comp_player1", "Player 1:", choices = c("Choose Player" = ""))),
              column(4, selectInput("comp_player2", "Player 2:", choices = c("Choose Player" = ""))),
              column(4, dateRangeInput("comp_date_range", "Date Range:", 
                                      start = Sys.Date() - 90, end = Sys.Date()))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Performance Comparison", status = "primary", solidHeader = TRUE, width = 12,
            plotOutput("comparison_plot", height = "500px")
          )
        ),
        
        fluidRow(
          box(
            title = "Comparison Summary", status = "info", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("comparison_summary_table")
          )
        )
      ),
      
      # Team Browser Tab
      tabItem(tabName = "browser",
        fluidRow(
          box(
            title = "Browser Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, selectInput("browser_team", "Filter by Team:", 
                                   choices = c("All Teams" = "All"))),
              column(3, selectInput("browser_player", "Filter by Player:", 
                                   choices = c("All Players" = "All"))),
              column(3, selectInput("browser_sort", "Sort by:", 
                                   choices = c("xwOBA" = "Avg_xwOBA", "wOBA" = "Avg_wOBA", 
                                             "xwOBACON" = "Avg_xwOBACON", "wOBACON" = "Avg_wOBACON", 
                                             "PAs" = "PA_Count"),
                                   selected = "Avg_xwOBA")),
              column(3, checkboxInput("show_only_matched", "Show Only Exact Matches", value = FALSE))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Team & Player Browser", status = "primary", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("browser_table")
          )
        )
      ),
      
      # NEW: Match Quality Tab
      tabItem(tabName = "match_quality",
        fluidRow(
          box(
            title = "Composite Key Match Quality Analysis", status = "primary", solidHeader = TRUE, width = 12,
            h4("This tab analyzes how well the composite key matching system is working."),
            p("Composite keys format: ", span("LASTNAME_FIRSTINITIAL_TEAMABBREV_SEASON", class = "composite-key")),
            p("Example: ", span("SMITH_J_BRI_2025", class = "composite-key"), " = Smith, J. on Bristol Blues in 2025")
          )
        ),
        
        fluidRow(
          box(
            title = "Match Rate Summary", status = "info", solidHeader = TRUE, width = 6,
            DT::dataTableOutput("match_rate_by_season")
          ),
          box(
            title = "Match Rate by Team", status = "info", solidHeader = TRUE, width = 6,
            DT::dataTableOutput("match_rate_by_team")
          )
        ),
        
        fluidRow(
          box(
            title = "Sample Successful Matches", status = "success", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("successful_matches_sample")
          )
        ),
        
        fluidRow(
          box(
            title = "Sample Unmatched Players", status = "warning", solidHeader = TRUE, width = 6,
            DT::dataTableOutput("unmatched_players_sample")
          ),
          box(
            title = "Available NECBL Composite Keys", status = "info", solidHeader = TRUE, width = 6,
            DT::dataTableOutput("necbl_keys_sample")
          )
        ),
        
        fluidRow(
          box(
            title = "Composite Key Verification", status = "primary", solidHeader = TRUE, width = 12,
            h5("Expected Data Sample Keys:"),
            DT::dataTableOutput("expected_keys_sample"),
            hr(),
            h5("NECBL Data Sample Keys:"),
            DT::dataTableOutput("necbl_verification_keys")
          )
        )
      )
    )
  )
)
# ===================================================================
# SECTION 8 PART 1: ENHANCED SHINY SERVER WITH COMPOSITE KEY LOGIC - SEASON-AWARE VERSION
# ===================================================================

server <- function(input, output, session) {
  
  # Enhanced reactive values with composite key support
  values <- reactiveValues(
    expected_data = NULL,
    necbl_data_all = NULL,
    necbl_data_current = NULL,
    enhanced_data = NULL,
    available_seasons = character(0),
    last_update = NULL,
    match_quality_stats = NULL
  )
  
  # Initialize with composite key support
  observe({
    if (is.null(values$expected_data)) {
      values$expected_data <- initialize_enhanced_data_composite()
      if (!is.null(values$expected_data)) {
        values$enhanced_data <- values$expected_data
        cat("‚úÖ Initialized with", nrow(values$enhanced_data), "expected records\n")
      }
    }
  })
  
  # CRITICAL FIX: Helper function for filtered data with SEASON-AWARE composite key filtering
  get_filtered_data <- function() {
    req(values$enhanced_data)
    
    current_data <- values$enhanced_data
    
    if (is.null(current_data) || nrow(current_data) == 0) {
      return(data.frame())
    }
    
    # CRITICAL FIX: Apply season filter to EXPECTED data first, not just matches
    if (!is.null(input$season_scope) && input$season_scope == "selected" && 
        !is.null(input$primary_season)) {
      
      # Filter expected data to selected season FIRST
      if ("Expected_Season" %in% names(current_data)) {
        # Use existing Expected_Season column
        current_data <- current_data %>%
          filter(Expected_Season == input$primary_season)
        cat("Filtered to", input$primary_season, "using Expected_Season:", nrow(current_data), "records\n")
      } else if ("Date" %in% names(current_data)) {
        # Extract year from Date column and filter to selected season
        current_data <- current_data %>%
          mutate(
            Expected_Season = as.character(year(as.Date(Date)))
          ) %>%
          filter(Expected_Season == input$primary_season)
        cat("Filtered to", input$primary_season, "using Date extraction:", nrow(current_data), "records\n")
      } else {
        # If no season info, warn but continue
        cat("WARNING: No season information available - showing all data\n")
      }
      
      # THEN filter matches to selected season (exact matches only)
      current_data <- current_data %>%
        filter(
          is.na(actual_woba_final) | 
          grepl(paste0("_", input$primary_season, "$"), necbl_composite_key, fixed = FALSE)
        )
    }
    
    # Apply PA threshold AFTER season filtering
    pa_threshold <- as.numeric(input$pa_threshold %||% 0)
    if (pa_threshold > 0) {
      current_data <- current_data %>%
        group_by(Batter) %>%
        filter(n() >= pa_threshold) %>%
        ungroup()
    }
    
    return(current_data)
  }
  
  # Update UI choices dynamically - SEASON-AWARE
  observe({
    current_data <- get_filtered_data()
    
    if (!is.null(current_data) && nrow(current_data) > 0) {
      player_choices <- c("All Players" = "", sort(unique(current_data$Batter)))
      
      updateSelectInput(session, "focus_player", choices = player_choices)
      updateSelectInput(session, "comp_player1", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "comp_player2", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "browser_player", choices = c("All Players" = "All", sort(unique(current_data$Batter))))
      
      if ("BatterTeam" %in% names(current_data)) {
        team_choices <- c("All Teams" = "All", sort(unique(current_data$BatterTeam)))
        updateSelectInput(session, "browser_team", choices = team_choices)
      }
    }
  })
  
  # Enhanced data status with composite key info - SEASON-AWARE
  output$current_data_status <- renderText({
    if (!is.null(values$enhanced_data)) {
      # Get season-filtered data for accurate counts
      filtered_data <- get_filtered_data()
      
      if (nrow(filtered_data) > 0) {
        total_players <- filtered_data %>% 
          distinct(Batter) %>% 
          nrow()
        
        if (!is.null(values$necbl_data_current)) {
          exact_matches <- sum(!is.na(filtered_data$actual_woba_final))
          paste("‚úÖ", total_players, "players (", input$primary_season, "),", exact_matches, "exact matches")
        } else {
          paste("üìä", input$primary_season, "expected only:", total_players, "players")
        }
      } else {
        paste("‚ùå No", input$primary_season, "data available")
      }
    } else {
      "‚ùå No data loaded"
    }
  })
  
  # NEW: Match rate display - SEASON-AWARE
  output$match_rate_display <- renderText({
    if (!is.null(values$enhanced_data) && !is.null(values$necbl_data_current)) {
      # Use season-filtered data for accurate match rate
      filtered_data <- get_filtered_data()
      
      if (nrow(filtered_data) > 0) {
        total <- nrow(filtered_data)
        matched <- sum(!is.na(filtered_data$actual_woba_final))
        match_rate <- round(matched / total * 100, 1)
        paste("üéØ", match_rate, "% match rate (", input$primary_season, ")")
      } else {
        paste("‚ùå No", input$primary_season, "data")
      }
    } else {
      ""
    }
  })
  
  # Load selected season with composite key matching - SEASON-AWARE
  observeEvent(input$load_season, {
    withProgress(message = paste('Loading', input$primary_season, 'season with composite keys...'), value = 0, {
      
      incProgress(0.3, detail = "Scraping actual data...")
      
      tryCatch({
        # Scrape selected season
        season_data <- get_necbl_woba_by_season(input$primary_season)
        
        if (!is.null(season_data) && nrow(season_data) > 0) {
          values$necbl_data_current <- season_data
          
          # Update all seasons cache
          if (!is.null(values$necbl_data_all)) {
            values$necbl_data_all <- values$necbl_data_all %>%
              filter(Season != input$primary_season) %>%
              rbind(season_data)
          } else {
            values$necbl_data_all <- season_data
          }
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.6, detail = "Matching with composite keys...")
          
          # CRITICAL FIX: Re-match with season-aware composite keys
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data_composite(
              values$expected_data, 
              values$necbl_data_all, 
              input$primary_season  # This ensures season-specific matching
            )
            
            # Calculate match quality stats
            values$match_quality_stats <- analyze_match_quality(values$enhanced_data)
          }
          
          incProgress(1.0, detail = "Complete!")
          
          # Get season-specific statistics for notification
          filtered_data <- get_filtered_data()
          total_records <- nrow(filtered_data)
          exact_matches <- sum(!is.na(filtered_data$actual_woba_final))
          match_rate <- if (total_records > 0) round(exact_matches / total_records * 100, 1) else 0
          
          showNotification(
            paste("‚úÖ", input$primary_season, "loaded!", exact_matches, "exact matches (", match_rate, "%) from", total_records, "expected records"),
            type = "message", duration = 8 
          )
        } else {
          showNotification(
            paste("‚ùå No data found for", input$primary_season, "season"),
            type = "error", duration = 10
          )
        }
      }, error = function(e) {
        showNotification(
          paste("‚ùå Error loading", input$primary_season, ":", e$message),
          type = "error", duration = 15
        )
      })
    })
  })
  
  # Load all seasons with composite key verification - SEASON-AWARE
  observeEvent(input$load_all, {
    withProgress(message = 'Loading all NECBL seasons with composite key verification...', value = 0, {
      
      tryCatch({
        # Use progress callback
        progress_func <- function(detail = "", value = 0) {
          incProgress(value * 0.8, detail = detail)
        }
        
        values$necbl_data_all <- get_all_necbl_seasons_composite(progress_func)
        
        if (!is.null(values$necbl_data_all) && nrow(values$necbl_data_all) > 0) {
          values$necbl_data_current <- values$necbl_data_all %>%
            filter(Season == input$primary_season)
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.9, detail = "Matching with composite keys...")
          
          # CRITICAL FIX: Re-match with season-aware composite keys
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data_composite(
              values$expected_data, 
              values$necbl_data_all, 
              input$primary_season  # This ensures season-specific matching
            )
            
            # Calculate comprehensive match quality stats
            values$match_quality_stats <- analyze_match_quality(values$enhanced_data)
          }
          
          incProgress(1.0, detail = "All seasons loaded with composite keys!")
          
          total_records_all <- nrow(values$necbl_data_all)
          # Get season-specific statistics for notification
          filtered_data <- get_filtered_data()
          total_records <- nrow(filtered_data)
          exact_matches <- sum(!is.na(filtered_data$actual_woba_final))
          n_seasons <- length(values$available_seasons)
          unique_keys <- length(unique(values$necbl_data_all$Player_Team_Season_Key))
          
          showNotification(
            paste("‚úÖ All seasons loaded!", total_records_all, "total records,", unique_keys, "unique keys,", exact_matches, "matches for", input$primary_season, ",", n_seasons, "seasons"),
            type = "message", duration = 12
          )
        } else {
          showNotification("‚ùå Error loading season data", type = "error", duration = 10)
        }
      }, error = function(e) {
        showNotification(paste("‚ùå Error loading all seasons:", e$message), type = "error", duration = 15)
      })
    })
  })
# Enhanced performance plot with composite key info - SEASON-AWARE VERSION
  output$performance_plotly <- renderPlotly({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    
    if (nrow(current_data) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = paste0("No data available for ", input$primary_season, "\nLoad season data first")), size = 6) +
        theme_void()
      return(ggplotly(p))
    }
    
    # Filter for specific player if selected
    if (!is.null(input$focus_player) && input$focus_player != "") {
      current_data <- current_data %>% filter(Batter == input$focus_player)
      plot_title <- paste("Performance Analysis:", input$focus_player, "(", input$primary_season, ")")
    } else {
      plot_title <- paste("Performance Analysis:", input$primary_season, "Season (Composite Key Matching)")
    }
    
    # Calculate player-level performance metrics (only exact matches) - SEASON-AWARE
    player_performance <- current_data %>%
      filter(!is.na(actual_woba_final)) %>%  # Only exact composite key matches
      group_by(Batter) %>%
      summarise(
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        xwOBACON = mean(predicted_xwobacon_final, na.rm = TRUE),
        wOBACON = mean(actual_wobacon_final, na.rm = TRUE),
        PA_Count = n(),
        Match_Quality = first(match_quality),
        Composite_Key = first(necbl_composite_key),
        NECBL_Player = first(necbl_player_name),
        Team = first(BatterTeam),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      )
    
    if (nrow(player_performance) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, 
                     label = paste0("No exact composite key matches for ", input$primary_season, "\n\nClick 'Load Selected Season' or check Match Quality tab")), 
                  size = 6, color = "#667eea") +
        theme_void()
      return(ggplotly(p))
    }
    
    # Select metrics based on input
    if (input$metric_type == "xwoba") {
      plot_data <- player_performance %>%
        select(Batter, xwOBA, wOBA, PA_Count, Match_Quality, Composite_Key, NECBL_Player, Team, Season) %>%
        rename(Expected = xwOBA, Actual = wOBA)
      x_label <- paste("wOBA (Actual", input$primary_season, ")")
      y_label <- paste("xwOBA (Expected", input$primary_season, ")")
    } else {
      plot_data <- player_performance %>%
        select(Batter, xwOBACON, wOBACON, PA_Count, Match_Quality, Composite_Key, NECBL_Player, Team, Season) %>%
        rename(Expected = xwOBACON, Actual = wOBACON)
      x_label <- paste("wOBACON (Actual", input$primary_season, ")")
      y_label <- paste("xwOBACON (Expected", input$primary_season, ")")
    }
    
    # Create enhanced scatter plot with composite key info - SEASON-AWARE
    p <- ggplot(plot_data, aes(x = Actual, y = Expected, text = paste(
      "Player:", Batter,
      "<br>NECBL Name:", NECBL_Player,
      "<br>Team:", Team,
      "<br>Season:", Season,
      "<br>PAs:", PA_Count,
      "<br>Expected:", round(Expected, 3),
      "<br>Actual:", round(Actual, 3),
      "<br>Difference:", round(Expected - Actual, 3),
      "<br>Composite Key:", Composite_Key,
      "<br>Match Quality:", Match_Quality
    ))) +
      geom_point(aes(color = Match_Quality), size = 4, alpha = 0.8) +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "#dc3545", size = 1) +
      scale_color_manual(values = c("Exact Match (2025)" = "#28a745", 
                                   "Exact Match (2024)" = "#20c997", 
                                   "Exact Match (2023)" = "#fd7e14", 
                                   "Exact Match (2022)" = "#ffc107",
                                   "Exact Match (2021)" = "#6f42c1")) +
      labs(title = plot_title,
           x = x_label, y = y_label, color = "Match Quality") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        title = list(text = plot_title, font = list(size = 16)),
        showlegend = TRUE
      )
  })
  
  # Performance summary table with composite key info - SEASON-AWARE
  output$performance_summary <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    
    if (nrow(current_data) == 0) return(data.frame())
    
    summary_data <- current_data %>%
      filter(!is.na(actual_woba_final)) %>%  # Only exact matches
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        NECBL_Player = first(necbl_player_name),
        NECBL_Team = first(necbl_team_abbrev),
        Composite_Key = first(necbl_composite_key),
        Match_Quality = first(match_quality),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      arrange(desc(abs(wOBA_Diff)))
    
    DT::datatable(
      summary_data,
      options = list(pageLength = 10, scrollX = TRUE),
      caption = paste("Performance Summary -", input$primary_season, "Season Only"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda')) %>%
      formatStyle(columns = c('wOBA_Diff', 'wOBACON_Diff'), 
                  backgroundColor = styleInterval(c(-0.025, 0.025), c('#f8d7da', '#ffffff', '#d4edda')))
  })
  
  # Underperformers table with exact matches only - SEASON-AWARE
  output$underperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    underperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%  # Only exact matches
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        NECBL_Player = first(necbl_player_name),
        NECBL_Team = first(necbl_team_abbrev),
        Composite_Key = first(necbl_composite_key),
        Match_Quality = first(match_quality),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      underperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Unlucky - Exact Composite Key Matches Only -", input$primary_season, "Season"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#d4edda') %>%
      formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda'))
  })
  
  # Overperformers table with exact matches only - SEASON-AWARE
  output$overperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    overperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%  # Only exact matches
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Expected_Team = first(BatterTeam),
        NECBL_Player = first(necbl_player_name),
        NECBL_Team = first(necbl_team_abbrev),
        Composite_Key = first(necbl_composite_key),
        Match_Quality = first(match_quality),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(wOBA - xwOBA, 3),
        wOBACON_Diff = round(wOBACON - xwOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      overperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Lucky - Exact Composite Key Matches Only -", input$primary_season, "Season"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#f8d7da') %>%
      formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda'))
  })
# ===================================================================
# SECTION 9: MATCH QUALITY TAB SERVER LOGIC - SEASON-AWARE VERSION
# ===================================================================

# Player comparison plot with exact matches - SEASON-AWARE
output$comparison_plot <- renderPlot({
  req(input$comp_player1, input$comp_player2)
  
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if ("Date" %in% names(current_data)) {
    current_data <- current_data %>%
      filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
  }
  
  comparison_data <- current_data %>%
    filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
    arrange(if("Date" %in% names(.)) Date else row_number()) %>%
    group_by(Batter) %>%
    mutate(
      PA_Number = row_number(),
      Cumulative_xwOBA = cummean(predicted_xwoba_final),
      Cumulative_wOBA = cummean(actual_woba_final),
      Cumulative_xwOBACON = cummean(predicted_xwobacon_final),
      Cumulative_wOBACON = cummean(actual_wobacon_final)
    ) %>%
    ungroup()
  
  if (nrow(comparison_data) > 0) {
    line_data <- comparison_data %>%
      select(Batter, PA_Number, Cumulative_xwOBA, Cumulative_wOBA, Cumulative_xwOBACON, Cumulative_wOBACON) %>%
      pivot_longer(cols = starts_with("Cumulative"), names_to = "Metric", values_to = "Value") %>%
      mutate(
        Metric = gsub("Cumulative_", "", Metric),
        Line_Type = ifelse(grepl("x", Metric), "Expected", paste("Actual (Exact Match", input$primary_season, ")")),
        Metric_Type = ifelse(grepl("OBACON", Metric), "wOBACON (Batted Balls)", "wOBA (All PAs)")
      ) %>%
      filter(!is.na(Value))
    
    ggplot(line_data, aes(x = PA_Number, y = Value, color = Batter, linetype = Line_Type)) +
      geom_line(size = 1.2, alpha = 0.8) +
      facet_wrap(~Metric_Type, scales = "free_y") +
      scale_color_manual(values = c("#667eea", "#764ba2")) +
      scale_linetype_manual(values = setNames(
        c("solid", "dashed"),
        c("Expected", paste0("Actual (Exact Match ", input$primary_season, ")"))
      )) +
      labs(title = paste("Performance Comparison (", input$primary_season, " Season):", input$comp_player1, "vs", input$comp_player2),
           subtitle = paste("Cumulative performance -", input$primary_season, "season exact matches only"),
           x = "Plate Appearance Number", y = "Cumulative Value",
           color = "Player", linetype = "Type") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        legend.position = "top"
      )
  } else {
    ggplot() + 
      geom_text(aes(x = 0.5, y = 0.5, label = paste0("No exact composite key matches for selected players in ", input$primary_season)), size = 6) +
      theme_void()
  }
})

# Comparison summary table with composite key info - SEASON-AWARE
output$comparison_summary_table <- DT::renderDataTable({
  req(input$comp_player1, input$comp_player2)
  
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if ("Date" %in% names(current_data)) {
    current_data <- current_data %>%
      filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
  }
  
  comparison_summary <- current_data %>%
    filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
    group_by(Batter) %>%
    summarise(
      PA = n(),
      Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
      Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
      Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
      Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
      wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
      wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
      Expected_Team = first(BatterTeam),
      NECBL_Player = first(necbl_player_name),
      NECBL_Team = first(necbl_team_abbrev),
      Composite_Key = first(necbl_composite_key),
      Match_Quality = first(match_quality),
      Has_Exact_Match = !all(is.na(actual_woba_final)),
      Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
      .groups = "drop"
    )
  
  DT::datatable(
    comparison_summary,
    options = list(pageLength = 15, scrollX = TRUE),
    caption = paste("Player Comparison Summary - Exact Composite Key Matches -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
    formatStyle('Has_Exact_Match', backgroundColor = styleEqual(TRUE, '#d4edda')) %>%
    formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda'))
})

# Enhanced team browser with composite key filtering - SEASON-AWARE
output$browser_table <- DT::renderDataTable({
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if (!is.null(input$browser_team) && input$browser_team != "All") {
    if ("BatterTeam" %in% names(current_data)) {
      current_data <- current_data %>% filter(BatterTeam == input$browser_team)
    }
  }
  
  if (!is.null(input$browser_player) && input$browser_player != "All") {
    current_data <- current_data %>% filter(Batter == input$browser_player)
  }
  
  browser_data <- current_data %>%
    group_by(Batter) %>%
    summarise(
      PA_Count = n(),
      Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
      Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
      Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
      Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
      wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
      wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
      Expected_Team = first(BatterTeam),
      NECBL_Player = first(necbl_player_name),
      NECBL_Team = first(necbl_team_abbrev),
      Composite_Key = first(necbl_composite_key),
      Match_Quality = first(match_quality),
      Has_Exact_Match = !all(is.na(actual_woba_final)),
      Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
      .groups = "drop"
    )
  
  # Apply exact match filter if requested
  if (!is.null(input$show_only_matched) && input$show_only_matched) {
    browser_data <- browser_data %>% filter(Has_Exact_Match)
  }
  
  # For composite key system: only show players with exact matches from selected season
  if (!is.null(input$season_scope) && input$season_scope == "selected") {
    browser_data <- browser_data %>% 
      filter(Has_Exact_Match & grepl(paste0("_", input$primary_season, "$"), Composite_Key, fixed = FALSE))
  }
  
  browser_data <- browser_data %>%
    arrange(desc(!!sym(input$browser_sort)))
  
  DT::datatable(
    browser_data,
    options = list(pageLength = 25, scrollX = TRUE),
    caption = paste("Team & Player Browser - Composite Key System -", input$primary_season, "Season Focus"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
    formatStyle("Has_Exact_Match", backgroundColor = styleEqual(TRUE, '#d4edda')) %>%
    formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda'))
})

# Match rate by season analysis - SEASON-AWARE
output$match_rate_by_season <- DT::renderDataTable({
  req(values$expected_data, values$necbl_data_all)
  
  # Calculate match rates across all available seasons - SEASON-AWARE
  season_analysis <- data.frame()
  
  for (season in sort(unique(values$necbl_data_all$Season))) {
    # Get expected data composite keys for this season - CRITICAL FIX
    if ("Expected_Season" %in% names(values$expected_data)) {
      expected_keys_season <- values$expected_data %>%
        filter(Expected_Season == season) %>%
        mutate(
          Last_Name = toupper(trimws(sub(",.*", "", Batter))),
          First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
          Team_Abbrev = sapply(BatterTeam, function(x) {
            team_info <- necbl_team_mapping_enhanced[[x]]
            if (!is.null(team_info)) team_info$abbrev else "UNK"
          }),
          Expected_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, season)
        ) %>%
        distinct(Batter, Expected_Key)
    } else if ("Date" %in% names(values$expected_data)) {
      expected_keys_season <- values$expected_data %>%
        mutate(
          Expected_Season = as.character(year(as.Date(Date)))
        ) %>%
        filter(Expected_Season == season) %>%
        mutate(
          Last_Name = toupper(trimws(sub(",.*", "", Batter))),
          First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
          Team_Abbrev = sapply(BatterTeam, function(x) {
            team_info <- necbl_team_mapping_enhanced[[x]]
            if (!is.null(team_info)) team_info$abbrev else "UNK"
          }),
          Expected_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, season)
        ) %>%
        distinct(Batter, Expected_Key)
    } else {
      # If no season info, skip this analysis
      next
    }
    
    # Get NECBL keys for this season
    necbl_keys_season <- values$necbl_data_all %>%
      filter(Season == season) %>%
      distinct(Player_Team_Season_Key)
    
    # Calculate matches
    matches <- sum(expected_keys_season$Expected_Key %in% necbl_keys_season$Player_Team_Season_Key)
    total_expected <- nrow(expected_keys_season)
    total_necbl <- nrow(necbl_keys_season)
    
    season_row <- data.frame(
      Season = season,
      Expected_Players = total_expected,
      NECBL_Players = total_necbl,
      Exact_Matches = matches,
      Match_Rate = round(if(total_expected > 0) matches / total_expected * 100 else 0, 1),
      Coverage = paste0(matches, "/", total_expected)
    )
    
    season_analysis <- rbind(season_analysis, season_row)
  }
  
  DT::datatable(
    season_analysis,
    options = list(pageLength = 10, dom = 't'),
    caption = "Season-Aware Composite Key Match Rates by Season",
    rownames = FALSE
  ) %>%
    formatStyle('Season', backgroundColor = styleEqual(input$primary_season, '#fff3cd')) %>%
    formatStyle('Match_Rate', 
                backgroundColor = styleInterval(c(50, 75), c('#f8d7da', '#fff3cd', '#d4edda')))
})

# Match rate by team analysis - SEASON-AWARE
output$match_rate_by_team <- DT::renderDataTable({
  req(values$enhanced_data)
  
  # Use season-filtered data for team analysis
  filtered_data <- get_filtered_data()
  
  team_analysis <- filtered_data %>%
    group_by(BatterTeam) %>%
    summarise(
      Total_Players = n_distinct(Batter),
      Exact_Matches = sum(!is.na(actual_woba_final)),
      Match_Rate = round(if(Total_Players > 0) Exact_Matches / Total_Players * 100 else 0, 1),
      Team_Name = first(sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$name else "Unknown"
      })),
      Team_Abbrev = first(sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      })),
      Coverage = paste0(Exact_Matches, "/", Total_Players),
      Season = input$primary_season,
      .groups = "drop"
    ) %>%
    arrange(desc(Match_Rate))
  
  DT::datatable(
    team_analysis,
    options = list(pageLength = 15, dom = 't'),
    caption = paste("Season-Aware Composite Key Match Rates by Team -", input$primary_season, "Season Only"),
    rownames = FALSE
  ) %>%
    formatStyle('Match_Rate', 
                backgroundColor = styleInterval(c(50, 75), c('#f8d7da', '#fff3cd', '#d4edda')))
})
# ===================================================================
# SECTION 10: FINAL LAUNCH FUNCTIONS AND USAGE INSTRUCTIONS - SEASON-AWARE VERSION
# ===================================================================

# Sample successful matches for verification - SEASON-AWARE
output$successful_matches_sample <- DT::renderDataTable({
  req(values$enhanced_data)
  
  # Use season-filtered data for samples
  filtered_data <- get_filtered_data()
  
  successful_sample <- filtered_data %>%
    filter(!is.na(actual_woba_final)) %>%
    distinct(Batter, .keep_all = TRUE) %>%
    select(
      Expected_Player = Batter,
      Expected_Team = BatterTeam,
      NECBL_Player = necbl_player_name,
      NECBL_Team = necbl_team_abbrev,
      Composite_Key = necbl_composite_key,
      Match_Quality = match_quality,
      Expected_xwOBA = predicted_xwoba_final,
      Actual_wOBA = actual_woba_final,
      Difference = predicted_xwoba_final - actual_woba_final,
      Season = if("Expected_Season" %in% names(.)) Expected_Season else input$primary_season
    ) %>%
    mutate(
      Difference = round(Difference, 3),
      Expected_xwOBA = round(Expected_xwOBA, 3),
      Actual_wOBA = round(Actual_wOBA, 3)
    ) %>%
    head(10)
  
  DT::datatable(
    successful_sample,
    options = list(pageLength = 10, scrollX = TRUE),
    caption = paste("Sample Successful Composite Key Matches -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('Expected_xwOBA', 'Actual_wOBA', 'Difference'), digits = 3) %>%
    formatStyle('Match_Quality', backgroundColor = styleEqual(paste0("Exact Match (", input$primary_season, ")"), '#d4edda')) %>%
    formatStyle('Composite_Key', 
                backgroundColor = '#e9ecef',
                fontFamily = 'Courier New, monospace')
})

# Sample unmatched players for debugging - SEASON-AWARE
output$unmatched_players_sample <- DT::renderDataTable({
  req(values$enhanced_data)
  
  # Use season-filtered data for samples
  filtered_data <- get_filtered_data()
  
  unmatched_sample <- filtered_data %>%
    filter(is.na(actual_woba_final)) %>%
    distinct(Batter, BatterTeam) %>%
    mutate(
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
      Team_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      }),
      Expected_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, input$primary_season),
      Season = input$primary_season
    ) %>%
    select(
      Expected_Player = Batter,
      Expected_Team = BatterTeam,
      Team_Abbrev,
      Expected_Composite_Key,
      Season
    ) %>%
    head(10)
  
  DT::datatable(
    unmatched_sample,
    options = list(pageLength = 10, scrollX = TRUE),
    caption = paste("Sample Unmatched Expected Players -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatStyle('Expected_Composite_Key', 
                backgroundColor = '#f8d7da',
                fontFamily = 'Courier New, monospace')
})

# Available NECBL composite keys for comparison - SEASON-AWARE
output$necbl_keys_sample <- DT::renderDataTable({
  req(values$necbl_data_current)
  
  necbl_sample <- values$necbl_data_current %>%
    select(
      NECBL_Player = Player,
      NECBL_Team = Team_Abbrev,
      Composite_Key = Player_Team_Season_Key,
      wOBA,
      wOBACON,
      PA,
      Season
    ) %>%
    mutate(
      wOBA = round(wOBA, 3),
      wOBACON = round(wOBACON, 3)
    ) %>%
    arrange(Composite_Key) %>%
    head(10)
  
  DT::datatable(
    necbl_sample,
    options = list(pageLength = 10, scrollX = TRUE),
    caption = paste("Sample NECBL Composite Keys Available -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('wOBA', 'wOBACON'), digits = 3) %>%
    formatStyle('Composite_Key', 
                backgroundColor = '#d4edda',
                fontFamily = 'Courier New, monospace')
})

# Expected data sample keys for verification - SEASON-AWARE
output$expected_keys_sample <- DT::renderDataTable({
  req(values$expected_data)
  
  # Use season-filtered data for samples
  filtered_data <- get_filtered_data()
  
  expected_sample <- filtered_data %>%
    distinct(Batter, BatterTeam) %>%
    mutate(
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
      Team_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      }),
      Expected_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, input$primary_season),
      Season = input$primary_season
    ) %>%
    select(
      Expected_Player = Batter,
      Expected_Team = BatterTeam,
      Parsed_Last = Last_Name,
      Parsed_Initial = First_Initial,
      Team_Abbrev,
      Expected_Composite_Key,
      Season
    ) %>%
    head(15)
  
  DT::datatable(
    expected_sample,
    options = list(pageLength = 15, scrollX = TRUE),
    caption = paste("Expected Data Composite Key Generation -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatStyle('Expected_Composite_Key', 
                backgroundColor = '#e9ecef',
                fontFamily = 'Courier New, monospace') %>%
    formatStyle('Team_Abbrev', 
                backgroundColor = styleEqual("UNK", '#fff3cd'))
})

# NECBL data verification keys - SEASON-AWARE
output$necbl_verification_keys <- DT::renderDataTable({
  req(values$necbl_data_current)
  
  necbl_verification <- values$necbl_data_current %>%
    select(
      NECBL_Player = Player,
      Last_Name,
      First_Initial,
      Team_Abbrev,
      Composite_Key = Player_Team_Season_Key,
      Season,
      wOBA
    ) %>%
    mutate(wOBA = round(wOBA, 3)) %>%
    arrange(Composite_Key) %>%
    head(15)
  
  DT::datatable(
    necbl_verification,
    options = list(pageLength = 15, scrollX = TRUE),
    caption = paste("NECBL Data Composite Key Generation -", input$primary_season),
    rownames = FALSE
  ) %>%
    formatRound(columns = 'wOBA', digits = 3) %>%
    formatStyle('Composite_Key', 
                backgroundColor = '#d4edda',
                fontFamily = 'Courier New, monospace')
})

}

# Function to launch the season-aware composite key enhanced dashboard
launch_xwoba_dashboard_composite <- function() {
  # Check if required data exists - check multiple possible names
  data_exists <- exists("pipeline_results") || exists("combined_df") || exists("raw_data")
  
  if (!data_exists) {
    stop("‚ùå No expected data found. Please ensure 'pipeline_results', 'combined_df', or 'raw_data' exists in your environment.")
  }
  
  cat("üéØ Launching Enhanced xwOBA Dashboard - Season-Aware Composite Key Edition...\n")
  cat("‚úÖ Season-aware composite key matching system (LASTNAME_FIRSTINITIAL_TEAMABBREV_SEASON)\n")
  cat("‚úÖ Expected data filtered by season BEFORE matching\n")
  cat("‚úÖ Exact joins only - no ambiguous fuzzy matching\n") 
  cat("‚úÖ OCE_STA and OCE_STA6 both map to Ocean State Waves\n")
  cat("‚úÖ NSH_N maps to North Shore Navigators\n")
  cat("‚úÖ 'X' character removal from NECBL player names\n")
  cat("‚úÖ FIXED: Jesse Jaconski will show only 2025 data when 2025 is selected\n")
  cat("‚úÖ FIXED: Multi-season players properly separated by season\n")
  cat("‚úÖ NEW Match Quality tab for complete transparency\n")
  cat("‚úÖ Interactive Plotly visualizations with composite key tooltips\n")
  cat("‚úÖ Season-specific filtering and analysis throughout\n")
  
  shinyApp(ui = ui, server = server)
}

# Helper function to verify data readiness - SEASON-AWARE VERSION
verify_data_readiness <- function() {
  cat("=== SEASON-AWARE DATA READINESS VERIFICATION ===\n")
  
  # Check for required data
  data_sources <- c()
  if (exists("pipeline_results")) data_sources <- c(data_sources, "pipeline_results")
  if (exists("combined_df")) data_sources <- c(data_sources, "combined_df")
  if (exists("raw_data")) data_sources <- c(data_sources, "raw_data")
  
  if (length(data_sources) == 0) {
    cat("‚ùå NO DATA FOUND\n")
    cat("   Please ensure 'pipeline_results', 'combined_df', or 'raw_data' exists in your environment\n")
    return(FALSE)
  }
  
  cat("‚úÖ DATA SOURCES FOUND:", paste(data_sources, collapse = ", "), "\n")
  
  # Get the primary data source
  if (exists("pipeline_results")) {
    primary_data <- pipeline_results
    data_name <- "pipeline_results"
  } else if (exists("combined_df")) {
    primary_data <- combined_df
    data_name <- "combined_df"
  } else {
    primary_data <- raw_data
    data_name <- "raw_data"
  }
  
  cat("üìä PRIMARY DATA SOURCE:", data_name, "with", nrow(primary_data), "records\n")
  
  # Check required columns
  required_cols <- c("Batter", "BatterTeam")
  missing_cols <- required_cols[!required_cols %in% names(primary_data)]
  
  if (length(missing_cols) > 0) {
    cat("‚ùå MISSING REQUIRED COLUMNS:", paste(missing_cols, collapse = ", "), "\n")
    return(FALSE)
  }
  
  cat("‚úÖ REQUIRED COLUMNS FOUND:", paste(required_cols, collapse = ", "), "\n")
  
  # Check for season information
  if ("Date" %in% names(primary_data)) {
    seasons_found <- primary_data %>%
      mutate(Season = as.character(year(as.Date(Date)))) %>%
      count(Season) %>%
      arrange(Season)
    
    cat("üóìÔ∏è  SEASONS FOUND IN DATA:\n")
    print(seasons_found)
  } else if ("Expected_Season" %in% names(primary_data)) {
    seasons_found <- primary_data %>%
      count(Expected_Season) %>%
      arrange(Expected_Season)
    
    cat("üóìÔ∏è  SEASONS FOUND IN DATA:\n")
    print(seasons_found)
  } else {
    cat("‚ö†Ô∏è  NO SEASON INFORMATION FOUND - will default to 2025\n")
  }
  
  # Check team codes
  unique_teams <- unique(primary_data$BatterTeam)
  mapped_teams <- names(necbl_team_mapping_enhanced)
  unmapped_teams <- unique_teams[!unique_teams %in% mapped_teams]
  
  cat("üèüÔ∏è  TEAM CODE STATUS:\n")
  cat("   Total unique team codes:", length(unique_teams), "\n")
  cat("   Mapped team codes:", length(intersect(unique_teams, mapped_teams)), "\n")
  
  if (length(unmapped_teams) > 0) {
    cat("‚ö†Ô∏è  UNMAPPED TEAM CODES:", paste(unmapped_teams, collapse = ", "), "\n")
    cat("   These will get 'UNK' abbreviation in composite keys\n")
  }
  
  # Show sample data with season info
  cat("\nüîç SAMPLE DATA PREVIEW:\n")
  if ("Date" %in% names(primary_data)) {
    sample_data <- primary_data %>%
      mutate(Season = as.character(year(as.Date(Date)))) %>%
      select(any_of(c("Batter", "BatterTeam", "Date", "Season", "Inning"))) %>%
      head(3)
  } else {
    sample_data <- primary_data %>%
      select(any_of(c("Batter", "BatterTeam", "Expected_Season", "Date", "Inning"))) %>%
      head(3)
  }
  print(sample_data)
  
  # Generate sample composite keys for different seasons
  cat("\nüîë SAMPLE COMPOSITE KEYS BY SEASON:\n")
  for (season in c("2024", "2025")) {
    sample_keys <- primary_data %>%
      distinct(Batter, BatterTeam) %>%
      mutate(
        Last_Name = toupper(trimws(sub(",.*", "", Batter))),
        First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
        Team_Abbrev = sapply(BatterTeam, function(x) {
          team_info <- necbl_team_mapping_enhanced[[x]]
          if (!is.null(team_info)) team_info$abbrev else "UNK"
        }),
        Sample_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, season)
      ) %>%
      select(Batter, BatterTeam, Sample_Composite_Key) %>%
      head(3)
    
    cat("   ", season, "season keys:\n")
    for (i in 1:nrow(sample_keys)) {
      cat("     ", sample_keys$Batter[i], "‚Üí", sample_keys$Sample_Composite_Key[i], "\n")
    }
  }
  
  cat("\n‚úÖ SEASON-AWARE DATA VERIFICATION COMPLETE - READY FOR LAUNCH!\n")
  return(TRUE)
}

# Function to test season-aware composite key system
test_composite_key_system <- function() {
  cat("=== TESTING SEASON-AWARE COMPOSITE KEY SYSTEM ===\n")
  
  # Test key generation with different seasons
  test_cases <- data.frame(
    last_name = c("Smith", "Johnson", "Smith", "Johnson"),
    first_initial = c("J", "M", "J", "M"),
    team_abbrev = c("BRI", "NG", "BRI", "NG"),
    season = c("2024", "2024", "2025", "2025")
  )
  
  cat("üß™ TESTING SEASON-AWARE COMPOSITE KEY GENERATION:\n")
  for (i in 1:nrow(test_cases)) {
    key <- create_composite_key(
      test_cases$last_name[i],
      test_cases$first_initial[i], 
      test_cases$team_abbrev[i],
      test_cases$season[i]
    )
    cat("   ", test_cases$last_name[i], test_cases$first_initial[i], 
        test_cases$team_abbrev[i], test_cases$season[i], "‚Üí", key, "\n")
  }
  
  cat("\n‚úÖ Notice how same player gets different keys for different seasons!\n")
  cat("   This ensures Jesse Jaconski's 2024 and 2025 data stay separate.\n")
  
  # Test season filtering logic
  cat("\nüóìÔ∏è  TESTING SEASON FILTERING LOGIC:\n")
  
  if (exists("pipeline_results")) {
    if ("Date" %in% names(pipeline_results)) {
      season_summary <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        count(Season, name = "Records") %>%
        arrange(Season)
      
      cat("   Seasons available in your data:\n")
      print(season_summary)
      
      # Test filtering to 2025
      test_2025 <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        filter(Season == "2025")
      
      cat("   Records when filtered to 2025:", nrow(test_2025), "\n")
      
      if (nrow(test_2025) > 0) {
        unique_players_2025 <- length(unique(test_2025$Batter))
        cat("   Unique players in 2025:", unique_players_2025, "\n")
      }
    } else {
      cat("   No Date column found - season filtering may not work optimally\n")
    }
  } else {
    cat("   No pipeline_results found - cannot test season filtering\n")
  }
  
  cat("\n‚úÖ SEASON-AWARE COMPOSITE KEY SYSTEM TEST COMPLETE!\n")
}

# Enhanced usage instructions - SEASON-AWARE VERSION
print_usage_instructions <- function() {
  cat("=== ENHANCED xwOBA DASHBOARD - SEASON-AWARE COMPOSITE KEY EDITION ===\n\n")
  
  cat("üöÄ QUICK START:\n")
  cat("   1. verify_data_readiness()              # Check if your data is ready\n")
  cat("   2. test_composite_key_system()          # Test the season-aware key generation\n")
  cat("   3. launch_xwoba_dashboard_composite()   # Launch the dashboard\n\n")
  
  cat("üîë SEASON-AWARE COMPOSITE KEY SYSTEM:\n")
  cat("   Format: LASTNAME_FIRSTINITIAL_TEAMABBREV_SEASON\n")
  cat("   Example: SMITH_J_BRI_2025 = Smith, J. on Bristol Blues in 2025\n")
  cat("   CRITICAL: Same player gets different keys for different seasons!\n")
  cat("   Benefits: Unambiguous, exact matching, no season contamination\n\n")
  
  cat("üîß KEY FIXES IN THIS VERSION:\n")
  cat("   ‚úÖ FIXED: Multi-season players (like Jesse Jaconski) properly separated\n")
  cat("   ‚úÖ FIXED: Expected data filtered by season BEFORE composite key generation\n")
  cat("   ‚úÖ FIXED: When you select 2025, only 2025 expected data is used\n")
  cat("   ‚úÖ FIXED: Season-aware matching prevents data contamination\n")
  cat("   ‚úÖ FIXED: All tables and plots show season-specific data only\n\n")
  
  cat("üìã KEY FEATURES:\n")
  cat("   ‚úÖ Season-aware composite key matching (no more cross-season contamination)\n")
  cat("   ‚úÖ Expected data properly filtered by season before analysis\n")
  cat("   ‚úÖ Match Quality tab shows season-specific match rates\n")
  cat("   ‚úÖ Interactive Plotly plots with season info in tooltips\n")
  cat("   ‚úÖ All analysis restricted to selected season only\n")
  cat("   ‚úÖ Enhanced verification and debugging tools\n")
  cat("   ‚úÖ OCE_STA/OCE_STA6 both map correctly to Ocean State Waves\n")
  cat("   ‚úÖ NSH_N maps correctly to North Shore Navigators\n")
  cat("   ‚úÖ 'X' character removal from NECBL player names\n\n")
  
  cat("üìñ DASHBOARD USAGE:\n")
  cat("   1. Launch dashboard and select your desired season (2025, 2024, etc.)\n")
  cat("   2. Click 'Load Selected Season' to get NECBL data for that season only\n")
  cat("   3. Expected data automatically filtered to match selected season\n")
  cat("   4. All analysis (plots, tables) shows only that season's data\n")
  cat("   5. Multi-season players properly separated by season\n")
  cat("   6. Visit 'Match Quality' tab to verify season-specific matching\n\n")
  
  cat("üí° JESSE JACONSKI EXAMPLE:\n")
  cat("   Before: Selecting 2025 showed combined 2024+2025 expected data\n")
  cat("   After:  Selecting 2025 shows ONLY 2025 expected data\n")
  cat("   Result: Clean season-specific analysis with no contamination\n\n")
  
  cat("‚ö†Ô∏è  REQUIREMENTS:\n")
  cat("   ‚Ä¢ Your data must have 'Batter', 'BatterTeam', and 'Date' columns\n")
  cat("   ‚Ä¢ Date column used to extract season information\n")
  cat("   ‚Ä¢ Internet connection for NECBL data scraping\n")
  cat("   ‚Ä¢ R packages: shiny, shinydashboard, DT, ggplot2, dplyr, tidyr, rvest, httr, stringr, xml2, plotly\n\n")
  
  cat("üéØ TROUBLESHOOTING:\n")
  cat("   ‚Ä¢ Player showing multiple seasons? Check if Date column exists and is formatted correctly\n")
  cat("   ‚Ä¢ Low match rates? Check Match Quality tab for season-specific issues\n")
  cat("   ‚Ä¢ No season separation? Verify Date column contains proper dates\n")
  cat("   ‚Ä¢ No data loading? Check internet connection and NECBL website status\n\n")
}

# Quick test function to verify season-aware system works
quick_composite_test <- function() {
  cat("üî• QUICK SEASON-AWARE COMPOSITE KEY TEST\n")
  
  # Test with actual data if available
  if (exists("pipeline_results")) {
    cat("‚úÖ Testing with pipeline_results...\n")
    
    # Check for season information
    if ("Date" %in% names(pipeline_results)) {
      seasons <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        count(Season) %>%
        arrange(Season)
      
      cat("‚úÖ Season information found:\n")
      print(seasons)
      
      # Test season filtering
      test_2025 <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        filter(Season == "2025")
      
      if (nrow(test_2025) > 0) {
        cat("‚úÖ Season filtering works: 2025 has", nrow(test_2025), "records\n")
        
        # Test a small scrape and match for 2025
        small_test <- tryCatch({
          get_necbl_woba_by_season("2025")
        }, error = function(e) {
          cat("‚ùå Scraping test failed:", e$message, "\n")
          return(data.frame())
        })
        
        if (nrow(small_test) > 0) {
          cat("‚úÖ Scraping works:", nrow(small_test), "players for 2025\n")
          
          # Test season-aware matching
          small_match <- match_necbl_data_composite(pipeline_results, small_test, "2025")
          matches <- sum(!is.na(small_match$actual_woba_final))
          cat("‚úÖ Season-aware matching works:", matches, "exact matches for 2025\n")
          
          if (matches > 0) {
            cat("üéâ SEASON-AWARE SYSTEM IS WORKING! Ready to launch dashboard.\n")
            return(TRUE)
          }
        }
      } else {
        cat("‚ö†Ô∏è  No 2025 data found - try different season\n")
      }
    } else {
      cat("‚ö†Ô∏è  No Date column found - season awareness may not work\n")
    }
  }
  
  cat("‚ö†Ô∏è  Test inconclusive - run verify_data_readiness() for details\n")
  return(FALSE)
}

# ===================================================================
# FINAL SETUP AND INSTRUCTIONS
# ===================================================================

# Display instructions immediately when code is loaded
cat("=== ENHANCED xwOBA DASHBOARD - SEASON-AWARE COMPOSITE KEY EDITION LOADED! ===\n\n")

print_usage_instructions()

cat("üî• READY TO LAUNCH WITH SEASON AWARENESS! Run: launch_xwoba_dashboard_composite()\n\n")

# Make main functions available in global environment
if (!exists("launch_xwoba_dashboard")) {
  assign("launch_xwoba_dashboard", launch_xwoba_dashboard_composite, envir = .GlobalEnv)
}

assign("launch_xwoba_dashboard_composite", launch_xwoba_dashboard_composite, envir = .GlobalEnv)
assign("verify_data_readiness", verify_data_readiness, envir = .GlobalEnv)
assign("test_composite_key_system", test_composite_key_system, envir = .GlobalEnv)
assign("print_usage_instructions", print_usage_instructions, envir = .GlobalEnv)
assign("quick_composite_test", quick_composite_test, envir = .GlobalEnv)

quick_composite_test()

launch_xwoba_dashboard_composite()
