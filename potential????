# Multi-Season xwOBA Dashboard with Individual Season Tracking
library(shiny)
library(ggplot2)
library(DT)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)
library(lubridate)
library(plotly)
library(shinydashboard)

# ===================================================================
# ENHANCED TEAM MAPPING WITH SEASON VARIATIONS & COMBINED TEAMS
# ===================================================================

necbl_team_mapping_enhanced <- list(
  "BRI_B" = list(
    name = "Bristol Blues", 
    abbrev = "BRI",
    team_id = "89490",
    variations = c("BRI_B", "BRISTOL", "BLUES")
  ),
  "DAN_WES" = list(
    name = "Danbury Westerners", 
    abbrev = "DAN",
    team_id = "6402",
    variations = c("DAN_WES", "DANBURY", "WESTERNERS")
  ),
  "KEE_SWA" = list(
    name = "Keene SwampBats", 
    abbrev = "KSB",
    team_id = "6401",
    variations = c("KEE_SWA", "KEENE", "SWAMPBATS")
  ),
  "MYS_SCH" = list(
    name = "Mystic Schooners", 
    abbrev = "MSC",
    team_id = "11912",
    variations = c("MYS_SCH", "MYSTIC", "SCHOONERS")
  ),
  "MAR_VIN" = list(
    name = "Martha's Vineyard Sharks", 
    abbrev = "MV",
    team_id = "142675",
    variations = c("MAR_VIN", "MARTHA", "VINEYARD", "SHARKS")
  ),
  "NEW_GUL" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458",
    variations = c("NEW_GUL", "NEWPORT", "GULLS")
  ),
  "NOR_ADA" = list(
    name = "North Adams Steeplecats", 
    abbrev = "NSC",
    team_id = "6404",
    variations = c("NOR_ADA", "NORTH_ADAMS", "STEEPLECATS")
  ),
  "NSH_N" = list(
    name = "North Shore Navigators", 
    abbrev = "NSN",
    team_id = "154432",
    variations = c("NSH_N", "NORTH_SHORE", "NAVIGATORS")
  ),
  # COMBINED OCEAN STATE TEAMS
  "OCE_STA" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489",
    variations = c("OCE_STA", "OCE_STA6", "OCEAN_STATE", "WAVES"),
    combined_teams = c("OCE_STA", "OCE_STA6")
  ),
  "SAN_MAI" = list(
    name = "Sanford Mainers", 
    abbrev = "SM",
    team_id = "6459",
    variations = c("SAN_MAI", "SANFORD", "MAINERS")
  ),
  "UPP_VAL" = list(
    name = "Upper Valley Nighthawks", 
    abbrev = "UVNH",
    team_id = "104040",
    variations = c("UPP_VAL", "UPPER_VALLEY", "NIGHTHAWKS")
  ),
  "VAL_BLU" = list(
    name = "Valley Blue Sox", 
    abbrev = "VAL",
    team_id = "6403",
    variations = c("VAL_BLU", "VALLEY", "BLUE_SOX")
  ),
  "VER_MOU" = list(
    name = "Vermont Mountaineers", 
    abbrev = "VM",
    team_id = "6405",
    variations = c("VER_MOU", "VERMONT", "MOUNTAINEERS")
  )
)

necbl_season_ids <- list(
  "2021" = "32746",
  "2022" = "33205", 
  "2023" = "33589",
  "2024" = "33860",
  "2025" = "34029"
)

# Enhanced URLs by season with proper team IDs
necbl_urls_by_season_enhanced <- list(
  "2025" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=34029&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=34029",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=34029",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=34029",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=34029",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=34029",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=34029",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=34029",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=34029",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=34029",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=34029",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=34029",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=34029"
  ),
  "2024" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=33860&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=33860",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=33860",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=33860",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=33860",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=33860",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=33860",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=33860",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=33860",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=33860",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=33860",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=33860",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=33860"
  ),
  "2023" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=33589&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=33589",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=33589",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=33589",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=33589",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=33589",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=33589",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=33589",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=33589",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=33589",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=33589",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=33589",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=33589"
  ),
  "2022" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=33205&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=33205",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=33205",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=33205",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=33205",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=33205",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=33205",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=33205",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=33205",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=33205",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=33205",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=33205",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=33205"
  ),
  "2021" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=32746&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=32746",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=32746",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=32746",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=32746",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=32746",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=32746",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=32746",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=32746",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=32746",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=32746",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=32746",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=32746"
  )
)

# ===================================================================
# CORE FUNCTIONS (Enhanced from previous artifact)
# ===================================================================

normalize_team_codes <- function(data) {
  if (!"BatterTeam" %in% names(data)) return(data)
  
  data %>%
    mutate(
      BatterTeam_Original = BatterTeam,
      BatterTeam = case_when(
        BatterTeam %in% c("OCE_STA", "OCE_STA6", "OCEAN_STATE", "OSW") ~ "OCE_STA",
        BatterTeam %in% c("BRI_B", "BRISTOL", "BLUES") ~ "BRI_B",
        BatterTeam %in% c("DAN_WES", "DANBURY", "WESTERNERS") ~ "DAN_WES",
        BatterTeam %in% c("KEE_SWA", "KEENE", "SWAMPBATS") ~ "KEE_SWA",
        BatterTeam %in% c("MYS_SCH", "MYSTIC", "SCHOONERS") ~ "MYS_SCH",
        BatterTeam %in% c("MAR_VIN", "MARTHA", "VINEYARD", "SHARKS") ~ "MAR_VIN",
        BatterTeam %in% c("NEW_GUL", "NEWPORT", "GULLS") ~ "NEW_GUL",
        BatterTeam %in% c("NOR_ADA", "NORTH_ADAMS", "STEEPLECATS") ~ "NOR_ADA",
        BatterTeam %in% c("NSH_N", "NORTH_SHORE", "NAVIGATORS") ~ "NSH_N",
        BatterTeam %in% c("SAN_MAI", "SANFORD", "MAINERS") ~ "SAN_MAI",
        BatterTeam %in% c("UPP_VAL", "UPPER_VALLEY", "NIGHTHAWKS") ~ "UPP_VAL",
        BatterTeam %in% c("VAL_BLU", "VALLEY", "BLUE_SOX") ~ "VAL_BLU",
        BatterTeam %in% c("VER_MOU", "VERMONT", "MOUNTAINEERS") ~ "VER_MOU",
        TRUE ~ BatterTeam
      )
    )
}

filter_data_by_season <- function(data, target_season = "2025", date_column = "Date") {
  if (!date_column %in% names(data)) {
    return(data %>% mutate(Season = target_season, Data_Season_Method = "No_Date_Filter"))
  }
  
  data_normalized <- normalize_team_codes(data)
  target_year <- as.numeric(target_season)
  
  data_with_season <- data_normalized %>%
    mutate(
      Date_Parsed = case_when(
        is.character(!!sym(date_column)) ~ as.Date(!!sym(date_column)),
        is.Date(!!sym(date_column)) ~ !!sym(date_column),
        TRUE ~ as.Date(!!sym(date_column))
      ),
      Year = year(Date_Parsed),
      Season = as.character(Year),
      Data_Season_Method = "Date_Based_Filter"
    ) %>%
    filter(Year == target_year)
  
  return(data_with_season)
}

get_necbl_woba_by_season_enhanced <- function(season = "2025") {
  necbl_urls <- necbl_urls_by_season_enhanced[[season]]
  if (is.null(necbl_urls)) return(data.frame())
  
  season_id <- necbl_season_ids[[season]]
  all_woba <- data.frame()
  
  for (i in seq_along(necbl_urls)) {
    team_name <- names(necbl_urls)[i]
    url <- necbl_urls[[i]]
    
    team_info <- NULL
    for (team_code in names(necbl_team_mapping_enhanced)) {
      if (necbl_team_mapping_enhanced[[team_code]]$name == team_name) {
        team_info <- necbl_team_mapping_enhanced[[team_code]]
        break
      }
    }
    
    team_abbrev <- if (!is.null(team_info)) team_info$abbrev else "UNK"
    team_id <- if (!is.null(team_info)) team_info$team_id else "Unknown"
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0"), timeout(15))
      if (status_code(response) != 200) next
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) next
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  pointstreak_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                      triples_val * 1.616 + hr_val * 2.101 + 
                                      (bb_val + hbp_val) * 0.690) / PA
                  
                  pointstreak_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                         triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  clean_name <- str_replace(clean_name, "^x\\s*", "")
                  clean_name <- str_replace(clean_name, "\\s+x\\s*", " ")
                  
                  if (grepl(",", clean_name)) {
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    first_words <- str_split(first_part, "\\s+")[[1]]
                    first_name <- first_words[1]
                    first_initial <- substr(first_name, 1, 1)
                  } else {
                    words <- str_split(clean_name, "\\s+")[[1]]
                    words <- words[words != ""]
                    
                    if (length(words) >= 2) {
                      first_name <- words[1]
                      first_initial <- substr(first_name, 1, 1)
                      last_name <- words[length(words)]
                    } else if (length(words) == 1) {
                      last_name <- words[1]
                      first_name <- words[1]
                      first_initial <- substr(words[1], 1, 1)
                    } else {
                      next
                    }
                  }
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Name = toupper(str_trim(first_name)),
                    First_Initial = toupper(str_trim(first_initial)),
                    wOBA = round(pointstreak_wOBA, 3),
                    wOBACON = round(pointstreak_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    Team_ID = team_id,
                    Season_ID = season_id,
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    BB = bb_val,
                    SO = so_val,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                # Skip problematic rows
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
            }
            break
          }
        }
      }
    }, error = function(e) {
      # Skip problematic teams
    })
    
    Sys.sleep(1)
  }
  
  return(all_woba)
}

# Enhanced matching function
match_necbl_data_enhanced <- function(model_data, necbl_data, target_season = "2025") {
  model_season_data <- filter_data_by_season(model_data, target_season)
  
  if (nrow(model_season_data) == 0) return(data.frame())
  
  model_with_names <- model_season_data %>%
    mutate(
      Original_Batter = Batter,
      Clean_Batter = str_replace_all(str_replace(str_trim(Batter), "^x\\s*", ""), "\\s+x\\s+", " "),
      Last_Name = toupper(trimws(sub(",.*", "", Clean_Batter))),
      First_Name_Full = toupper(trimws(sub(".*,\\s*", "", Clean_Batter))),
      First_Initial = toupper(substr(First_Name_Full, 1, 1)),
      First_Name = toupper(trimws(word(First_Name_Full, 1))),
      Expected_NECBL_Team = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$name else NA_character_
      }),
      Expected_NECBL_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else NA_character_
      })
    )
  
  if (nrow(necbl_data) == 0) {
    return(model_with_names %>%
           select(-Original_Batter, -Clean_Batter, -Last_Name, -First_Name_Full, 
                  -First_Initial, -First_Name, -Expected_NECBL_Team, -Expected_NECBL_Abbrev) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Model Only",
             pointstreak_team_abbrev = NA_character_,
             season_verified = target_season
           ))
  }
  
  # Enhanced matching strategies
  team_lastname_firstname_matches <- model_with_names %>%
    inner_join(necbl_data, 
               by = c("Last_Name", "First_Name", "Expected_NECBL_Team" = "Team"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "Team+LastName+FirstName_Match")
  
  remaining_model_1 <- model_with_names %>%
    anti_join(team_lastname_firstname_matches, by = c("Last_Name", "First_Initial"))
  
  remaining_necbl_1 <- necbl_data %>%
    anti_join(team_lastname_firstname_matches, by = c("Last_Name", "First_Initial"))
  
  team_lastname_initial_matches <- remaining_model_1 %>%
    inner_join(remaining_necbl_1, 
               by = c("Last_Name", "First_Initial", "Expected_NECBL_Team" = "Team"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "Team+LastName+Initial_Match")
  
  # Additional matching strategies (abbreviated for space)
  remaining_model_2 <- remaining_model_1 %>%
    anti_join(team_lastname_initial_matches, by = c("Last_Name", "First_Initial"))
  
  remaining_necbl_2 <- remaining_necbl_1 %>%
    anti_join(team_lastname_initial_matches, by = c("Last_Name", "First_Initial"))
  
  lastname_firstname_matches <- remaining_model_2 %>%
    inner_join(remaining_necbl_2, 
               by = c("Last_Name", "First_Name"),
               suffix = c("", "_necbl")) %>%
    mutate(match_quality = "LastName+FirstName_Match")
  
  # Combine all matches
  all_matches <- bind_rows(
    team_lastname_firstname_matches,
    team_lastname_initial_matches,
    lastname_firstname_matches
  ) %>%
    select(Last_Name, First_Initial, wOBA, wOBACON, Team_Abbrev, Team_ID, Season_ID, 
           PA, Batted_Balls, BB, SO, match_quality)
  
  # Apply to model data with season tracking
  matched_data <- model_season_data %>%
    mutate(
      Last_Name = toupper(trimws(sub(",.*", "", 
        str_replace_all(str_replace(str_trim(Batter), "^x\\s*", ""), "\\s+x\\s+", " ")))),
      First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", 
        str_replace_all(str_replace(str_trim(Batter), "^x\\s*", ""), "\\s+x\\s+", " "))), 1, 1))
    ) %>%
    left_join(all_matches, by = c("Last_Name", "First_Initial")) %>%
    mutate(
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      data_source = case_when(
        match_quality == "Team+LastName+FirstName_Match" ~ "Pointstreak (Team+Name+FirstName)",
        match_quality == "Team+LastName+Initial_Match" ~ "Pointstreak (Team+Name+Initial)",
        match_quality == "LastName+FirstName_Match" ~ "Pointstreak (Name+FirstName Only)",
        TRUE ~ "Model Only"
      ),
      pointstreak_team_abbrev = Team_Abbrev,
      pointstreak_team_id = Team_ID,
      pointstreak_season_id = Season_ID,
      season_verified = target_season,
      
      # Create unique player-season identifier
      player_season_id = paste(Batter, Season, sep = "_")
    ) %>%
    select(-Last_Name, -First_Initial, -wOBA, -wOBACON, -Team_Abbrev, -Team_ID, 
           -Season_ID, -PA, -Batted_Balls, -BB, -SO, -match_quality)
  
  return(matched_data)
}

# Initialize data using ACTUAL MODEL DATA - FIXED VERSION
initialize_multi_season_data <- function() {
  # Check if we have actual model data available
  if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("Using existing combined_df data with", nrow(combined_df), "records\n")
    
    # Ensure the data has the required columns and proper structure
    model_data <- combined_df %>%
      mutate(
        # Ensure we have proper season identification
        Season = if("Season" %in% names(.)) Season else as.character(year(Date)),
        
        # Ensure we have predicted metrics
        predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else 
          if("predicted_xwoba" %in% names(.)) predicted_xwoba else 0.350,
        predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else 
          if("predicted_xwobacon" %in% names(.)) predicted_xwobacon else 0.400,
        
        # Initialize Pointstreak overlay columns
        actual_woba_final = if("actual_woba_final" %in% names(.)) actual_woba_final else NA_real_,
        actual_wobacon_final = if("actual_wobacon_final" %in% names(.)) actual_wobacon_final else NA_real_,
        data_source = if("data_source" %in% names(.)) data_source else "Model Only",
        pointstreak_team_abbrev = if("pointstreak_team_abbrev" %in% names(.)) pointstreak_team_abbrev else NA_character_,
        season_verified = if("season_verified" %in% names(.)) season_verified else Season,
        
        # Create unique player-season identifier
        player_season_id = paste(Batter, Season, sep = "_")
      )
    
    # Normalize team codes using actual data
    model_data <- normalize_team_codes(model_data)
    
    cat("Processed model data:\n")
    cat("- Total records:", nrow(model_data), "\n")
    cat("- Unique players:", length(unique(model_data$Batter)), "\n")
    cat("- Seasons covered:", paste(sort(unique(model_data$Season)), collapse = ", "), "\n")
    cat("- Teams:", paste(sort(unique(model_data$BatterTeam)), collapse = ", "), "\n")
    
    return(model_data)
  }
  
  # Fallback: Check for raw_data
  if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("Using existing raw_data with", nrow(raw_data), "records\n")
    
    # Process raw data through your model pipeline
    processed_data <- raw_data %>%
      filter(
        !is.na(Batter),
        !is.na(Date)
      ) %>%
      mutate(
        # Extract season from date
        Season = as.character(year(Date)),
        
        # Calculate model predictions (simplified version)
        predicted_xwoba_final = if("predicted_xwoba" %in% names(.)) predicted_xwoba else
          pmin(2.5, pmax(0, 0.1 + (ExitSpeed - 60) * 0.01 + 
                         pmax(0, 30 - abs(Angle - 20)) * 0.005)),
        predicted_xwobacon_final = if("predicted_xwobacon" %in% names(.)) predicted_xwobacon else
          pmin(2.5, pmax(0, 0.15 + (ExitSpeed - 60) * 0.012 + 
                         pmax(0, 25 - abs(Angle - 22)) * 0.006)),
        
        # Initialize Pointstreak overlay columns
        actual_woba_final = NA_real_,
        actual_wobacon_final = NA_real_,
        data_source = "Model Only",
        pointstreak_team_abbrev = NA_character_,
        season_verified = Season,
        
        # Create unique player-season identifier
        player_season_id = paste(Batter, Season, sep = "_")
      )
    
    # Normalize team codes
    processed_data <- normalize_team_codes(processed_data)
    
    cat("Processed raw data:\n")
    cat("- Total records:", nrow(processed_data), "\n")
    cat("- Unique players:", length(unique(processed_data$Batter)), "\n")
    cat("- Seasons covered:", paste(sort(unique(processed_data$Season)), collapse = ", "), "\n")
    cat("- Teams:", paste(sort(unique(processed_data$BatterTeam)), collapse = ", "), "\n")
    
    return(processed_data)
  }
  
  # Last resort: Use any data.frame with 'Batter' column in the global environment
  batter_data_objects <- ls(envir = .GlobalEnv)[sapply(ls(envir = .GlobalEnv), function(x) {
    obj <- get(x, envir = .GlobalEnv)
    is.data.frame(obj) && "Batter" %in% names(obj) && nrow(obj) > 0
  })]
  
  if (length(batter_data_objects) > 0) {
    data_obj_name <- batter_data_objects[1]
    cat("Using", data_obj_name, "data with Batter column\n")
    
    available_data <- get(data_obj_name, envir = .GlobalEnv)
    
    processed_data <- available_data %>%
      filter(!is.na(Batter)) %>%
      mutate(
        # Handle Date column if available
        Date = if("Date" %in% names(.)) Date else Sys.Date(),
        Season = if("Season" %in% names(.)) Season else 
          if("Date" %in% names(.)) as.character(year(Date)) else "2025",
        
        # Handle BatterTeam
        BatterTeam = if("BatterTeam" %in% names(.)) BatterTeam else "UNK_TEAM",
        
        # Model predictions
        predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else
          if("predicted_xwoba" %in% names(.)) predicted_xwoba else 0.350,
        predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else
          if("predicted_xwobacon" %in% names(.)) predicted_xwobacon else 0.400,
        
        # Initialize Pointstreak overlay columns
        actual_woba_final = NA_real_,
        actual_wobacon_final = NA_real_,
        data_source = "Model Only",
        pointstreak_team_abbrev = NA_character_,
        season_verified = Season,
        
        # Create unique player-season identifier
        player_season_id = paste(Batter, Season, sep = "_")
      )
    
    # Normalize team codes if we have a BatterTeam column
    if ("BatterTeam" %in% names(processed_data)) {
      processed_data <- normalize_team_codes(processed_data)
    }
    
    cat("Processed", data_obj_name, "data:\n")
    cat("- Total records:", nrow(processed_data), "\n")
    cat("- Unique players:", length(unique(processed_data$Batter)), "\n")
    cat("- Seasons covered:", paste(sort(unique(processed_data$Season)), collapse = ", "), "\n")
    
    return(processed_data)
  }
  
# ===================================================================
# SHINY UI WITH ENHANCED SEASON CONTROLS
# ===================================================================

ui <- dashboardPage(
  dashboardHeader(title = "Multi-Season xwOBA Dashboard"),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Season Overview", tabName = "overview", icon = icon("chart-line")),
      menuItem("Player Analysis", tabName = "player_analysis", icon = icon("user")),
      menuItem("Multi-Season Tracking", tabName = "multi_season", icon = icon("calendar")),
      menuItem("Performance Analysis", tabName = "performance", icon = icon("chart-bar")),
      menuItem("Team Browser", tabName = "team_browser", icon = icon("users"))
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .content-wrapper, .right-side {
          background-color: #f4f4f4;
        }
        .season-card {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 15px;
          border-radius: 8px;
          margin: 10px 0;
        }
        .metric-box {
          background: white;
          border-radius: 8px;
          padding: 15px;
          margin: 5px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .player-highlight {
          background-color: #fff3cd;
          border: 1px solid #ffeaa7;
          border-radius: 4px;
          padding: 8px;
        }
      "))
    ),
    
    tabItems(
      # Season Overview Tab
      tabItem(tabName = "overview",
        fluidRow(
          box(width = 12, title = "Season Data Controls", status = "primary", solidHeader = TRUE,
            fluidRow(
              column(3, 
                selectInput("active_seasons", "Active Seasons:", 
                           choices = c("2021", "2022", "2023", "2024", "2025"), 
                           selected = c("2024", "2025"), multiple = TRUE)
              ),
              column(3,
                selectInput("overview_team_filter", "Filter by Team:", 
                           choices = c("All Teams" = "All"), selected = "All")
              ),
              column(3,
                selectInput("data_source_filter", "Data Source:", 
                           choices = c("All Data" = "All", "Model Only" = "Model Only", 
                                     "With Pointstreak" = "Pointstreak"), selected = "All")
              ),
              column(3,
                actionButton("refresh_all_seasons", "ðŸ”„ Refresh All Selected Seasons", 
                           class = "btn-warning", style = "margin-top: 25px;")
              )
            )
          )
        ),
        
        fluidRow(
          valueBoxOutput("total_players_box"),
          valueBoxOutput("total_seasons_box"),
          valueBoxOutput("pointstreak_coverage_box")
        ),
        
        fluidRow(
          box(width = 6, title = "Season Distribution", status = "info", solidHeader = TRUE,
              plotOutput("season_distribution_plot", height = "300px")
          ),
          box(width = 6, title = "Team Distribution", status = "info", solidHeader = TRUE,
              plotOutput("team_distribution_plot", height = "300px")
          )
        ),
        
        fluidRow(
          box(width = 12, title = "Season Summary Table", status = "success", solidHeader = TRUE,
              DT::dataTableOutput("season_summary_table")
          )
        )
      ),
      
      # Player Analysis Tab
      tabItem(tabName = "player_analysis",
        fluidRow(
          box(width = 12, title = "Player Selection", status = "primary", solidHeader = TRUE,
            fluidRow(
              column(4,
                selectInput("selected_player", "Select Player:", 
                           choices = c("Choose Player" = ""), selected = "")
              ),
              column(4,
                selectInput("player_season_filter", "Season(s):", 
                           choices = c("All Seasons" = "All"), selected = "All", multiple = TRUE)
              ),
              column(4,
                selectInput("metric_focus", "Primary Metric:", 
                           choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                           selected = "xwoba")
              )
            )
          )
        ),
        
        fluidRow(
          valueBoxOutput("player_total_pa_box"),
          valueBoxOutput("player_seasons_played_box"),
          valueBoxOutput("player_best_season_box")
        ),
        
        fluidRow(
          box(width = 6, title = "Player Performance Over Time", status = "info", solidHeader = TRUE,
              plotlyOutput("player_timeline_plot", height = "400px")
          ),
          box(width = 6, title = "Season Comparison", status = "info", solidHeader = TRUE,
              plotOutput("player_season_comparison_plot", height = "400px")
          )
        ),
        
        fluidRow(
          box(width = 12, title = "Player Season Details", status = "success", solidHeader = TRUE,
              DT::dataTableOutput("player_season_details_table")
          )
        )
      ),
      
      # Multi-Season Tracking Tab
      tabItem(tabName = "multi_season",
        fluidRow(
          box(width = 12, title = "Multi-Season Player Tracking", status = "primary", solidHeader = TRUE,
            fluidRow(
              column(3,
                numericInput("min_seasons", "Minimum Seasons Played:", 
                           value = 2, min = 1, max = 5, step = 1)
              ),
              column(3,
                selectInput("tracking_seasons", "Include Seasons:", 
                           choices = c("2021", "2022", "2023", "2024", "2025"), 
                           selected = c("2023", "2024", "2025"), multiple = TRUE)
              ),
              column(3,
                numericInput("min_pa_per_season", "Min PA per Season:", 
                           value = 20, min = 5, max = 100, step = 5)
              ),
              column(3,
                selectInput("multi_season_metric", "Tracking Metric:", 
                           choices = c("xwOBA" = "predicted_xwoba_final", "wOBA" = "actual_woba_final",
                                     "xwOBACON" = "predicted_xwobacon_final", "wOBACON" = "actual_wobacon_final"), 
                           selected = "predicted_xwoba_final")
              )
            )
          )
        ),
        
        fluidRow(
          valueBoxOutput("multi_season_players_box"),
          valueBoxOutput("avg_seasons_per_player_box"),
          valueBoxOutput("most_improved_player_box")
        ),
        
        fluidRow(
          box(width = 8, title = "Multi-Season Player Trajectories", status = "info", solidHeader = TRUE,
              plotlyOutput("multi_season_trajectories_plot", height = "500px")
          ),
          box(width = 4, title = "Season-to-Season Changes", status = "info", solidHeader = TRUE,
              plotOutput("season_change_distribution_plot", height = "500px")
          )
        ),
        
        fluidRow(
          box(width = 6, title = "Most Improved Players", status = "success", solidHeader = TRUE,
              DT::dataTableOutput("most_improved_table")
          ),
          box(width = 6, title = "Consistent Performers", status = "warning", solidHeader = TRUE,
              DT::dataTableOutput("consistent_performers_table")
          )
        )
      ),
      
      # Performance Analysis Tab
      tabItem(tabName = "performance",
        fluidRow(
          box(width = 12, title = "Performance Analysis Controls", status = "primary", solidHeader = TRUE,
            fluidRow(
              column(3,
                selectInput("perf_season", "Season:", 
                           choices = c("2021", "2022", "2023", "2024", "2025"), 
                           selected = "2025")
              ),
              column(3,
                selectInput("perf_team_filter", "Team Filter:", 
                           choices = c("All Teams" = "All"), selected = "All")
              ),
              column(3,
                numericInput("perf_min_pa", "Minimum PAs:", 
                           value = 25, min = 5, max = 100, step = 5)
              ),
              column(3,
                actionButton("refresh_performance", "ðŸ”„ Refresh Performance Data", 
                           class = "btn-primary", style = "margin-top: 25px;")
              )
            )
          )
        ),
        
        fluidRow(
          box(width = 8, title = "Expected vs Actual Performance", status = "info", solidHeader = TRUE,
              plotlyOutput("performance_scatter_plot", height = "500px")
          ),
          box(width = 4, title = "Performance Distribution", status = "info", solidHeader = TRUE,
              plotOutput("performance_distribution_plot", height = "500px")
          )
        ),
        
        fluidRow(
          box(width = 6, title = "Underperformers (Getting Unlucky)", status = "success", solidHeader = TRUE,
              DT::dataTableOutput("underperformers_table")
          ),
          box(width = 6, title = "Overperformers (Getting Lucky)", status = "danger", solidHeader = TRUE,
              DT::dataTableOutput("overperformers_table")
          )
        )
      ),
      
      # Team Browser Tab
      tabItem(tabName = "team_browser",
        fluidRow(
          box(width = 12, title = "Team Browser Controls", status = "primary", solidHeader = TRUE,
            fluidRow(
              column(3,
                selectInput("browser_season", "Season:", 
                           choices = c("2021", "2022", "2023", "2024", "2025"), 
                           selected = "2025")
              ),
              column(3,
                selectInput("browser_team", "Team:", 
                           choices = c("All Teams" = "All"), selected = "All")
              ),
              column(3,
                selectInput("browser_sort_by", "Sort By:", 
                           choices = c("xwOBA" = "avg_xwoba", "wOBA" = "avg_woba", 
                                     "PAs" = "total_pa", "Player Name" = "player"), 
                           selected = "avg_xwoba")
              ),
              column(3,
                numericInput("browser_min_pa", "Min PAs:", 
                           value = 15, min = 1, max = 100, step = 1)
              )
            )
          )
        ),
        
        fluidRow(
          box(width = 12, title = "Team Player Browser", status = "success", solidHeader = TRUE,
              DT::dataTableOutput("team_browser_table")
          )
        )
      )
    )
  )
)

# ===================================================================
# SHINY SERVER WITH MULTI-SEASON LOGIC
# ===================================================================

server <- function(input, output, session) {
  
  # Reactive values for multi-season data storage
  values <- reactiveValues(
    multi_season_data = NULL,
    necbl_data_by_season = list(),
    last_update = NULL,
    base_data = NULL
  )
  
  # Initialize data on startup
  observe({
    if (is.null(values$base_data)) {
      values$base_data <- initialize_multi_season_data()
      cat("Initialized multi-season data with", nrow(values$base_data), "records\n")
      
      # Update UI choices based on available data
      if (!is.null(values$base_data) && nrow(values$base_data) > 0) {
        available_seasons <- sort(unique(year(values$base_data$Date)))
        available_teams <- c("All Teams" = "All", sort(unique(values$base_data$BatterTeam)))
        available_players <- sort(unique(values$base_data$Batter))
        
        updateSelectInput(session, "active_seasons", choices = as.character(available_seasons), 
                         selected = as.character(tail(available_seasons, 2)))
        updateSelectInput(session, "overview_team_filter", choices = available_teams)
        updateSelectInput(session, "perf_team_filter", choices = available_teams)
        updateSelectInput(session, "browser_team", choices = available_teams)
        updateSelectInput(session, "selected_player", choices = c("Choose Player" = "", available_players))
        updateSelectInput(session, "perf_season", choices = as.character(available_seasons), 
                         selected = as.character(max(available_seasons)))
        updateSelectInput(session, "browser_season", choices = as.character(available_seasons), 
                         selected = as.character(max(available_seasons)))
        updateSelectInput(session, "tracking_seasons", choices = as.character(available_seasons), 
                         selected = as.character(tail(available_seasons, 3)))
      }
    }
  })
  
  # Reactive function to get filtered multi-season data
  get_multi_season_data <- function() {
    req(values$base_data)
    
    if (is.null(values$multi_season_data)) {
      # Initial processing - separate by individual seasons
      processed_data <- values$base_data %>%
        normalize_team_codes() %>%
        mutate(
          Season = as.character(year(Date)),
          player_season_id = paste(Batter, Season, sep = "_"),
          # Initialize with model-only data
          actual_woba_final = NA_real_,
          actual_wobacon_final = NA_real_,
          data_source = "Model Only",
          pointstreak_team_abbrev = NA_character_,
          season_verified = Season
        )
      
      values$multi_season_data <- processed_data
    }
    
    # Filter by selected seasons
    filtered_data <- values$multi_season_data %>%
      filter(Season %in% input$active_seasons)
    
    return(filtered_data)
  }
  
  # Refresh NECBL data for all selected seasons
  observeEvent(input$refresh_all_seasons, {
    req(input$active_seasons)
    
    showModal(modalDialog(
      title = "Refreshing Multi-Season NECBL Data",
      div(
        h4("Processing Selected Seasons..."),
        p("Scraping Pointstreak data for:", paste(input$active_seasons, collapse = ", ")),
        p("This may take several minutes for multiple seasons.")
      ),
      footer = NULL, easyClose = FALSE
    ))
    
    tryCatch({
      updated_data <- values$base_data
      all_necbl_data <- data.frame()
      
      # Process each selected season
      for (season in input$active_seasons) {
        cat("Processing season:", season, "\n")
        
        # Scrape NECBL data for this season
        necbl_season_data <- get_necbl_woba_by_season_enhanced(season)
        
        if (nrow(necbl_season_data) > 0) {
          # Store NECBL data by season
          values$necbl_data_by_season[[season]] <- necbl_season_data
          all_necbl_data <- rbind(all_necbl_data, necbl_season_data)
          
          # Match with model data for this specific season
          season_matched_data <- match_necbl_data_enhanced(values$base_data, necbl_season_data, season)
          
          if (nrow(season_matched_data) > 0) {
            # Update the specific season data
            season_filter <- updated_data$Season == season | year(updated_data$Date) == as.numeric(season)
            
            # Remove old season data and add new matched data
            updated_data <- updated_data[!season_filter, ]
            updated_data <- rbind(updated_data, season_matched_data)
          }
        }
        
        Sys.sleep(1) # Rate limiting
      }
      
      # Update reactive values
      values$multi_season_data <- updated_data
      values$last_update <- Sys.time()
      
      removeModal()
      
      total_pointstreak <- sum(!is.na(updated_data$actual_woba_final))
      total_records <- nrow(updated_data)
      
      showNotification(
        HTML(paste0(
          "<strong>Multi-Season Update Complete!</strong><br>",
          "ðŸŽ¯ Seasons processed: ", paste(input$active_seasons, collapse = ", "), "<br>",
          "ðŸ“Š Total records: ", total_records, "<br>",
          "ðŸ“ˆ Pointstreak enhanced: ", total_pointstreak, " (", 
          round(total_pointstreak/total_records*100, 1), "%)"
        )), 
        type = "success", duration = 10
      )
      
    }, error = function(e) {
      removeModal()
      showNotification(paste("Error in multi-season refresh:", e$message), type = "error", duration = 15)
    })
  })
  
  # Season Overview Value Boxes
  output$total_players_box <- renderValueBox({
    data <- get_multi_season_data()
    unique_players <- length(unique(data$Batter))
    
    valueBox(
      value = unique_players,
      subtitle = "Total Players",
      icon = icon("users"),
      color = "blue"
    )
  })
  
  output$total_seasons_box <- renderValueBox({
    data <- get_multi_season_data()
    unique_seasons <- length(unique(data$Season))
    
    valueBox(
      value = unique_seasons,
      subtitle = "Seasons Covered",
      icon = icon("calendar"),
      color = "green"
    )
  })
  
  output$pointstreak_coverage_box <- renderValueBox({
    data <- get_multi_season_data()
    pointstreak_pct <- round(sum(!is.na(data$actual_woba_final)) / nrow(data) * 100, 1)
    
    valueBox(
      value = paste0(pointstreak_pct, "%"),
      subtitle = "Pointstreak Coverage",
      icon = icon("chart-line"),
      color = if (pointstreak_pct > 50) "yellow" else "red"
    )
  })
  
  # Season Distribution Plot
  output$season_distribution_plot <- renderPlot({
    data <- get_multi_season_data()
    
    season_summary <- data %>%
      group_by(Season, data_source) %>%
      summarise(count = n(), .groups = "drop")
    
    ggplot(season_summary, aes(x = Season, y = count, fill = data_source)) +
      geom_col(position = "stack") +
      scale_fill_manual(values = c("Model Only" = "#e74c3c", "Pointstreak (Team+Name+FirstName)" = "#2ecc71",
                                  "Pointstreak (Team+Name+Initial)" = "#27ae60",
                                  "Pointstreak (Name+FirstName Only)" = "#f39c12")) +
      labs(title = "Records by Season and Data Source",
           x = "Season", y = "Number of Records", fill = "Data Source") +
      theme_minimal() +
      theme(legend.position = "bottom")
  })
  
  # Team Distribution Plot
  output$team_distribution_plot <- renderPlot({
    data <- get_multi_season_data()
    
    team_summary <- data %>%
      count(BatterTeam, sort = TRUE) %>%
      top_n(10, n)
    
    ggplot(team_summary, aes(x = reorder(BatterTeam, n), y = n)) +
      geom_col(fill = "#3498db") +
      coord_flip() +
      labs(title = "Top 10 Teams by Records",
           x = "Team", y = "Number of Records") +
      theme_minimal()
  })
  
  # Season Summary Table
  output$season_summary_table <- DT::renderDataTable({
    data <- get_multi_season_data()
    
    summary_table <- data %>%
      group_by(Season) %>%
      summarise(
        Total_Records = n(),
        Unique_Players = n_distinct(Batter),
        Teams = n_distinct(BatterTeam),
        Pointstreak_Records = sum(!is.na(actual_woba_final)),
        Pointstreak_Percentage = round(Pointstreak_Records / Total_Records * 100, 1),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Date_Range = paste(min(Date, na.rm = TRUE), "to", max(Date, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      arrange(desc(Season))
    
    DT::datatable(summary_table, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatPercentage("Pointstreak_Percentage", 1) %>%
      formatRound(c("Avg_xwOBA", "Avg_wOBA"), 3)
  })
  
  # Player Analysis - Update player season filter based on selected player
  observe({
    req(input$selected_player)
    if (input$selected_player != "") {
      data <- get_multi_season_data()
      player_seasons <- data %>%
        filter(Batter == input$selected_player) %>%
        distinct(Season) %>%
        arrange(Season) %>%
        pull(Season)
      
      updateSelectInput(session, "player_season_filter", 
                       choices = c("All Seasons" = "All", setNames(player_seasons, player_seasons)),
                       selected = "All")
    }
  })
  
  # Player Analysis Value Boxes
  output$player_total_pa_box <- renderValueBox({
    req(input$selected_player)
    if (input$selected_player == "") {
      return(valueBox(value = 0, subtitle = "Select Player", icon = icon("user"), color = "light-blue"))
    }
    
    data <- get_multi_season_data()
    player_data <- data %>% filter(Batter == input$selected_player)
    
    if (input$player_season_filter != "All" && !is.null(input$player_season_filter)) {
      player_data <- player_data %>% filter(Season %in% input$player_season_filter)
    }
    
    total_pa <- nrow(player_data)
    
    valueBox(
      value = total_pa,
      subtitle = "Total Plate Appearances",
      icon = icon("baseball-ball"),
      color = "blue"
    )
  })
  
  output$player_seasons_played_box <- renderValueBox({
    req(input$selected_player)
    if (input$selected_player == "") {
      return(valueBox(value = 0, subtitle = "Select Player", icon = icon("calendar"), color = "light-blue"))
    }
    
    data <- get_multi_season_data()
    seasons_played <- data %>%
      filter(Batter == input$selected_player) %>%
      distinct(Season) %>%
      nrow()
    
    valueBox(
      value = seasons_played,
      subtitle = "Seasons Played",
      icon = icon("calendar"),
      color = "green"
    )
  })
  
  output$player_best_season_box <- renderValueBox({
    req(input$selected_player)
    if (input$selected_player == "") {
      return(valueBox(value = "--", subtitle = "Select Player", icon = icon("trophy"), color = "light-blue"))
    }
    
    data <- get_multi_season_data()
    player_seasons <- data %>%
      filter(Batter == input$selected_player) %>%
      group_by(Season) %>%
      summarise(avg_xwoba = mean(predicted_xwoba_final, na.rm = TRUE), .groups = "drop") %>%
      arrange(desc(avg_xwoba))
    
    best_season <- if (nrow(player_seasons) > 0) {
      paste0(player_seasons$Season[1], " (", round(player_seasons$avg_xwoba[1], 3), ")")
    } else {
      "No Data"
    }
    
    valueBox(
      value = best_season,
      subtitle = "Best Season (xwOBA)",
      icon = icon("trophy"),
      color = "yellow"
    )
  })
  
  # Player Timeline Plot
  output$player_timeline_plot <- renderPlotly({
    req(input$selected_player)
    if (input$selected_player == "") {
      return(plot_ly() %>% add_text(text = "Select a player", x = 0.5, y = 0.5))
    }
    
    data <- get_multi_season_data()
    player_data <- data %>% filter(Batter == input$selected_player)
    
    if (input$player_season_filter != "All" && !is.null(input$player_season_filter)) {
      player_data <- player_data %>% filter(Season %in% input$player_season_filter)
    }
    
    if (nrow(player_data) == 0) {
      return(plot_ly() %>% add_text(text = "No data for selected filters", x = 0.5, y = 0.5))
    }
    
    # Create cumulative performance by date
    timeline_data <- player_data %>%
      arrange(Date) %>%
      mutate(
        pa_number = row_number(),
        cumulative_xwoba = cummean(predicted_xwoba_final),
        cumulative_woba = cummean(actual_woba_final)
      )
    
    p <- plot_ly(timeline_data, x = ~Date) %>%
      add_lines(y = ~cumulative_xwoba, name = "xwOBA", line = list(color = "#3498db")) %>%
      add_lines(y = ~cumulative_woba, name = "wOBA", line = list(color = "#e74c3c")) %>%
      layout(
        title = paste("Performance Timeline:", input$selected_player),
        xaxis = list(title = "Date"),
        yaxis = list(title = "Cumulative Performance"),
        hovermode = "x unified"
      )
    
    return(p)
  })
  
  # Player Season Comparison Plot
  output$player_season_comparison_plot <- renderPlot({
    req(input$selected_player)
    if (input$selected_player == "") return(ggplot() + theme_void())
    
    data <- get_multi_season_data()
    player_season_stats <- data %>%
      filter(Batter == input$selected_player) %>%
      group_by(Season) %>%
      summarise(
        PA = n(),
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        Has_Pointstreak = !all(is.na(actual_woba_final)),
        .groups = "drop"
      ) %>%
      pivot_longer(cols = c(xwOBA, wOBA), names_to = "Metric", values_to = "Value") %>%
      filter(!is.na(Value))
    
    if (nrow(player_season_stats) == 0) return(ggplot() + theme_void())
    
    ggplot(player_season_stats, aes(x = Season, y = Value, fill = Metric)) +
      geom_col(position = "dodge", alpha = 0.8) +
      scale_fill_manual(values = c("xwOBA" = "#3498db", "wOBA" = "#e74c3c")) +
      labs(title = paste("Season Comparison:", input$selected_player),
           x = "Season", y = "Performance Value") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  })
  
  # Player Season Details Table
  output$player_season_details_table <- DT::renderDataTable({
    req(input$selected_player)
    if (input$selected_player == "") return(data.frame())
    
    data <- get_multi_season_data()
    player_details <- data %>%
      filter(Batter == input$selected_player) %>%
      group_by(Season, BatterTeam) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Data_Source = first(data_source),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Date_Range = paste(min(Date), "to", max(Date)),
        .groups = "drop"
      ) %>%
      arrange(desc(Season))
    
    DT::datatable(player_details, options = list(pageLength = 10, scrollX = TRUE)) %>%
      formatRound(c("xwOBA", "wOBA", "xwOBACON", "wOBACON"), 3)
  })
  
  # Multi-Season Tracking Value Boxes
  output$multi_season_players_box <- renderValueBox({
    data <- get_multi_season_data()
    
    multi_season_players <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter) %>%
      summarise(
        seasons_played = n_distinct(Season),
        total_pa = n(),
        .groups = "drop"
      ) %>%
      filter(seasons_played >= input$min_seasons, total_pa >= input$min_pa_per_season * seasons_played) %>%
      nrow()
    
    valueBox(
      value = multi_season_players,
      subtitle = "Multi-Season Players",
      icon = icon("users"),
      color = "purple"
    )
  })
  
  output$avg_seasons_per_player_box <- renderValueBox({
    data <- get_multi_season_data()
    
    avg_seasons <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter) %>%
      summarise(seasons = n_distinct(Season), .groups = "drop") %>%
      summarise(avg_seasons = round(mean(seasons), 1)) %>%
      pull(avg_seasons)
    
    valueBox(
      value = avg_seasons,
      subtitle = "Avg Seasons per Player",
      icon = icon("chart-line"),
      color = "teal"
    )
  })
  
  output$most_improved_player_box <- renderValueBox({
    data <- get_multi_season_data()
    
    improvement_data <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter, Season) %>%
      summarise(
        pa = n(),
        metric_value = mean(!!sym(input$multi_season_metric), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      filter(pa >= input$min_pa_per_season) %>%
      group_by(Batter) %>%
      filter(n_distinct(Season) >= input$min_seasons) %>%
      arrange(Season) %>%
      summarise(
        improvement = last(metric_value) - first(metric_value),
        .groups = "drop"
      ) %>%
      arrange(desc(improvement))
    
    most_improved <- if (nrow(improvement_data) > 0) {
      paste0(improvement_data$Batter[1], " (+", round(improvement_data$improvement[1], 3), ")")
    } else {
      "None Found"
    }
    
    valueBox(
      value = most_improved,
      subtitle = "Most Improved Player",
      icon = icon("trending-up"),
      color = "green"
    )
  })
  
  # Multi-Season Trajectories Plot
  output$multi_season_trajectories_plot <- renderPlotly({
    data <- get_multi_season_data()
    
    trajectory_data <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter, Season) %>%
      summarise(
        pa = n(),
        metric_value = mean(!!sym(input$multi_season_metric), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      filter(pa >= input$min_pa_per_season) %>%
      group_by(Batter) %>%
      filter(n_distinct(Season) >= input$min_seasons) %>%
      ungroup()
    
    if (nrow(trajectory_data) == 0) {
      return(plot_ly() %>% add_text(text = "No players meet criteria", x = 0.5, y = 0.5))
    }
    
    p <- plot_ly(trajectory_data, x = ~Season, y = ~metric_value, color = ~Batter, type = "scatter", mode = "lines+markers") %>%
      layout(
        title = paste("Multi-Season Player Trajectories:", gsub("_", " ", tools::toTitleCase(gsub("_final", "", input$multi_season_metric)))),
        xaxis = list(title = "Season"),
        yaxis = list(title = gsub("_", " ", tools::toTitleCase(gsub("_final", "", input$multi_season_metric)))),
        showlegend = TRUE
      )
    
    return(p)
  })
  
  # Performance Analysis
  observeEvent(input$refresh_performance, {
    req(input$perf_season)
    
    showModal(modalDialog(
      title = paste("Refreshing Performance Data for", input$perf_season),
      "Updating Pointstreak data for performance analysis...",
      footer = NULL, easyClose = FALSE
    ))
    
    tryCatch({
      necbl_data <- get_necbl_woba_by_season_enhanced(input$perf_season)
      
      if (nrow(necbl_data) > 0) {
        matched_data <- match_necbl_data_enhanced(values$base_data, necbl_data, input$perf_season)
        
        # Update the season data in multi_season_data
        if (nrow(matched_data) > 0) {
          updated_data <- values$multi_season_data
          season_filter <- updated_data$Season == input$perf_season
          updated_data <- updated_data[!season_filter, ]
          updated_data <- rbind(updated_data, matched_data)
          values$multi_season_data <- updated_data
        }
      }
      
      removeModal()
      showNotification(paste("Performance data updated for", input$perf_season), type = "success")
      
    }, error = function(e) {
      removeModal()
      showNotification(paste("Error updating performance data:", e$message), type = "error")
    })
  })
  
  # Performance Scatter Plot
  output$performance_scatter_plot <- renderPlotly({
    data <- get_multi_season_data() %>%
      filter(Season == input$perf_season)
    
    if (input$perf_team_filter != "All") {
      data <- data %>% filter(BatterTeam == input$perf_team_filter)
    }
    
    player_performance <- data %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        Team = first(BatterTeam),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      filter(PA >= input$perf_min_pa, !is.na(wOBA))
    
    if (nrow(player_performance) == 0) {
      return(plot_ly() %>% add_text(text = "No data with Pointstreak overlay found", x = 0.5, y = 0.5))
    }
    
    p <- plot_ly(player_performance, x = ~wOBA, y = ~xwOBA, 
                 size = ~PA, color = ~Data_Source, text = ~Batter,
                 hovertemplate = paste("<b>%{text}</b><br>",
                                     "wOBA: %{x:.3f}<br>",
                                     "xwOBA: %{y:.3f}<br>",
                                     "PA: %{marker.size}<br>",
                                     "<extra></extra>")) %>%
      add_markers() %>%
      add_lines(x = c(0, 1), y = c(0, 1), mode = "lines", 
               line = list(dash = "dash", color = "red"), 
               name = "Perfect Prediction", showlegend = FALSE) %>%
      layout(
        title = paste("Expected vs Actual Performance -", input$perf_season),
        xaxis = list(title = "wOBA (Pointstreak)"),
        yaxis = list(title = "xwOBA (Model)")
      )
    
    return(p)
  })
  
  # Underperformers and Overperformers Tables
  output$underperformers_table <- DT::renderDataTable({
    data <- get_multi_season_data() %>%
      filter(Season == input$perf_season)
    
    if (input$perf_team_filter != "All") {
      data <- data %>% filter(BatterTeam == input$perf_team_filter)
    }
    
    underperformers <- data %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      filter(PA >= input$perf_min_pa, !is.na(wOBA)) %>%
      mutate(Difference = round(xwOBA - wOBA, 3)) %>%
      filter(Difference > 0.025) %>%
      arrange(desc(Difference)) %>%
      head(20)
    
    DT::datatable(underperformers, options = list(pageLength = 10, scrollX = TRUE)) %>%
      formatRound(c("xwOBA", "wOBA", "Difference"), 3) %>%
      formatStyle("Difference", backgroundColor = "#d4edda")
  })
  
  output$overperformers_table <- DT::renderDataTable({
    data <- get_multi_season_data() %>%
      filter(Season == input$perf_season)
    
    if (input$perf_team_filter != "All") {
      data <- data %>% filter(BatterTeam == input$perf_team_filter)
    }
    
    overperformers <- data %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      filter(PA >= input$perf_min_pa, !is.na(wOBA)) %>%
      mutate(Difference = round(wOBA - xwOBA, 3)) %>%
      filter(Difference > 0.025) %>%
      arrange(desc(Difference)) %>%
      head(20)
    
    DT::datatable(overperformers, options = list(pageLength = 10, scrollX = TRUE)) %>%
      formatRound(c("xwOBA", "wOBA", "Difference"), 3) %>%
      formatStyle("Difference", backgroundColor = "#f8d7da")
  })
  
  # Team Browser Table
  output$team_browser_table <- DT::renderDataTable({
    data <- get_multi_season_data() %>%
      filter(Season == input$browser_season)
    
    if (input$browser_team != "All") {
      data <- data %>% filter(BatterTeam == input$browser_team)
    }
    
    browser_data <- data %>%
      group_by(Batter) %>%
      summarise(
        total_pa = n(),
        avg_xwoba = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        avg_woba = round(mean(actual_woba_final, na.rm = TRUE), 3),
        avg_xwobacon = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        avg_wobacon = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        team = first(BatterTeam),
        data_source = first(data_source),
        pointstreak_team = first(pointstreak_team_abbrev),
        .groups = "drop"
      ) %>%
      filter(total_pa >= input$browser_min_pa) %>%
      arrange(desc(!!sym(input$browser_sort_by)))
    
    DT::datatable(browser_data, options = list(pageLength = 25, scrollX = TRUE)) %>%
      formatRound(c("avg_xwoba", "avg_woba", "avg_xwobacon", "avg_wobacon"), 3)
  })
  
  # Additional Multi-Season Tables
  output$most_improved_table <- DT::renderDataTable({
    data <- get_multi_season_data()
    
    improvement_data <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter, Season) %>%
      summarise(
        pa = n(),
        metric_value = mean(!!sym(input$multi_season_metric), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      filter(pa >= input$min_pa_per_season) %>%
      group_by(Batter) %>%
      filter(n_distinct(Season) >= input$min_seasons) %>%
      arrange(Season) %>%
      summarise(
        seasons_played = n(),
        first_season_value = round(first(metric_value), 3),
        last_season_value = round(last(metric_value), 3),
        improvement = round(last(metric_value) - first(metric_value), 3),
        .groups = "drop"
      ) %>%
      filter(improvement > 0) %>%
      arrange(desc(improvement)) %>%
      head(20)
    
    DT::datatable(improvement_data, options = list(pageLength = 10, scrollX = TRUE)) %>%
      formatRound(c("first_season_value", "last_season_value", "improvement"), 3) %>%
      formatStyle("improvement", backgroundColor = "#d4edda")
  })
  
  output$consistent_performers_table <- DT::renderDataTable({
    data <- get_multi_season_data()
    
    consistency_data <- data %>%
      filter(Season %in% input$tracking_seasons) %>%
      group_by(Batter, Season) %>%
      summarise(
        pa = n(),
        metric_value = mean(!!sym(input$multi_season_metric), na.rm = TRUE),
        .groups = "drop"
      ) %>%
      filter(pa >= input$min_pa_per_season) %>%
      group_by(Batter) %>%
      filter(n_distinct(Season) >= input$min_seasons) %>%
      summarise(
        seasons_played = n(),
        avg_performance = round(mean(metric_value), 3),
        std_dev = round(sd(metric_value), 3),
        consistency_score = round(avg_performance / (std_dev + 0.001), 2),
        .groups = "drop"
      ) %>%
      arrange(desc(consistency_score)) %>%
      head(20)
    
    DT::datatable(consistency_data, options = list(pageLength = 10, scrollX = TRUE)) %>%
      formatRound(c("avg_performance", "std_dev"), 3) %>%
      formatStyle("consistency_score", backgroundColor = "#fff3cd")
  })
}

# ===================================================================
# RUN THE APPLICATION
# ===================================================================

shinyApp(ui = ui, server = server)

