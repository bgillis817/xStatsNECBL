# Enhanced xwOBA Dashboard - Complete R Shiny Integration
# SECTION 1: REQUIRED LIBRARIES
# ===================================================================

library(shiny)
library(shinydashboard)
library(DT)
library(ggplot2)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)
library(plotly)
# ===================================================================
# SECTION 2: ENHANCED CORE FUNCTIONS - FIXED FOR DATE COLUMN
# ===================================================================

# Enhanced xwOBA calculation with proper PA integration - SEASON-AWARE VERSION
calculate_expected_xwoba_and_full <- function(raw_data, xgb_expected = NULL) {
  cat("=== CALCULATING EXPECTED xwOBA WITH PROPER PA INTEGRATION (SEASON-AWARE) ===\n")
  
  # CRITICAL FIX: Add season extraction BEFORE any processing
  if ("Date" %in% names(raw_data)) {
    raw_data <- raw_data %>%
      mutate(
        Expected_Season = as.character(year(as.Date(Date)))
      )
    cat("Season extraction complete. Seasons found:", paste(unique(raw_data$Expected_Season), collapse = ", "), "\n")
  } else {
    # If no Date column, assume current year or add a default
    raw_data <- raw_data %>%
      mutate(Expected_Season = "2025")
    cat("No Date column found - using default season 2025\n")
  }
  
  # Step 1: Filter to batted balls with complete data
  batted_balls <- raw_data %>%
    filter(
      PlayResult %in% c("Single", "Double", "Triple", "HomeRun", "Out",
                        "FieldersChoice", "Error", "Sacrifice") &
      !is.na(ExitSpeed) & ExitSpeed > 0 &
      !is.na(Angle) & !is.na(Batter)
    )
  
  cat("Batted balls with tracking data:", nrow(batted_balls), "\n")
  
  # Outcome classification for batted balls
  batted_balls$outcome <- case_when(
    batted_balls$PlayResult %in% c("Single") ~ "single",
    batted_balls$PlayResult %in% c("Double") ~ "double", 
    batted_balls$PlayResult %in% c("Triple") ~ "triple",
    batted_balls$PlayResult %in% c("HomeRun") ~ "home_run",
    batted_balls$PlayResult %in% c("Out", "FieldersChoice", "Error", "Sacrifice") ~ "out",
    TRUE ~ "other"
  )
  
  batted_balls <- batted_balls[batted_balls$outcome != "other", ]
  
  # wOBA weights
  woba_weights_vector <- c(0.000, 0.888, 1.271, 1.616, 2.101)
  
  # Get expected predictions for batted balls
  if (!is.null(xgb_expected) && exists("dtest")) {
    test_probs <- predict(xgb_expected, dtest, reshape = TRUE)
    colnames(test_probs) <- c("P_out", "P_single", "P_double", "P_triple", "P_home_run")
    predicted_xwobacon <- as.vector(test_probs %*% woba_weights_vector)
    batted_balls$predicted_xwobacon <- predicted_xwobacon
  } else {
    # Fallback calculation if expected objects not available
    batted_balls$predicted_xwobacon <- pmin(2.5, pmax(0, 
      0.1 + (batted_balls$ExitSpeed - 60) * 0.01 + 
      pmax(0, 30 - abs(batted_balls$Angle - 20)) * 0.005
    ))
  }
  
  cat("xwOBACON calculated for", nrow(batted_balls), "batted balls\n")
  
  # Step 2: Get ALL plate appearances for each player BY SEASON
  all_pa <- raw_data %>% 
    filter(!is.na(Batter)) %>%
    mutate(
      pa_outcome = case_when(
        PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
        PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
        PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
        KorBB == "Walk" ~ "walk",
        KorBB == "IntentionalWalk" ~ "intentional_walk",
        PitchCall == "HitByPitch" ~ "hit_by_pitch",
        KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
        TRUE ~ "other"
      )
    ) %>%
    filter(pa_outcome != "other")
  
  cat("Total plate appearances:", nrow(all_pa), "\n")
  
  # Step 3: Calculate player-level xwOBA BY SEASON (critical fix)
  player_xwoba_full <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon, Expected_Season),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    # CRITICAL FIX: Use Expected_Season.x (from all_pa) for grouping
    mutate(
      Expected_Season = coalesce(Expected_Season.x, Expected_Season.y)
    ) %>%
    group_by(Batter, Expected_Season) %>%  # GROUP BY SEASON TOO!
    summarise(
      hits = sum(pa_outcome == "hit"),
      outs = sum(pa_outcome == "out"),
      strikeouts = sum(pa_outcome == "strikeout"),
      BB = sum(pa_outcome == "walk"),
      IBB = sum(pa_outcome == "intentional_walk"),
      SF = sum(pa_outcome == "sacrifice_fly"),
      HBP = sum(pa_outcome == "hit_by_pitch"),
      
      batted_balls_count = hits + outs,
      AB = hits + outs + strikeouts,
      total_pa = AB + BB - IBB + SF + HBP,
      
      mean_xwobacon = mean(predicted_xwobacon, na.rm = TRUE),
      
      wBB_HBP = 0.690,
      xwoba_numerator = (mean_xwobacon * batted_balls_count) + (wBB_HBP * (BB - IBB + HBP)),
      predicted_xwoba_full = ifelse(total_pa > 0, xwoba_numerator / total_pa, NA_real_),
      
      .groups = "drop"
    )
  
  cat("Player-level xwOBA calculated for", nrow(player_xwoba_full), "player-season combinations\n")
  
  # Step 4: Merge back to individual PA level WITH SEASON AWARENESS
  enhanced_data <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    left_join(
      player_xwoba_full %>% select(Batter, Expected_Season, predicted_xwoba_full, mean_xwobacon),
      by = c("Batter", "Expected_Season")  # JOIN ON BOTH PLAYER AND SEASON
    ) %>%
    mutate(
      predicted_xwoba_final = predicted_xwoba_full,
      predicted_xwobacon_final = ifelse(!is.na(predicted_xwobacon), predicted_xwobacon, mean_xwobacon)
    )
  
  cat("=== CALCULATION SUMMARY ===\n")
  cat("Total enhanced records:", nrow(enhanced_data), "\n")
  cat("Records with xwOBA:", sum(!is.na(enhanced_data$predicted_xwoba_final)), "\n")
  cat("Records with xwOBACON:", sum(!is.na(enhanced_data$predicted_xwobacon_final)), "\n")
  
  # Show season breakdown
  if ("Expected_Season" %in% names(enhanced_data)) {
    season_summary <- enhanced_data %>%
      group_by(Expected_Season) %>%
      summarise(
        Players = n_distinct(Batter),
        Records = n(),
        .groups = "drop"
      )
    cat("Season breakdown:\n")
    print(season_summary)
  }
  
  return(enhanced_data)
}

# ===================================================================
# SECTION 3: NECBL TEAM MAPPING & SEASON-SPECIFIC SCRAPING
# ===================================================================

# Complete team mapping with roster URLs and season IDs - FIXED VERSION
necbl_team_mapping_enhanced <- list(
  "BRI_B" = list(
    name = "Bristol Blues", 
    abbrev = "BRI",
    team_id = "89490"
  ),
  "DAN_WES" = list(
    name = "Danbury Westerners", 
    abbrev = "DAN",
    team_id = "6402"
  ),
  "KEE_SWA" = list(
    name = "Keene SwampBats", 
    abbrev = "KSB",
    team_id = "6401"
  ),
  "MAR_VIN" = list(
    name = "Martha's Vineyard Sharks", 
    abbrev = "MV",
    team_id = "142675"
  ),
  "MYS_SCH" = list(
    name = "Mystic Schooners", 
    abbrev = "MSC",
    team_id = "11912"
  ),
  "NEW_GUL" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458"
  ),
  "NOR_ADA" = list(
    name = "North Adams Steeplecats", 
    abbrev = "NSC",
    team_id = "6404"
  ),
  # FIXED: Added NSH_N mapping
  "NSH_N" = list(
    name = "North Shore Navigators", 
    abbrev = "NSN",
    team_id = "154432"
  ),
  # Ocean State Waves - handles both OCE_STA and OCE_STA6
  "OCE_STA" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489"
  ),
  "OCE_STA6" = list(
    name = "Ocean State Waves", 
    abbrev = "OSW",
    team_id = "51489"
  ),
  "SAN_MAI" = list(
    name = "Sanford Mainers", 
    abbrev = "SM",
    team_id = "6459"
  ),
  "UPP_VAL" = list(
    name = "Upper Valley Nighthawks", 
    abbrev = "UVNH",
    team_id = "104040"
  ),
  "VAL_BLU" = list(
    name = "Valley Blue Sox", 
    abbrev = "VAL",
    team_id = "6403"
  ),
  "VER_MOU" = list(
    name = "Vermont Mountaineers", 
    abbrev = "VM",
    team_id = "6405"
  ),
  # Additional mappings for unmapped teams
  "WIN_MUS" = list(
    name = "Winnipesaukee Muskrats", 
    abbrev = "WM",
    team_id = "6406"
  ),
  "NWL_WB" = list(
    name = "Newport Gulls", 
    abbrev = "NG",
    team_id = "6458"
  ),
  "NEC_EAS" = list(
    name = "NECBL East", 
    abbrev = "NE",
    team_id = "unknown"
  ),
  "NEC_WES" = list(
    name = "NECBL West", 
    abbrev = "NW", 
    team_id = "unknown"
  )
)

# NECBL URLs by season with proper season IDs
necbl_urls_by_season <- list(
  "2025" = list(seasonid = "34029"),
  "2024" = list(seasonid = "33860"),
  "2023" = list(seasonid = "33589"),
  "2022" = list(seasonid = "33205"),
  "2021" = list(seasonid = "32746")
)

# Helper function to create composite keys
create_composite_key <- function(last_name, first_initial, team_abbrev, season) {
  paste(
    toupper(trimws(last_name)),
    toupper(trimws(first_initial)),
    toupper(trimws(team_abbrev)),
    season,
    sep = "_"
  )
}

# Helper function to extract team info from model team codes
get_team_info_from_model_code <- function(model_team_code) {
  team_info <- necbl_team_mapping_enhanced[[model_team_code]]
  if (!is.null(team_info)) {
    return(list(
      name = team_info$name,
      abbrev = team_info$abbrev,
      team_id = team_info$team_id
    ))
  } else {
    return(list(name = NA_character_, abbrev = "UNK", team_id = NA_character_))
  }
}
# ===================================================================
# SECTION 4: ENHANCED SCRAPER WITH COMPOSITE KEY GENERATION & FIXES
# ===================================================================

# Enhanced scraper with composite key generation for exact matching
get_necbl_woba_by_season <- function(season = "2025") {
  cat("=== SCRAPING NECBL", season, "SEASON WITH COMPOSITE KEYS ===\n")
  
  season_info <- necbl_urls_by_season[[season]]
  if (is.null(season_info)) {
    cat("ERROR: Season", season, "not available\n")
    return(data.frame())
  }
  
  seasonid <- season_info$seasonid
  all_woba <- data.frame()
  
  cat("Using UNIVERSAL URL format with leagueid=204 for all teams\n")
  
  for (team_code in names(necbl_team_mapping_enhanced)) {
    team_info <- necbl_team_mapping_enhanced[[team_code]]
    team_name <- team_info$name
    team_abbrev <- team_info$abbrev
    team_id <- team_info$team_id
    
    # Skip duplicate Ocean State entries (we only need to scrape once)
    if (team_code == "OCE_STA6") next
    # Skip other duplicate entries
    if (team_code %in% c("NWL_WB", "WIN_MUS", "NEC_EAS", "NEC_WES")) next
    
    # UNIVERSAL FORMAT: ALL seasons and ALL teams use leagueid=204
    url <- paste0("http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=", 
                 seasonid, "&teamid=", team_id)
    
    cat("Scraping", team_name, "(", team_abbrev, ") for", season, "...\n")
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"), timeout(15))
      if (status_code(response) != 200) {
        cat("HTTP", status_code(response), "for", team_name, "\n")
        next
      }
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            # Find required columns
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) next
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                # Skip invalid rows
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                # Extract stats
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                # Extract other stats with defaults
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                # Calculate singles and metrics
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  # wOBA: weighted value / PAs
                  actual_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                  triples_val * 1.616 + hr_val * 2.101 + 
                                  (bb_val + hbp_val) * 0.690) / PA
                  
                  # wOBACON: weighted value / Batted_Balls
                  actual_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                     triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  # Enhanced player name parsing for composite key generation
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  
                  # CRITICAL FIX: Remove unwanted "X" characters from pointstreak names
                  # Remove leading "X " or "x " that appears in some NECBL data
                  clean_name <- str_trim(gsub("^[Xx]\\s+", "", clean_name))
                  
                  # DEBUG: Log the original and cleaned name for Kea
                  if (grepl("Kea", clean_name, ignore.case = TRUE)) {
                    cat("DEBUG - Original player_raw:", player_raw, "\n")
                    cat("DEBUG - Cleaned name:", clean_name, "\n")
                  }
                  
                  # SPECIAL CASE: Handle any Kea name variations
                  if (grepl("Kea", clean_name, ignore.case = TRUE)) {
                    # If it contains "Jaydon Aukai Kea" or similar, normalize to "Kea, J"
                    if (grepl("Jaydon.*Kea", clean_name, ignore.case = TRUE) || 
                        grepl("Aukai.*Kea", clean_name, ignore.case = TRUE)) {
                      clean_name <- "Kea, J"
                      cat("DEBUG - Normalized Kea name to:", clean_name, "\n")
                    }
                    # If it's already "Kea, J" format, keep it
                    else if (grepl("Kea,\\s*J", clean_name, ignore.case = TRUE)) {
                      clean_name <- "Kea, J"
                      cat("DEBUG - Kept Kea name as:", clean_name, "\n")
                    }
                  }
                  
                  # Parse name more carefully
                  if (grepl(",", clean_name)) {
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    
                    # Extract first name and first initial
                    first_words <- str_split(first_part, "\\s+")[[1]]
                    first_name <- first_words[1]
                    first_initial <- substr(first_name, 1, 1)
                    
                  } else {
                    words <- str_split(clean_name, "\\s+")[[1]]
                    if (length(words) >= 2) {
                      first_name <- words[1]
                      first_initial <- substr(first_name, 1, 1)
                      last_name <- paste(words[2:length(words)], collapse = " ")
                    } else {
                      last_name <- clean_name
                      first_name <- substr(clean_name, 1, 1)
                      first_initial <- substr(clean_name, 1, 1)
                    }
                  }
                  
                  # COMPOSITE KEY GENERATION - This is the key improvement!
                  composite_key <- create_composite_key(last_name, first_initial, team_abbrev, season)
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Name = str_trim(first_name),
                    First_Initial = toupper(str_trim(first_initial)),
                    Player_Team_Season_Key = composite_key,  # NEW: Composite key for exact matching
                    wOBA = round(actual_wOBA, 3),
                    wOBACON = round(actual_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    Singles = singles_val,
                    Doubles = doubles_val,
                    Triples = triples_val,
                    HRs = hr_val,
                    BBs = bb_val,
                    HBPs = hbp_val,
                    SOs = so_val,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                cat("Error processing row", row_idx, "for", team_name, ":", e$message, "\n")
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
            }
            break
          }
        }
      }
    }, error = function(e) {
      cat("ERROR scraping", team_name, ":", e$message, "\n")
    })
    
    Sys.sleep(1.5)  # Be respectful to the server
  }
  
  # Verify composite key uniqueness and handle duplicates
  if (nrow(all_woba) > 0) {
    duplicate_keys <- all_woba %>%
      group_by(Player_Team_Season_Key) %>%
      filter(n() > 1) %>%
      ungroup()
    
    if (nrow(duplicate_keys) > 0) {
      cat("WARNING: Found", nrow(duplicate_keys), "duplicate composite keys - removing duplicates:\n")
      print(duplicate_keys %>% select(Player, Player_Team_Season_Key, Team))
      
      # Keep only the first occurrence of each duplicate key
      all_woba <- all_woba %>%
        group_by(Player_Team_Season_Key) %>%
        slice_head(n = 1) %>%
        ungroup()
      
      cat("‚úÖ Duplicates removed -", nrow(all_woba), "unique records remaining\n")
    } else {
      cat("‚úÖ All composite keys are unique!\n")
    }
  }
  
  cat("Total players with calculated wOBA/wOBACON for", season, ":", nrow(all_woba), "\n")
  cat("Sample composite keys:\n")
  if (nrow(all_woba) > 0) {
    print(head(all_woba %>% select(Player, Player_Team_Season_Key), 3))
  }
  
  return(all_woba)
}
# ===================================================================
# SECTION 5: SIMPLIFIED MATCHING FUNCTION WITH COMPOSITE KEYS - SEASON-AWARE VERSION
# ===================================================================

# MASSIVELY SIMPLIFIED: No more 4-tier matching - just exact composite key joins! - NOW SEASON-AWARE
match_necbl_data_composite <- function(expected_data, necbl_data, selected_season = "2025") {
  cat("=== MATCHING WITH COMPOSITE KEYS (EXACT JOINS ONLY) - SEASON-AWARE ===\n")
  cat("Expected records (PRIMARY):", nrow(expected_data), "\n")
  cat("NECBL records (OVERLAY):", nrow(necbl_data), "\n")
  cat("Selected season:", selected_season, "\n")
  
  # CRITICAL FIX: Filter expected data to selected season FIRST - HANDLE BOTH DATE AND EXPECTED_SEASON
  if ("Expected_Season" %in% names(expected_data)) {
    expected_season_data <- expected_data %>%
      filter(Expected_Season == selected_season)
    cat("Expected records filtered to", selected_season, ":", nrow(expected_season_data), "\n")
  } else if ("Date" %in% names(expected_data)) {
    # Extract season from Date if Expected_Season doesn't exist
    expected_season_data <- expected_data %>%
      mutate(Expected_Season = as.character(year(as.Date(Date)))) %>%
      filter(Expected_Season == selected_season)
    cat("Expected records filtered to", selected_season, "via Date:", nrow(expected_season_data), "\n")
  } else {
    # If no season info, return all expected data but warn
    cat("WARNING: No season information in expected data - using all records\n")
    expected_season_data <- expected_data %>%
      mutate(Expected_Season = selected_season)
  }
  
  # Filter NECBL data to selected season ONLY
  necbl_season_data <- necbl_data %>%
    filter(Season == selected_season)
  
  cat("NECBL records for", selected_season, ":", nrow(necbl_season_data), "\n")
  
  # Generate composite keys for expected data - USING THE SELECTED SEASON
  expected_with_keys <- expected_season_data %>%
    mutate(
      # Parse expected data names: "Last Name, First Name" format
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Name_Full = trimws(sub(".*,\\s*", "", Batter)),
      First_Initial = toupper(substr(First_Name_Full, 1, 1)),
      
      # SPECIAL CASE: Handle Jaydon Kea - normalize to use "J" as first initial
      First_Initial = ifelse(
        toupper(trimws(sub(",.*", "", Batter))) == "KEA" & 
        grepl("^Jaydon", First_Name_Full, ignore.case = TRUE),
        "J", First_Initial
      ),
      
      # Get team abbreviation from BatterTeam using enhanced mapping
      Team_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping_enhanced[[x]]
        if (!is.null(team_info)) team_info$abbrev else "UNK"
      }),
      
      # Generate composite key for expected data - CRITICAL: USE SELECTED SEASON
      Expected_Composite_Key = create_composite_key(Last_Name, First_Initial, Team_Abbrev, selected_season)
    )
  
  cat("Generated", nrow(expected_with_keys), "composite keys for expected data in", selected_season, "\n")
  
  # Show sample expected keys for verification
  cat("Sample expected composite keys for", selected_season, ":\n")
  sample_keys <- expected_with_keys %>% 
    distinct(Batter, Expected_Composite_Key, BatterTeam) %>% 
    head(3)
  print(sample_keys)
  
  # If no NECBL data for selected season, return expected-only
  if (nrow(necbl_season_data) == 0) {
    cat("No NECBL data for", selected_season, "- returning expected data only\n")
    return(expected_with_keys %>%
           select(-Last_Name, -First_Initial, -First_Name_Full, -Team_Abbrev, -Expected_Composite_Key) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Expected Only"
           ))
  }
  
  # If no expected data for selected season, return empty
  if (nrow(expected_with_keys) == 0) {
    cat("No expected data for", selected_season, "- returning empty dataset\n")
    return(data.frame())
  }
  
  # SIMPLE EXACT JOIN ON COMPOSITE KEYS - No complex tiers!
  joined_data <- expected_with_keys %>%
    left_join(
      necbl_season_data %>% 
      select(Player_Team_Season_Key, Player, wOBA, wOBACON, Team, Team_Abbrev, PA, Batted_Balls), 
      by = c("Expected_Composite_Key" = "Player_Team_Season_Key")
    )
  
  # Check what columns we actually have after the join
  cat("Columns after join:", paste(names(joined_data), collapse = ", "), "\n")
  
  matched_data <- joined_data %>%
    mutate(
      # Overlay actual data where available
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      
      # Data source
      data_source = case_when(
        !is.na(wOBA) ~ paste0("Expected + Actual (", selected_season, ")"),
        TRUE ~ "Expected Only"
      )
    ) %>%
    # Clean up temporary columns - ONLY REMOVE COLUMNS THAT WE CREATED
    select(-Last_Name, -First_Initial, -First_Name_Full, -Expected_Composite_Key) %>%
    # Remove the joined columns that we've copied to new names
    select(-any_of(c("Player", "wOBA", "wOBACON", "Team", "Team_Abbrev", "PA", "Batted_Balls")))
  
  # MATCHING SUMMARY
  total_records <- nrow(matched_data)
  exact_matches <- sum(!is.na(matched_data$actual_woba_final))
  
  cat("\n=== SEASON-AWARE MATCHING SUMMARY ===\n")
  cat("üéØ SEASON FOCUS:", selected_season, "\n")
  cat("‚úÖ EXPECTED RECORDS FOR", selected_season, ":", total_records, "(100%)\n")
  cat("üéØ EXACT MATCHES FOUND:", exact_matches, "\n")
  
  return(matched_data)
}

# Helper function to analyze match quality - UPDATED FOR SEASON AWARENESS
analyze_match_quality <- function(matched_data) {
  cat("=== DETAILED MATCH QUALITY ANALYSIS (SEASON-AWARE) ===\n")
  
  # Overall statistics
  total <- nrow(matched_data)
  matched <- sum(!is.na(matched_data$actual_woba_final))
  
  cat("Total Expected Players:", total, "\n")
  cat("Successfully Matched:", matched, "\n")
  
  # Show season info if available
  if ("Expected_Season" %in% names(matched_data)) {
    season_info <- matched_data %>%
      count(Expected_Season, name = "Records") %>%
      arrange(Expected_Season)
    cat("Expected data by season:\n")
    print(season_info)
  }
  
  cat("\n")
  
  # By team analysis
  team_analysis <- matched_data %>%
    group_by(BatterTeam) %>%
    summarise(
      Total_Players = n(),
      Matched_Players = sum(!is.na(actual_woba_final)),
      .groups = "drop"
    ) %>%
    arrange(desc(Matched_Players))
  
  cat("MATCHED PLAYERS BY TEAM:\n")
  print(team_analysis)
  
  return(team_analysis)
}
# ===================================================================
# SECTION 6: LOAD ALL SEASONS WITH COMPOSITE KEY TRACKING
# ===================================================================

# Load all seasons with progress tracking and composite key verification
get_all_necbl_seasons_composite <- function(progress_callback = NULL) {
  cat("=== LOADING ALL NECBL SEASONS (2021-2025) WITH COMPOSITE KEYS ===\n")
  
  all_seasons_data <- data.frame()
  seasons <- c("2021", "2022", "2023", "2024", "2025")
  total_composite_keys <- 0
  
  for (i in seq_along(seasons)) {
    if (!is.null(progress_callback)) {
      progress_callback(detail = paste("Loading", seasons[i], "season..."), 
                       value = i / length(seasons))
    }
    
    cat("\nüìÖ Scraping", seasons[i], "season...\n")
    season_data <- get_necbl_woba_by_season(seasons[i])
    
    if (nrow(season_data) > 0) {
      # Verify composite keys for this season
      season_keys <- unique(season_data$Player_Team_Season_Key)
      duplicate_check <- season_data %>%
        group_by(Player_Team_Season_Key) %>%
        filter(n() > 1)
      
      if (nrow(duplicate_check) > 0) {
        cat("‚ö†Ô∏è  WARNING:", nrow(duplicate_check), "duplicate composite keys in", seasons[i], "\n")
        print(duplicate_check %>% select(Player, Player_Team_Season_Key, Team))
      } else {
        cat("‚úÖ All", length(season_keys), "composite keys unique for", seasons[i], "\n")
      }
      
      all_seasons_data <- rbind(all_seasons_data, season_data)
      total_composite_keys <- total_composite_keys + length(season_keys)
      cat("üìä Added", nrow(season_data), "records for", seasons[i], "\n")
    } else {
      cat("‚ùå No data found for", seasons[i], "\n")
    }
    
    # Small delay between seasons
    Sys.sleep(2)
  }
  
  cat("\n=== FINAL COMPOSITE KEY VERIFICATION ===\n")
  
  if (nrow(all_seasons_data) > 0) {
    # Check for any cross-season duplicates (shouldn't happen with season in key)
    all_keys <- all_seasons_data$Player_Team_Season_Key
    duplicate_keys <- all_seasons_data %>%
      group_by(Player_Team_Season_Key) %>%
      filter(n() > 1)
    
    if (nrow(duplicate_keys) > 0) {
      cat("‚ùå CRITICAL ERROR:", nrow(duplicate_keys), "duplicate composite keys across all seasons!\n")
      print(duplicate_keys %>% select(Player, Player_Team_Season_Key, Season, Team))
    } else {
      cat("‚úÖ ALL", length(unique(all_keys)), "COMPOSITE KEYS ARE GLOBALLY UNIQUE!\n")
    }
    
    # Summary statistics
    cat("\nüìà COMPOSITE KEY SUMMARY:\n")
    season_summary <- all_seasons_data %>%
      group_by(Season) %>%
      summarise(
        Players = n(),
        Unique_Keys = n_distinct(Player_Team_Season_Key),
        Teams = n_distinct(Team_Abbrev),
        Avg_wOBA = round(mean(wOBA, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(wOBACON, na.rm = TRUE), 3),
        .groups = "drop"
      ) %>%
      arrange(Season)
    
    print(season_summary)
    
    # Show sample composite keys from each season
    cat("\nüîç SAMPLE COMPOSITE KEYS BY SEASON:\n")
    sample_keys <- all_seasons_data %>%
      group_by(Season) %>%
      slice_head(n = 2) %>%
      select(Season, Player, Player_Team_Season_Key, Team_Abbrev) %>%
      ungroup()
    
    print(sample_keys)
    
  } else {
    cat("‚ùå NO DATA LOADED FROM ANY SEASON\n")
  }
  
  cat("\n=== TOTAL NECBL DATA LOADED ===\n")
  cat("üìä Total records across all seasons:", nrow(all_seasons_data), "\n")
  cat("üîë Total unique composite keys:", length(unique(all_seasons_data$Player_Team_Season_Key)), "\n")
  cat("üìÖ Seasons loaded:", paste(unique(all_seasons_data$Season), collapse = ", "), "\n")
  cat("üèüÔ∏è  Teams represented:", length(unique(all_seasons_data$Team_Abbrev)), "\n")
  
  return(all_seasons_data)
}

# Enhanced initialization with composite key support - FIXED VERSION
initialize_enhanced_data_composite <- function() {
  cat("=== INITIALIZING ENHANCED DATA WITH COMPOSITE KEY SUPPORT ===\n")
  
  # Try to use your existing data - check multiple possible names
  if (exists("pipeline_results") && is.data.frame(pipeline_results) && nrow(pipeline_results) > 0) {
    cat("‚úÖ Using existing pipeline_results data\n")
    base_data <- pipeline_results
    
    # Ensure proper xwOBA/xwOBACON separation
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("üîÑ Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_expected_xwoba_and_full(base_data, if(exists("expected")) expected else NULL)
    }
    
  } else if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("‚úÖ Using existing combined_df data\n")
    base_data <- combined_df
    
    # Ensure proper xwOBA/xwOBACON separation
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("üîÑ Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_expected_xwoba_and_full(base_data, if(exists("expected")) expected else NULL)
    }
    
  } else if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("‚úÖ Using raw_data and applying expected calculations\n")
    base_data <- calculate_expected_xwoba_and_full(raw_data, if(exists("expected")) expected else NULL)
    
  } else {
    cat("‚ùå No existing data found - create sample data first\n")
    return(NULL)
  }
  
  # Verify required columns exist
  required_cols <- c("Batter", "BatterTeam")
  missing_cols <- required_cols[!required_cols %in% names(base_data)]
  
  if (length(missing_cols) > 0) {
    cat("‚ùå MISSING REQUIRED COLUMNS:", paste(missing_cols, collapse = ", "), "\n")
    return(NULL)
  }
  
  # Check BatterTeam values against mapping
  unique_teams <- unique(base_data$BatterTeam)
  mapped_teams <- names(necbl_team_mapping_enhanced)
  unmapped_teams <- unique_teams[!unique_teams %in% mapped_teams]
  
  cat("üèüÔ∏è  TEAM CODE VERIFICATION:\n")
  cat("   Expected teams found:", paste(intersect(unique_teams, mapped_teams), collapse = ", "), "\n")
  
  if (length(unmapped_teams) > 0) {
    cat("‚ö†Ô∏è  UNMAPPED TEAM CODES:", paste(unmapped_teams, collapse = ", "), "\n")
    cat("   These will get 'UNK' abbreviation in composite keys\n")
  }
  
  # Ensure all required columns exist with proper defaults
  final_data <- base_data %>%
    mutate(
      predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else 0.350,
      predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else 0.400,
      
      # Initialize actual overlay columns for composite key matching
      actual_woba_final = NA_real_,
      actual_wobacon_final = NA_real_,
      data_source = "Expected Only"
    )
  
  cat("\n‚úÖ Enhanced data initialized with", nrow(final_data), "total records\n")
  
  return(final_data)
}
# ===================================================================
# SECTION 7: ENHANCED SHINY UI
# ===================================================================

ui <- dashboardPage(
  dashboardHeader(title = "Enhanced xwOBA Dashboard"),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Performance Analysis", tabName = "performance", icon = icon("chart-line")),
      menuItem("Underperformers", tabName = "underperform", icon = icon("arrow-down")),
      menuItem("Overperformers", tabName = "overperform", icon = icon("arrow-up")),
      menuItem("Player Comparison", tabName = "comparison", icon = icon("balance-scale")),
      menuItem("Team Browser", tabName = "browser", icon = icon("table"))
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .content-wrapper, .right-side {
          background-color: #f4f4f4;
        }
        .season-highlight {
          background-color: #fff3cd !important;
        }
        .exact-match {
          background-color: #d4edda !important;
        }
        .no-match {
          background-color: #f8d7da !important;
        }
        .box-solid > .box-header {
          color: #fff;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .progress-bar {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
      "))
    ),
    
    tabItems(
      # Performance Analysis Tab
      tabItem(tabName = "performance",
        fluidRow(
          box(
            title = "Season & Filter Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, 
                selectInput("primary_season", "Primary Season:", 
                           choices = c("2025", "2024", "2023", "2022", "2021"), 
                           selected = "2025")
              ),
              column(3, 
                selectInput("season_scope", "Show Players:", 
                           choices = c("Selected Season Only" = "selected", 
                                     "All Available Seasons" = "all"), 
                           selected = "selected")
              ),
              column(3, 
                selectInput("pa_threshold", "Minimum PAs:", 
                           choices = c("All Players" = 0, "10+" = 10, "20+" = 20, "30+" = 30),
                           selected = 20)
              ),
              column(3, 
                selectInput("metric_type", "Primary Metric:", 
                           choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                           selected = "xwoba")
              )
            ),
            hr(),
            fluidRow(
              column(3,
                actionButton("load_season", "Load Selected Season", 
                            class = "btn btn-primary", icon = icon("download"))
              ),
              column(3,
                actionButton("load_all", "Load All Seasons (2021-2025)", 
                            class = "btn btn-info", icon = icon("database"))
              ),
              column(6,
                div(id = "data_status", 
                    textOutput("current_data_status", inline = TRUE))
              )
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Expected vs Actual Performance", status = "primary", solidHeader = TRUE, width = 12,
            plotlyOutput("performance_plotly", height = "600px")
          )
        ),
        
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 4,
            selectInput("focus_player", "Focus on Player:", 
                       choices = c("All Players" = ""), selected = "")
          ),
          box(
            title = "Performance Summary", status = "info", solidHeader = TRUE, width = 8,
            DT::dataTableOutput("performance_summary")
          )
        )
      ),
      
      # Underperformers Tab
      tabItem(tabName = "underperform",
        fluidRow(
          box(
            title = "Players Getting Unlucky (Expected > Actual)", 
            status = "success", solidHeader = TRUE, width = 12,
            p(paste("Players whose expected predictions exceed their actual results.",
                   "These players may be due for positive regression.")),
            DT::dataTableOutput("underperformers_table")
          )
        )
      ),
      
      # Overperformers Tab
      tabItem(tabName = "overperform",
        fluidRow(
          box(
            title = "Players Getting Lucky (Actual > Expected)", 
            status = "warning", solidHeader = TRUE, width = 12,
            p(paste("Players whose actual results exceed their expected predictions.",
                   "These players may be due for negative regression.")),
            DT::dataTableOutput("overperformers_table")
          )
        )
      ),
      
      # Player Comparison Tab
      tabItem(tabName = "comparison",
        fluidRow(
          box(
            title = "Player Selection", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(4, selectInput("comp_player1", "Player 1:", choices = c("Choose Player" = ""))),
              column(4, selectInput("comp_player2", "Player 2:", choices = c("Choose Player" = ""))),
              column(4, dateRangeInput("comp_date_range", "Date Range:", 
                                      start = Sys.Date() - 90, end = Sys.Date()))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Performance Comparison", status = "primary", solidHeader = TRUE, width = 12,
            plotOutput("comparison_plot", height = "500px")
          )
        ),
        
        fluidRow(
          box(
            title = "Comparison Summary", status = "info", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("comparison_summary_table")
          )
        )
      ),
      
      # Team Browser Tab
      tabItem(tabName = "browser",
        fluidRow(
          box(
            title = "Browser Controls", status = "primary", solidHeader = TRUE, width = 12,
            fluidRow(
              column(3, selectInput("browser_team", "Filter by Team:", 
                                   choices = c("All Teams" = "All"))),
              column(3, selectInput("browser_player", "Filter by Player:", 
                                   choices = c("All Players" = "All"))),
              column(3, selectInput("browser_sort", "Sort by:", 
                                   choices = c("xwOBA" = "Avg_xwOBA", "wOBA" = "Avg_wOBA", 
                                             "xwOBACON" = "Avg_xwOBACON", "wOBACON" = "Avg_wOBACON", 
                                             "PAs" = "PA_Count"),
                                   selected = "Avg_xwOBA")),
              column(3, checkboxInput("show_only_matched", "Show Only Matched Players", value = FALSE))
            )
          )
        ),
        
        fluidRow(
          box(
            title = "Team & Player Browser", status = "primary", solidHeader = TRUE, width = 12,
            DT::dataTableOutput("browser_table")
          )
        )
      )
    )
  )
)
# ===================================================================
# SECTION 8 PART 1: ENHANCED SHINY SERVER - SEASON-AWARE VERSION (Reactive Values & Data Loading)
# ===================================================================

server <- function(input, output, session) {
  
  # Enhanced reactive values
  values <- reactiveValues(
    expected_data = NULL,
    necbl_data_all = NULL,
    necbl_data_current = NULL,
    enhanced_data = NULL,
    available_seasons = character(0),
    last_update = NULL
  )
  
  # Initialize with composite key support
  observe({
    if (is.null(values$expected_data)) {
      values$expected_data <- initialize_enhanced_data_composite()
      if (!is.null(values$expected_data)) {
        values$enhanced_data <- values$expected_data
        cat("‚úÖ Initialized with", nrow(values$enhanced_data), "expected records\n")
      }
    }
  })
  
  # CRITICAL FIX: Helper function for filtered data with SEASON-AWARE filtering
  get_filtered_data <- function() {
    req(values$enhanced_data)
    
    current_data <- values$enhanced_data
    
    if (is.null(current_data) || nrow(current_data) == 0) {
      return(data.frame())
    }
    
    # CRITICAL FIX: Apply season filter to EXPECTED data first, not just matches
    if (!is.null(input$season_scope) && input$season_scope == "selected" && 
        !is.null(input$primary_season)) {
      
      # Filter expected data to selected season FIRST
      if ("Expected_Season" %in% names(current_data)) {
        # Use existing Expected_Season column
        current_data <- current_data %>%
          filter(Expected_Season == input$primary_season)
        cat("Filtered to", input$primary_season, "using Expected_Season:", nrow(current_data), "records\n")
      } else if ("Date" %in% names(current_data)) {
        # Extract year from Date column and filter to selected season
        current_data <- current_data %>%
          mutate(
            Expected_Season = as.character(year(as.Date(Date)))
          ) %>%
          filter(Expected_Season == input$primary_season)
        cat("Filtered to", input$primary_season, "using Date extraction:", nrow(current_data), "records\n")
      } else {
        # If no season info, warn but continue
        cat("WARNING: No season information available - showing all data\n")
      }
    }
    
    # Apply PA threshold AFTER season filtering
    pa_threshold <- as.numeric(input$pa_threshold %||% 0)
    if (pa_threshold > 0) {
      current_data <- current_data %>%
        group_by(Batter) %>%
        filter(n() >= pa_threshold) %>%
        ungroup()
    }
    
    return(current_data)
  }
  
  # Update UI choices dynamically - SEASON-AWARE
  observe({
    current_data <- get_filtered_data()
    
    if (!is.null(current_data) && nrow(current_data) > 0) {
      player_choices <- c("All Players" = "", sort(unique(current_data$Batter)))
      
      updateSelectInput(session, "focus_player", choices = player_choices)
      updateSelectInput(session, "comp_player1", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "comp_player2", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
      updateSelectInput(session, "browser_player", choices = c("All Players" = "All", sort(unique(current_data$Batter))))
      
      if ("BatterTeam" %in% names(current_data)) {
        team_choices <- c("All Teams" = "All", sort(unique(current_data$BatterTeam)))
        updateSelectInput(session, "browser_team", choices = team_choices)
      }
    }
  })
  
  # Enhanced data status - show nothing after loading
  output$current_data_status <- renderText({
    ""
  })
  
  # Load selected season - SEASON-AWARE
  observeEvent(input$load_season, {
    withProgress(message = paste('Loading', input$primary_season, 'season...'), value = 0, {
      
      incProgress(0.3, detail = "Scraping actual data...")
      
      tryCatch({
        # Scrape selected season
        season_data <- get_necbl_woba_by_season(input$primary_season)
        
        if (!is.null(season_data) && nrow(season_data) > 0) {
          values$necbl_data_current <- season_data
          
          # Update all seasons cache
          if (!is.null(values$necbl_data_all)) {
            values$necbl_data_all <- values$necbl_data_all %>%
              filter(Season != input$primary_season) %>%
              rbind(season_data)
          } else {
            values$necbl_data_all <- season_data
          }
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.6, detail = "Matching data...")
          
          # CRITICAL FIX: Re-match with season-aware matching
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data_composite(
              values$expected_data, 
              values$necbl_data_all, 
              input$primary_season  # This ensures season-specific matching
            )
          }
          
          incProgress(1.0, detail = "Complete!")
          
        } else {
          showNotification(
            paste("‚ùå No data found for", input$primary_season, "season"),
            type = "error", duration = 10
          )
        }
      }, error = function(e) {
        showNotification(
          paste("‚ùå Error loading", input$primary_season, ":", e$message),
          type = "error", duration = 15
        )
      })
    })
  })
  
  # Load all seasons - SEASON-AWARE
  observeEvent(input$load_all, {
    withProgress(message = 'Loading all NECBL seasons...', value = 0, {
      
      tryCatch({
        # Use progress callback
        progress_func <- function(detail = "", value = 0) {
          incProgress(value * 0.8, detail = detail)
        }
        
        values$necbl_data_all <- get_all_necbl_seasons_composite(progress_func)
        
        if (!is.null(values$necbl_data_all) && nrow(values$necbl_data_all) > 0) {
          values$necbl_data_current <- values$necbl_data_all %>%
            filter(Season == input$primary_season)
          
          values$available_seasons <- unique(values$necbl_data_all$Season)
          values$last_update <- Sys.time()
          
          incProgress(0.9, detail = "Matching data...")
          
          # CRITICAL FIX: Re-match with season-aware matching
          if (!is.null(values$expected_data)) {
            values$enhanced_data <- match_necbl_data_composite(
              values$expected_data, 
              values$necbl_data_all, 
              input$primary_season  # This ensures season-specific matching
            )
          }
          
          incProgress(1.0, detail = "All seasons loaded!")
          
        } else {
          showNotification("‚ùå Error loading season data", type = "error", duration = 10)
        }
      }, error = function(e) {
        showNotification(paste("‚ùå Error loading all seasons:", e$message), type = "error", duration = 15)
      })
    })
  })
# Enhanced performance plot - SEASON-AWARE VERSION
  output$performance_plotly <- renderPlotly({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    
    if (nrow(current_data) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = paste0("No data available for ", input$primary_season, "\nLoad season data first")), size = 6) +
        theme_void()
      return(ggplotly(p))
    }
    
    # Filter for specific player if selected
    if (!is.null(input$focus_player) && input$focus_player != "") {
      current_data <- current_data %>% filter(Batter == input$focus_player)
      plot_title <- paste("Performance Analysis:", input$focus_player, "(", input$primary_season, ")")
    } else {
      plot_title <- paste("Performance Analysis:", input$primary_season, "Season")
    }
    
    # Calculate player-level performance metrics - SEASON-AWARE
    player_performance <- current_data %>%
      filter(!is.na(actual_woba_final)) %>%  # Only matched players
      group_by(Batter) %>%
      summarise(
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        xwOBACON = mean(predicted_xwobacon_final, na.rm = TRUE),
        wOBACON = mean(actual_wobacon_final, na.rm = TRUE),
        PA_Count = n(),
        Team = first(BatterTeam),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      )
    
    if (nrow(player_performance) == 0) {
      p <- ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, 
                     label = paste0("No matched players for ", input$primary_season, "\n\nClick 'Load Selected Season' to get NECBL data")), 
                  size = 6, color = "#667eea") +
        theme_void()
      return(ggplotly(p))
    }
    
    # Select metrics based on input
    if (input$metric_type == "xwoba") {
      plot_data <- player_performance %>%
        select(Batter, xwOBA, wOBA, PA_Count, Team, Season) %>%
        rename(Expected = xwOBA, Actual = wOBA)
      x_label <- paste("wOBA (Actual", input$primary_season, ")")
      y_label <- paste("xwOBA (Expected", input$primary_season, ")")
    } else {
      plot_data <- player_performance %>%
        select(Batter, xwOBACON, wOBACON, PA_Count, Team, Season) %>%
        rename(Expected = xwOBACON, Actual = wOBACON)
      x_label <- paste("wOBACON (Actual", input$primary_season, ")")
      y_label <- paste("xwOBACON (Expected", input$primary_season, ")")
    }
    
    # Create enhanced scatter plot - SEASON-AWARE
    p <- ggplot(plot_data, aes(x = Actual, y = Expected, text = paste(
      "Player:", Batter,
      "<br>Team:", Team,
      "<br>Season:", Season,
      "<br>PAs:", PA_Count,
      "<br>Expected:", round(Expected, 3),
      "<br>Actual:", round(Actual, 3),
      "<br>Difference:", round(Expected - Actual, 3)
    ))) +
      geom_point(aes(color = Season), size = 4, alpha = 0.8) +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "#dc3545", size = 1) +
      scale_color_manual(values = c("2025" = "#28a745", 
                                   "2024" = "#20c997", 
                                   "2023" = "#fd7e14", 
                                   "2022" = "#ffc107",
                                   "2021" = "#6f42c1")) +
      labs(title = plot_title,
           x = x_label, y = y_label, color = "Season") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "right"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        title = list(text = plot_title, font = list(size = 16)),
        showlegend = TRUE
      )
  })
  
  # Performance summary table - SEASON-AWARE
  output$performance_summary <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    
    if (nrow(current_data) == 0) return(data.frame())
    
    summary_data <- current_data %>%
      filter(!is.na(actual_woba_final)) %>%  # Only matched players
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      arrange(desc(abs(wOBA_Diff)))
    
    DT::datatable(
      summary_data,
      options = list(pageLength = 10, scrollX = TRUE),
      caption = paste("Performance Summary -", input$primary_season, "Season Only"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(columns = c('wOBA_Diff', 'wOBACON_Diff'), 
                  backgroundColor = styleInterval(c(-0.025, 0.025), c('#f8d7da', '#ffffff', '#d4edda')))
  })
# Underperformers table - SEASON-AWARE
  output$underperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    underperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%  # Only matched players
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      underperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Unlucky -", input$primary_season, "Season"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#d4edda')
  })
  
  # Overperformers table - SEASON-AWARE
  output$overperformers_table <- DT::renderDataTable({
    current_data <- get_filtered_data()  # This now returns season-filtered data
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    overperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%  # Only matched players
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(wOBA - xwOBA, 3),
        wOBACON_Diff = round(wOBACON - xwOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(
      overperformers,
      options = list(pageLength = 15, scrollX = TRUE),
      caption = paste("Players Getting Lucky -", input$primary_season, "Season"),
      rownames = FALSE
    ) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#f8d7da')
  })
# Player comparison plot - SEASON-AWARE
output$comparison_plot <- renderPlot({
  req(input$comp_player1, input$comp_player2)
  
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if ("Date" %in% names(current_data)) {
    current_data <- current_data %>%
      filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
  }
  
  comparison_data <- current_data %>%
    filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
    arrange(if("Date" %in% names(.)) Date else row_number()) %>%
    group_by(Batter) %>%
    mutate(
      PA_Number = row_number(),
      Cumulative_xwOBA = cummean(predicted_xwoba_final),
      Cumulative_wOBA = cummean(actual_woba_final),
      Cumulative_xwOBACON = cummean(predicted_xwobacon_final),
      Cumulative_wOBACON = cummean(actual_wobacon_final)
    ) %>%
    ungroup()
  
  if (nrow(comparison_data) > 0) {
    line_data <- comparison_data %>%
      select(Batter, PA_Number, Cumulative_xwOBA, Cumulative_wOBA, Cumulative_xwOBACON, Cumulative_wOBACON) %>%
      pivot_longer(cols = starts_with("Cumulative"), names_to = "Metric", values_to = "Value") %>%
      mutate(
        Metric = gsub("Cumulative_", "", Metric),
        Line_Type = ifelse(grepl("x", Metric), "Expected", paste("Actual", input$primary_season)),
        Metric_Type = ifelse(grepl("OBACON", Metric), "wOBACON (Batted Balls)", "wOBA (All PAs)")
      ) %>%
      filter(!is.na(Value))
    
    ggplot(line_data, aes(x = PA_Number, y = Value, color = Batter, linetype = Line_Type)) +
      geom_line(size = 1.2, alpha = 0.8) +
      facet_wrap(~Metric_Type, scales = "free_y") +
      scale_color_manual(values = c("#667eea", "#764ba2")) +
      scale_linetype_manual(values = setNames(
        c("solid", "dashed"),
        c("Expected", paste0("Actual ", input$primary_season))
      )) +
      labs(title = paste("Performance Comparison (", input$primary_season, " Season):", input$comp_player1, "vs", input$comp_player2),
           subtitle = paste("Cumulative performance -", input$primary_season, "season"),
           x = "Plate Appearance Number", y = "Cumulative Value",
           color = "Player", linetype = "Type") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        legend.position = "top"
      )
  } else {
    ggplot() + 
      geom_text(aes(x = 0.5, y = 0.5, label = paste0("No data for selected players in ", input$primary_season)), size = 6) +
      theme_void()
  }
})

# Comparison summary table - SEASON-AWARE
output$comparison_summary_table <- DT::renderDataTable({
  req(input$comp_player1, input$comp_player2)
  
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if ("Date" %in% names(current_data)) {
    current_data <- current_data %>%
      filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
  }
  
  comparison_summary <- current_data %>%
    filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
    group_by(Batter) %>%
    summarise(
      PA = n(),
      Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
      Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
      Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
      Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
      wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
      wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
      Team = first(BatterTeam),
      Has_Actual_Data = !all(is.na(actual_woba_final)),
      Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
      .groups = "drop"
    ) %>%
    select(-Has_Actual_Data)  # Keep for logic but don't display
  
  DT::datatable(
    comparison_summary,
    options = list(pageLength = 15, scrollX = TRUE),
    caption = paste("Player Comparison Summary -", input$primary_season, "Season"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3)
})
# Enhanced team browser - SEASON-AWARE
output$browser_table <- DT::renderDataTable({
  current_data <- get_filtered_data()  # This now returns season-filtered data
  
  if (!is.null(input$browser_team) && input$browser_team != "All") {
    if ("BatterTeam" %in% names(current_data)) {
      current_data <- current_data %>% filter(BatterTeam == input$browser_team)
    }
  }
  
  if (!is.null(input$browser_player) && input$browser_player != "All") {
    current_data <- current_data %>% filter(Batter == input$browser_player)
  }
  
  browser_data <- current_data %>%
    group_by(Batter) %>%
    summarise(
      PA_Count = n(),
      Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
      Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
      Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
      Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
      wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
      wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
      Team = first(BatterTeam),
      Has_Actual_Data = !all(is.na(actual_woba_final)),
      Season = if("Expected_Season" %in% names(current_data)) first(Expected_Season) else input$primary_season,
      .groups = "drop"
    )
  
  # Apply matched players filter if requested
  if (!is.null(input$show_only_matched) && input$show_only_matched) {
    browser_data <- browser_data %>% filter(Has_Actual_Data)
  }
  
  # For selected season scope: only show players from selected season
  if (!is.null(input$season_scope) && input$season_scope == "selected") {
    browser_data <- browser_data %>% 
      filter(Season == input$primary_season)
  }
  
  browser_data <- browser_data %>%
    arrange(desc(!!sym(input$browser_sort))) %>%
    select(-Has_Actual_Data)  # Keep for logic but don't display
  
  DT::datatable(
    browser_data,
    options = list(pageLength = 25, scrollX = TRUE),
    caption = paste("Team & Player Browser -", input$primary_season, "Season Focus"),
    rownames = FALSE
  ) %>%
    formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3)
})

}
# ===================================================================
# SECTION 9: FINAL LAUNCH FUNCTIONS AND USAGE INSTRUCTIONS - SEASON-AWARE VERSION
# ===================================================================

# Function to launch the season-aware enhanced dashboard
launch_xwoba_dashboard_composite <- function() {
  # Check if required data exists - check multiple possible names
  data_exists <- exists("pipeline_results") || exists("combined_df") || exists("raw_data")
  
  if (!data_exists) {
    stop("‚ùå No expected data found. Please ensure 'pipeline_results', 'combined_df', or 'raw_data' exists in your environment.")
  }
  
  cat("üéØ Launching Enhanced xwOBA Dashboard - Season-Aware Edition...\n")
  cat("‚úÖ Season-aware matching system\n")
  cat("‚úÖ Expected data filtered by season BEFORE matching\n")
  cat("‚úÖ Exact joins only - no ambiguous fuzzy matching\n") 
  cat("‚úÖ OCE_STA and OCE_STA6 both map to Ocean State Waves\n")
  cat("‚úÖ NSH_N maps to North Shore Navigators\n")
  cat("‚úÖ 'X' character removal from NECBL player names\n")
  cat("‚úÖ FIXED: Multi-season players properly separated by season\n")
  cat("‚úÖ Interactive Plotly visualizations\n")
  cat("‚úÖ Season-specific filtering and analysis throughout\n")
  
  shinyApp(ui = ui, server = server)
}

# Helper function to verify data readiness - SEASON-AWARE VERSION
verify_data_readiness <- function() {
  cat("=== SEASON-AWARE DATA READINESS VERIFICATION ===\n")
  
  # Check for required data
  data_sources <- c()
  if (exists("pipeline_results")) data_sources <- c(data_sources, "pipeline_results")
  if (exists("combined_df")) data_sources <- c(data_sources, "combined_df")
  if (exists("raw_data")) data_sources <- c(data_sources, "raw_data")
  
  if (length(data_sources) == 0) {
    cat("‚ùå NO DATA FOUND\n")
    cat("   Please ensure 'pipeline_results', 'combined_df', or 'raw_data' exists in your environment\n")
    return(FALSE)
  }
  
  cat("‚úÖ DATA SOURCES FOUND:", paste(data_sources, collapse = ", "), "\n")
  
  # Get the primary data source
  if (exists("pipeline_results")) {
    primary_data <- pipeline_results
    data_name <- "pipeline_results"
  } else if (exists("combined_df")) {
    primary_data <- combined_df
    data_name <- "combined_df"
  } else {
    primary_data <- raw_data
    data_name <- "raw_data"
  }
  
  cat("üìä PRIMARY DATA SOURCE:", data_name, "with", nrow(primary_data), "records\n")
  
  # Check required columns
  required_cols <- c("Batter", "BatterTeam")
  missing_cols <- required_cols[!required_cols %in% names(primary_data)]
  
  if (length(missing_cols) > 0) {
    cat("‚ùå MISSING REQUIRED COLUMNS:", paste(missing_cols, collapse = ", "), "\n")
    return(FALSE)
  }
  
  cat("‚úÖ REQUIRED COLUMNS FOUND:", paste(required_cols, collapse = ", "), "\n")
  
  # Check for season information
  if ("Date" %in% names(primary_data)) {
    seasons_found <- primary_data %>%
      mutate(Season = as.character(year(as.Date(Date)))) %>%
      count(Season) %>%
      arrange(Season)
    
    cat("üóìÔ∏è  SEASONS FOUND IN DATA:\n")
    print(seasons_found)
  } else if ("Expected_Season" %in% names(primary_data)) {
    seasons_found <- primary_data %>%
      count(Expected_Season) %>%
      arrange(Expected_Season)
    
    cat("üóìÔ∏è  SEASONS FOUND IN DATA:\n")
    print(seasons_found)
  } else {
    cat("‚ö†Ô∏è  NO SEASON INFORMATION FOUND - will default to 2025\n")
  }
  
  # Check team codes
  unique_teams <- unique(primary_data$BatterTeam)
  mapped_teams <- names(necbl_team_mapping_enhanced)
  unmapped_teams <- unique_teams[!unique_teams %in% mapped_teams]
  
  cat("üèüÔ∏è  TEAM CODE STATUS:\n")
  cat("   Total unique team codes:", length(unique_teams), "\n")
  cat("   Mapped team codes:", length(intersect(unique_teams, mapped_teams)), "\n")
  
  if (length(unmapped_teams) > 0) {
    cat("‚ö†Ô∏è  UNMAPPED TEAM CODES:", paste(unmapped_teams, collapse = ", "), "\n")
    cat("   These will get 'UNK' abbreviation\n")
  }
  
  # Show sample data with season info
  cat("\nüîç SAMPLE DATA PREVIEW:\n")
  if ("Date" %in% names(primary_data)) {
    sample_data <- primary_data %>%
      mutate(Season = as.character(year(as.Date(Date)))) %>%
      select(any_of(c("Batter", "BatterTeam", "Date", "Season", "Inning"))) %>%
      head(3)
  } else {
    sample_data <- primary_data %>%
      select(any_of(c("Batter", "BatterTeam", "Expected_Season", "Date", "Inning"))) %>%
      head(3)
  }
  print(sample_data)
  
  cat("\n‚úÖ SEASON-AWARE DATA VERIFICATION COMPLETE - READY FOR LAUNCH!\n")
  return(TRUE)
}

# Function to test season-aware system
test_composite_key_system <- function() {
  cat("=== TESTING SEASON-AWARE SYSTEM ===\n")
  
  # Test season filtering logic
  cat("\nüóìÔ∏è  TESTING SEASON FILTERING LOGIC:\n")
  
  if (exists("pipeline_results")) {
    if ("Date" %in% names(pipeline_results)) {
      season_summary <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        count(Season, name = "Records") %>%
        arrange(Season)
      
      cat("   Seasons available in your data:\n")
      print(season_summary)
      
      # Test filtering to 2025
      test_2025 <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        filter(Season == "2025")
      
      cat("   Records when filtered to 2025:", nrow(test_2025), "\n")
      
      if (nrow(test_2025) > 0) {
        unique_players_2025 <- length(unique(test_2025$Batter))
        cat("   Unique players in 2025:", unique_players_2025, "\n")
      }
    } else {
      cat("   No Date column found - season filtering may not work optimally\n")
    }
  } else {
    cat("   No pipeline_results found - cannot test season filtering\n")
  }
  
  cat("\n‚úÖ SEASON-AWARE SYSTEM TEST COMPLETE!\n")
}

# Enhanced usage instructions - SEASON-AWARE VERSION
print_usage_instructions <- function() {
  cat("=== ENHANCED xwOBA DASHBOARD - SEASON-AWARE EDITION ===\n\n")
  
  cat("üöÄ QUICK START:\n")
  cat("   1. verify_data_readiness()              # Check if your data is ready\n")
  cat("   2. test_composite_key_system()          # Test the season-aware system\n")
  cat("   3. launch_xwoba_dashboard_composite()   # Launch the dashboard\n\n")
  
  cat("üîß KEY FIXES IN THIS VERSION:\n")
  cat("   ‚úÖ FIXED: Multi-season players properly separated\n")
  cat("   ‚úÖ FIXED: Expected data filtered by season BEFORE analysis\n")
  cat("   ‚úÖ FIXED: When you select 2025, only 2025 expected data is used\n")
  cat("   ‚úÖ FIXED: Season-aware matching prevents data contamination\n")
  cat("   ‚úÖ FIXED: All tables and plots show season-specific data only\n\n")
  
  cat("üìã KEY FEATURES:\n")
  cat("   ‚úÖ Season-aware matching (no more cross-season contamination)\n")
  cat("   ‚úÖ Expected data properly filtered by season before analysis\n")
  cat("   ‚úÖ Interactive Plotly plots with season info in tooltips\n")
  cat("   ‚úÖ All analysis restricted to selected season only\n")
  cat("   ‚úÖ Enhanced verification and debugging tools\n")
  cat("   ‚úÖ OCE_STA/OCE_STA6 both map correctly to Ocean State Waves\n")
  cat("   ‚úÖ NSH_N maps correctly to North Shore Navigators\n")
  cat("   ‚úÖ 'X' character removal from NECBL player names\n\n")
  
  cat("üìñ DASHBOARD USAGE:\n")
  cat("   1. Launch dashboard and select your desired season (2025, 2024, etc.)\n")
  cat("   2. Click 'Load Selected Season' to get NECBL data for that season only\n")
  cat("   3. Expected data automatically filtered to match selected season\n")
  cat("   4. All analysis (plots, tables) shows only that season's data\n")
  cat("   5. Multi-season players properly separated by season\n\n")
  
  cat("‚ö†Ô∏è  REQUIREMENTS:\n")
  cat("   ‚Ä¢ Your data must have 'Batter', 'BatterTeam', and 'Date' columns\n")
  cat("   ‚Ä¢ Date column used to extract season information\n")
  cat("   ‚Ä¢ Internet connection for NECBL data scraping\n")
  cat("   ‚Ä¢ R packages: shiny, shinydashboard, DT, ggplot2, dplyr, tidyr, rvest, httr, stringr, xml2, plotly\n\n")
  
  cat("üéØ TROUBLESHOOTING:\n")
  cat("   ‚Ä¢ Player showing multiple seasons? Check if Date column exists and is formatted correctly\n")
  cat("   ‚Ä¢ No season separation? Verify Date column contains proper dates\n")
  cat("   ‚Ä¢ No data loading? Check internet connection and NECBL website status\n\n")
}

# Quick test function to verify season-aware system works
quick_composite_test <- function() {
  cat("üî• QUICK SEASON-AWARE TEST\n")
  
  # Test with actual data if available
  if (exists("pipeline_results")) {
    cat("‚úÖ Testing with pipeline_results...\n")
    
    # Check for season information
    if ("Date" %in% names(pipeline_results)) {
      seasons <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        count(Season) %>%
        arrange(Season)
      
      cat("‚úÖ Season information found:\n")
      print(seasons)
      
      # Test season filtering
      test_2025 <- pipeline_results %>%
        mutate(Season = as.character(year(as.Date(Date)))) %>%
        filter(Season == "2025")
      
      if (nrow(test_2025) > 0) {
        cat("‚úÖ Season filtering works: 2025 has", nrow(test_2025), "records\n")
        
        # Test a small scrape and match for 2025
        small_test <- tryCatch({
          get_necbl_woba_by_season("2025")
        }, error = function(e) {
          cat("‚ùå Scraping test failed:", e$message, "\n")
          return(data.frame())
        })
        
        if (nrow(small_test) > 0) {
          cat("‚úÖ Scraping works:", nrow(small_test), "players for 2025\n")
          
          # Test season-aware matching
          small_match <- match_necbl_data_composite(pipeline_results, small_test, "2025")
          matches <- sum(!is.na(small_match$actual_woba_final))
          cat("‚úÖ Season-aware matching works:", matches, "matches for 2025\n")
          
          if (matches > 0) {
            cat("üéâ SEASON-AWARE SYSTEM IS WORKING! Ready to launch dashboard.\n")
            return(TRUE)
          }
        }
      } else {
        cat("‚ö†Ô∏è  No 2025 data found - try different season\n")
      }
    } else {
      cat("‚ö†Ô∏è  No Date column found - season awareness may not work\n")
    }
  }
  
  cat("‚ö†Ô∏è  Test inconclusive - run verify_data_readiness() for details\n")
  return(FALSE)
}

# ===================================================================
# FINAL SETUP AND INSTRUCTIONS
# ===================================================================

# Display instructions immediately when code is loaded
cat("=== ENHANCED xwOBA DASHBOARD - SEASON-AWARE EDITION LOADED! ===\n\n")

print_usage_instructions()

cat("üî• READY TO LAUNCH WITH SEASON AWARENESS! Run: launch_xwoba_dashboard_composite()\n\n")

# Make main functions available in global environment
if (!exists("launch_xwoba_dashboard")) {
  assign("launch_xwoba_dashboard", launch_xwoba_dashboard_composite, envir = .GlobalEnv)
}

assign("launch_xwoba_dashboard_composite", launch_xwoba_dashboard_composite, envir = .GlobalEnv)
assign("verify_data_readiness", verify_data_readiness, envir = .GlobalEnv)
assign("test_composite_key_system", test_composite_key_system, envir = .GlobalEnv)
assign("print_usage_instructions", print_usage_instructions, envir = .GlobalEnv)
assign("quick_composite_test", quick_composite_test, envir = .GlobalEnv)

quick_composite_test()

launch_xwoba_dashboard_composite()
