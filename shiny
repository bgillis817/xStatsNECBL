# Enhanced xwOBA Dashboard with Proper Model Integration
library(shiny)
library(ggplot2)
library(DT)
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
library(stringr)
library(xml2)

# ===================================================================
# CORE MODEL INTEGRATION - Using Your Established Methods
# ===================================================================

# Enhanced xwOBA calculation with proper PA integration
calculate_model_xwoba_and_full <- function(raw_data, xgb_model = NULL) {
  cat("=== CALCULATING MODEL xwOBA WITH PROPER PA INTEGRATION ===\n")
  
  # Step 1: Filter to batted balls with complete data (your existing filter)
  batted_balls <- raw_data %>%
    filter(
      PlayResult %in% c("Single", "Double", "Triple", "HomeRun", "Out",
                        "FieldersChoice", "Error", "Sacrifice") &
      !is.na(ExitSpeed) & ExitSpeed > 0 &
      !is.na(Angle) & !is.na(Batter)
    )
  
  cat("Batted balls with tracking data:", nrow(batted_balls), "\n")
  
  # Outcome classification for batted balls (your existing mapping)
  batted_balls$outcome <- case_when(
    batted_balls$PlayResult %in% c("Single") ~ "single",
    batted_balls$PlayResult %in% c("Double") ~ "double", 
    batted_balls$PlayResult %in% c("Triple") ~ "triple",
    batted_balls$PlayResult %in% c("HomeRun") ~ "home_run",
    batted_balls$PlayResult %in% c("Out", "FieldersChoice", "Error", "Sacrifice") ~ "out",
    TRUE ~ "other"
  )
  
  batted_balls <- batted_balls[batted_balls$outcome != "other", ]
  
  # Your wOBA weights
  woba_weights_vector <- c(0.000, 0.888, 1.271, 1.616, 2.101)
  
  # Get model predictions for batted balls
  if (!is.null(xgb_model) && exists("dtest")) {
    test_probs <- predict(xgb_model, dtest, reshape = TRUE)
    colnames(test_probs) <- c("P_out", "P_single", "P_double", "P_triple", "P_home_run")
    
    # Calculate xwOBACON (contact only)
    predicted_xwobacon <- as.vector(test_probs %*% woba_weights_vector)
    batted_balls$predicted_xwobacon <- predicted_xwobacon
  } else {
    # Fallback calculation if model objects not available
    batted_balls$predicted_xwobacon <- pmin(2.5, pmax(0, 
      0.1 + (batted_balls$ExitSpeed - 60) * 0.01 + 
      pmax(0, 30 - abs(batted_balls$Angle - 20)) * 0.005
    ))
  }
  
  cat("xwOBACON calculated for", nrow(batted_balls), "batted balls\n")
  
  # Step 2: Get ALL plate appearances for each player
  all_pa <- raw_data %>% 
    filter(!is.na(Batter)) %>%
    mutate(
      pa_outcome = case_when(
        PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
        PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
        PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
        KorBB == "Walk" ~ "walk",
        KorBB == "IntentionalWalk" ~ "intentional_walk",
        PitchCall == "HitByPitch" ~ "hit_by_pitch",
        KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
        TRUE ~ "other"
      )
    ) %>%
    filter(pa_outcome != "other")
  
  cat("Total plate appearances:", nrow(all_pa), "\n")
  
  # Step 3: Calculate player-level xwOBA (full PA denominator)
  player_xwoba_full <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    group_by(Batter) %>%
    summarise(
      # Count PA components
      hits = sum(pa_outcome == "hit"),
      outs = sum(pa_outcome == "out"),
      strikeouts = sum(pa_outcome == "strikeout"),
      BB = sum(pa_outcome == "walk"),
      IBB = sum(pa_outcome == "intentional_walk"),
      SF = sum(pa_outcome == "sacrifice_fly"),
      HBP = sum(pa_outcome == "hit_by_pitch"),
      
      # Calculate denominators
      batted_balls_count = hits + outs,
      AB = hits + outs + strikeouts,
      total_pa = AB + BB - IBB + SF + HBP,
      
      # Get mean xwOBACON for batted balls
      mean_xwobacon = mean(predicted_xwobacon, na.rm = TRUE),
      
      # Calculate full xwOBA using your method
      wBB_HBP = 0.690,
      xwoba_numerator = (mean_xwobacon * batted_balls_count) + (wBB_HBP * (BB - IBB + HBP)),
      predicted_xwoba_full = ifelse(total_pa > 0, xwoba_numerator / total_pa, NA_real_),
      
      .groups = "drop"
    )
  
  cat("Player-level xwOBA calculated for", nrow(player_xwoba_full), "players\n")
  
  # Step 4: Merge back to individual PA level
  enhanced_data <- all_pa %>%
    left_join(
      batted_balls %>% select(Batter, Date, Inning, PAofInning, predicted_xwobacon),
      by = c("Batter", "Date", "Inning", "PAofInning")
    ) %>%
    left_join(
      player_xwoba_full %>% select(Batter, predicted_xwoba_full, mean_xwobacon),
      by = "Batter"
    ) %>%
    mutate(
      # Final metrics
      predicted_xwoba_final = predicted_xwoba_full,  # Full PA denominator
      predicted_xwobacon_final = ifelse(!is.na(predicted_xwobacon), predicted_xwobacon, mean_xwobacon)  # Contact only
    )
  
  cat("=== CALCULATION SUMMARY ===\n")
  cat("Total enhanced records:", nrow(enhanced_data), "\n")
  cat("Records with xwOBA:", sum(!is.na(enhanced_data$predicted_xwoba_final)), "\n")
  cat("Records with xwOBACON:", sum(!is.na(enhanced_data$predicted_xwobacon_final)), "\n")
  
  
  
  return(enhanced_data)
}

# Your full xwOBA calculation (including walks, HBP)
calculate_full_xwoba <- function(raw_data, batted_ball_xwoba) {
  # All plate appearances classification
  all_pa <- raw_data %>% filter(!is.na(Batter))
  
  all_pa$outcome <- case_when(
    all_pa$PlayResult %in% c("Single", "Double", "Triple", "HomeRun") ~ "hit",
    all_pa$PlayResult %in% c("Out", "FieldersChoice", "Error") ~ "out", 
    all_pa$PlayResult %in% c("Sacrifice") ~ "sacrifice_fly",
    all_pa$KorBB == "Walk" ~ "walk",
    all_pa$KorBB == "IntentionalWalk" ~ "intentional_walk",
    all_pa$PitchCall == "HitByPitch" ~ "hit_by_pitch",
    all_pa$KorBB %in% c("Strikeout", "StrikeoutLooking", "StrikeoutSwinging") ~ "strikeout",
    TRUE ~ "other"
  )
  
  classified_pa <- all_pa[all_pa$outcome != "other", ]
  
  # Calculate components
  hits <- sum(classified_pa$outcome == "hit")
  outs <- sum(classified_pa$outcome == "out") 
  strikeouts <- sum(classified_pa$outcome == "strikeout")
  BB <- sum(classified_pa$outcome == "walk")
  IBB <- sum(classified_pa$outcome == "intentional_walk")
  SF <- sum(classified_pa$outcome == "sacrifice_fly")
  HBP <- sum(classified_pa$outcome == "hit_by_pitch")
  
  batted_balls <- hits + outs
  AB <- hits + outs + strikeouts
  denominator <- AB + BB - IBB + SF + HBP
  
  # Your calculation method
  mean_xwoba_contact <- mean(batted_ball_xwoba, na.rm = TRUE)
  wBB_HBP <- 0.690
  
  numerator <- (mean_xwoba_contact * batted_balls) + (wBB_HBP * (BB - IBB + HBP))
  full_xwoba <- numerator / denominator
  
  return(list(
    full_xwoba = full_xwoba,
    xwoba_contact = mean_xwoba_contact,
    batted_balls = batted_balls,
    total_pa = denominator
  ))
}

# ===================================================================
# NECBL TEAM MAPPING & POINTSTREAK INTEGRATION
# ===================================================================

necbl_team_mapping <- list(
  "BRI_B" = list(name = "Bristol Blues", abbrev = "BRI"),
  "DAN_WES" = list(name = "Danbury Westerners", abbrev = "DAN"),
  "KEE_SWA" = list(name = "Keene SwampBats", abbrev = "KSB"),
  "MAR_VIN" = list(name = "Martha's Vineyard Sharks", abbrev = "MV"),
  "MYS_SCH" = list(name = "Mystic Schooners", abbrev = "MSC"),
  "NEW_GUL" = list(name = "Newport Gulls", abbrev = "NG"),
  "NOR_ADA" = list(name = "North Adams Steeplecats", abbrev = "NSC"),
  "NSH_N" = list(name = "North Shore Navigators", abbrev = "NSN"),
  "OCE_STA" = list(name = "Ocean State Waves", abbrev = "OSW"),
  "SAN_MAI" = list(name = "Sanford Mainers", abbrev = "SM"),
  "UPP_VAL" = list(name = "Upper Valley Nighthawks", abbrev = "UVNH"),
  "VAL_BLU" = list(name = "Valley Blue Sox", abbrev = "VAL"),
  "VER_MOU" = list(name = "Vermont Mountaineers", abbrev = "VM")
)

# NECBL URLs for seasons 2021-2025
necbl_urls_by_season <- list(
  "2025" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=34029&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=34029",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=34029",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=34029",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=34029",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=34029",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=34029",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=34029",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=34029",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=34029",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=34029",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=34029",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=34029"
  ),
  "2024" = list(
    "Bristol Blues" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?leagueid=204&seasonid=33860&teamid=89490",
    "Danbury Westerners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6402&seasonid=33860",
    "Keene SwampBats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6401&seasonid=33860",
    "Martha's Vineyard Sharks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=142675&seasonid=33860",
    "Mystic Schooners" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=11912&seasonid=33860",
    "Newport Gulls" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6458&seasonid=33860",
    "North Adams Steeplecats" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6404&seasonid=33860",
    "North Shore Navigators" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=154432&seasonid=33860",
    "Ocean State Waves" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=51489&seasonid=33860",
    "Sanford Mainers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6459&seasonid=33860",
    "Upper Valley Nighthawks" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=104040&seasonid=33860",
    "Valley Blue Sox" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6403&seasonid=33860",
    "Vermont Mountaineers" = "http://necbl.wttbaseball.pointstreak.com/team_stats.html?teamid=6405&seasonid=33860"
  )
  # Add 2023, 2022, 2021 similarly...
)

# Enhanced Pointstreak scraper with proper wOBA/wOBACON calculation
get_necbl_woba_by_season <- function(season = "2025") {
  cat("=== SCRAPING NECBL", season, "SEASON ===\n")
  
  necbl_urls <- necbl_urls_by_season[[season]]
  if (is.null(necbl_urls)) {
    cat("ERROR: Season", season, "not available\n")
    return(data.frame())
  }
  
  all_woba <- data.frame()
  
  for (i in seq_along(necbl_urls)) {
    team_name <- names(necbl_urls)[i]
    url <- necbl_urls[[i]]
    
    # Get team abbreviation
    team_abbrev <- "UNK"
    for (team_code in names(necbl_team_mapping)) {
      if (necbl_team_mapping[[team_code]]$name == team_name) {
        team_abbrev <- necbl_team_mapping[[team_code]]$abbrev
        break
      }
    }
    
    cat("Scraping", team_name, "...\n")
    
    tryCatch({
      response <- GET(url, user_agent("Mozilla/5.0"), timeout(15))
      if (status_code(response) != 200) next
      
      page <- read_html(response)
      tables <- html_table(page, fill = TRUE)
      
      for (j in seq_along(tables)) {
        table <- tables[[j]]
        
        if (ncol(table) >= 10 && nrow(table) > 2) {
          col_text <- paste(names(table), collapse = " ")
          
          if (grepl("Player.*AB.*H", col_text, ignore.case = TRUE)) {
            # Find required columns
            ab_col <- which(grepl("^AB$", names(table), ignore.case = TRUE))[1]
            h_col <- which(grepl("^H$", names(table), ignore.case = TRUE))[1]
            doubles_col <- which(grepl("^2B$", names(table), ignore.case = TRUE))[1]
            triples_col <- which(grepl("^3B$", names(table), ignore.case = TRUE))[1]
            hr_col <- which(grepl("^HR$", names(table), ignore.case = TRUE))[1]
            bb_col <- which(grepl("^BB$", names(table), ignore.case = TRUE))[1]
            hbp_col <- which(grepl("^HBP$", names(table), ignore.case = TRUE))[1]
            so_col <- which(grepl("^SO$|^K$", names(table), ignore.case = TRUE))[1]
            
            if (is.na(ab_col) || is.na(h_col)) next
            
            team_stats <- data.frame()
            
            for (row_idx in 2:nrow(table)) {
              tryCatch({
                player_raw <- as.character(table[row_idx, 1])
                
                # Skip invalid rows
                if (is.na(player_raw) || nchar(trimws(player_raw)) < 3 || 
                    grepl("Total|AVG|OBP|SLG|---|^\\s*$|Player", player_raw, ignore.case = TRUE)) {
                  next
                }
                
                # Extract stats
                ab_val <- as.numeric(as.character(table[row_idx, ab_col]))
                h_val <- as.numeric(as.character(table[row_idx, h_col]))
                
                if (is.na(ab_val) || is.na(h_val) || ab_val <= 0) next
                
                # Extract other stats with defaults
                doubles_val <- if (!is.na(doubles_col)) as.numeric(as.character(table[row_idx, doubles_col])) else 0
                if (is.na(doubles_val)) doubles_val <- 0
                
                triples_val <- if (!is.na(triples_col)) as.numeric(as.character(table[row_idx, triples_col])) else 0
                if (is.na(triples_val)) triples_val <- 0
                
                hr_val <- if (!is.na(hr_col)) as.numeric(as.character(table[row_idx, hr_col])) else 0
                if (is.na(hr_val)) hr_val <- 0
                
                bb_val <- if (!is.na(bb_col)) as.numeric(as.character(table[row_idx, bb_col])) else 0
                if (is.na(bb_val)) bb_val <- 0
                
                hbp_val <- if (!is.na(hbp_col)) as.numeric(as.character(table[row_idx, hbp_col])) else 0
                if (is.na(hbp_val)) hbp_val <- 0
                
                so_val <- if (!is.na(so_col)) as.numeric(as.character(table[row_idx, so_col])) else 0
                if (is.na(so_val)) so_val <- 0
                
                # Calculate singles and metrics
                singles_val <- max(0, h_val - doubles_val - triples_val - hr_val)
                PA <- ab_val + bb_val + hbp_val
                Batted_Balls <- ab_val - so_val
                
                if (PA > 0 && Batted_Balls > 0) {
                  # wOBA: weighted value / PAs (your established weights)
                  pointstreak_wOBA <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                      triples_val * 1.616 + hr_val * 2.101 + 
                                      (bb_val + hbp_val) * 0.690) / PA
                  
                  # wOBACON: weighted value / Batted_Balls
                  pointstreak_wOBACON <- (singles_val * 0.888 + doubles_val * 1.271 + 
                                         triples_val * 1.616 + hr_val * 2.101) / Batted_Balls
                  
                  # Parse player name for matching
                  clean_name <- str_trim(str_replace_all(player_raw, "[^A-Za-z\\s,.-]", ""))
                  
                  if (grepl(",", clean_name)) {
                    parts <- str_split(clean_name, ",")[[1]]
                    last_name <- str_trim(parts[1])
                    first_part <- str_trim(parts[2])
                    first_initial <- substr(first_part, 1, 1)
                  } else {
                    words <- str_split(clean_name, "\\s+")[[1]]
                    if (length(words) >= 2) {
                      first_initial <- substr(words[1], 1, 1)
                      last_name <- paste(words[2:length(words)], collapse = " ")
                    } else {
                      last_name <- clean_name
                      first_initial <- substr(clean_name, 1, 1)
                    }
                  }
                  
                  player_row <- data.frame(
                    Player = clean_name,
                    Last_Name = toupper(str_trim(last_name)),
                    First_Initial = toupper(str_trim(first_initial)),
                    wOBA = round(pointstreak_wOBA, 3),
                    wOBACON = round(pointstreak_wOBACON, 3),
                    Season = season,
                    Team = team_name,
                    Team_Abbrev = team_abbrev,
                    PA = PA,
                    Batted_Balls = Batted_Balls,
                    stringsAsFactors = FALSE
                  )
                  
                  team_stats <- rbind(team_stats, player_row)
                }
              }, error = function(e) {
                # Skip problematic rows
              })
            }
            
            if (nrow(team_stats) > 0) {
              all_woba <- rbind(all_woba, team_stats)
            }
            break
          }
        }
      }
    }, error = function(e) {
      cat("ERROR:", e$message, "\n")
    })
    
    Sys.sleep(1)
  }
  
  cat("Total players with calculated wOBA/wOBACON:", nrow(all_woba), "\n")
  return(all_woba)
}

# Enhanced matching function - Model as primary, Pointstreak as overlay
match_necbl_data <- function(model_data, necbl_data) {
  cat("=== MATCHING MODEL DATA WITH POINTSTREAK OVERLAY ===\n")
  cat("Model records (PRIMARY):", nrow(model_data), "\n")
  cat("NECBL records (OVERLAY):", nrow(necbl_data), "\n")
  
  # Parse model data names: "Last Name, First Name" format
  model_with_names <- model_data %>%
    mutate(
      Last_Name = toupper(trimws(sub(",.*", "", Batter))),
      First_Initial = toupper(substr(trimws(sub(".*,\\s*", "", Batter)), 1, 1)),
      # Expected NECBL team from BatterTeam mapping
      Expected_NECBL_Team = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$name else NA_character_
      }),
      Expected_NECBL_Abbrev = sapply(BatterTeam, function(x) {
        team_info <- necbl_team_mapping[[x]]
        if (!is.null(team_info)) team_info$abbrev else NA_character_
      })
    )
  
  # If no NECBL data, return model-only
  if (nrow(necbl_data) == 0) {
    return(model_with_names %>%
           select(-Last_Name, -First_Initial, -Expected_NECBL_Team, -Expected_NECBL_Abbrev) %>%
           mutate(
             actual_woba_final = NA_real_,
             actual_wobacon_final = NA_real_,
             data_source = "Model Only",
             pointstreak_team_abbrev = NA_character_
           ))
  }
  
  # Matching strategies
  # 1. Team + Name match
  team_matches <- model_with_names %>%
    left_join(necbl_data %>% select(Last_Name, First_Initial, Team, wOBA, wOBACON, Team_Abbrev), 
              by = c("Last_Name", "First_Initial", "Expected_NECBL_Team" = "Team")) %>%
    mutate(match_quality = ifelse(!is.na(wOBA), "Team+Name_Match", NA_character_))
  
  # 2. Team abbreviation + Name match
  abbrev_matches <- team_matches %>%
    filter(is.na(match_quality)) %>%
    select(-wOBA, -wOBACON, -Team_Abbrev, -match_quality) %>%
    left_join(necbl_data %>% select(Last_Name, First_Initial, Team_Abbrev, wOBA, wOBACON, Team), 
              by = c("Last_Name", "First_Initial", "Expected_NECBL_Abbrev" = "Team_Abbrev")) %>%
    mutate(match_quality = ifelse(!is.na(wOBA), "Team_Abbrev_Match", NA_character_))
  
  # 3. Name-only match
  necbl_lookup <- necbl_data %>%
    group_by(Last_Name, First_Initial) %>%
    slice_head(n = 1) %>%
    ungroup()
  
  name_only_matches <- abbrev_matches %>%
    filter(is.na(match_quality)) %>%
    select(-wOBA, -wOBACON, -Team, -match_quality) %>%
    left_join(necbl_lookup %>% select(Last_Name, First_Initial, wOBA, wOBACON, Team, Team_Abbrev), 
              by = c("Last_Name", "First_Initial")) %>%
    mutate(match_quality = ifelse(!is.na(wOBA), "Name_Only_Match", NA_character_))
  
  # Combine all matches
  final_matches <- bind_rows(
    team_matches %>% filter(!is.na(match_quality)),
    abbrev_matches %>% filter(!is.na(match_quality)),
    name_only_matches %>% filter(!is.na(match_quality))
  ) %>%
    group_by(Last_Name, First_Initial) %>%
    arrange(match(match_quality, c("Team+Name_Match", "Team_Abbrev_Match", "Name_Only_Match"))) %>%
    slice_head(n = 1) %>%
    ungroup()
  
  # Apply to ALL model data - PRESERVE EVERYTHING
  matched_data <- model_with_names %>%
    left_join(final_matches %>% select(Last_Name, First_Initial, wOBA, wOBACON, Team, Team_Abbrev, match_quality), 
              by = c("Last_Name", "First_Initial")) %>%
    mutate(
      # OVERLAY Pointstreak data where available
      actual_woba_final = wOBA,
      actual_wobacon_final = wOBACON,
      
      # Data source tracking
      data_source = case_when(
        match_quality == "Team+Name_Match" ~ "Model + Pointstreak (Team+Name)",
        match_quality == "Team_Abbrev_Match" ~ "Model + Pointstreak (Team+Name)",
        match_quality == "Name_Only_Match" ~ "Model + Pointstreak (Name Only)",
        TRUE ~ "Model Only"
      ),
      
      # Team info
      pointstreak_team_abbrev = Team_Abbrev
    ) %>%
    select(-Last_Name, -First_Initial, -Expected_NECBL_Team, -Expected_NECBL_Abbrev, 
           -wOBA, -wOBACON, -Team, -Team_Abbrev, -match_quality)
  
  # Summary
  total_records <- nrow(matched_data)
  pointstreak_overlay <- sum(!is.na(matched_data$actual_woba_final))
  
  cat("=== MATCHING SUMMARY ===\n")
  cat("- TOTAL MODEL RECORDS PRESERVED:", total_records, "(100%)\n")
  cat("- Records with Pointstreak overlay:", pointstreak_overlay, "\n")
  cat("- Overlay rate:", round(pointstreak_overlay / total_records * 100, 1), "%\n")
  
  return(matched_data)
}

# Updated initialization with proper PA integration
initialize_app_data <- function() {
  cat("=== INITIALIZING APP DATA WITH PROPER PA INTEGRATION ===\n")
  
  # Use your existing data if available
  if (exists("combined_df") && is.data.frame(combined_df) && nrow(combined_df) > 0) {
    cat("Using existing combined_df data\n")
    base_data <- combined_df
    
    # Ensure proper xwOBA/xwOBACON separation if not already done
    if (!"predicted_xwobacon_final" %in% names(base_data)) {
      cat("Recalculating xwOBA/xwOBACON separation...\n")
      base_data <- calculate_model_xwoba_and_full(base_data, if(exists("model")) model else NULL)
    }
    
  } else if (exists("raw_data") && is.data.frame(raw_data) && nrow(raw_data) > 0) {
    cat("Using raw_data and applying model calculations\n")
    
    # Apply your enhanced model calculation
    base_data <- calculate_model_xwoba_and_full(raw_data, if(exists("model")) model else NULL)
    
  } else {
    cat("Creating sample data with proper PA structure\n")
    # Sample data with realistic PA structure including walks/strikeouts
    set.seed(42)
    n <- 1200  # Increased to include non-contact PAs
    
    # Create batted balls (with tracking data)
    batted_balls <- data.frame(
      Batter = paste(sample(c("Smith", "Johnson", "Williams", "Brown", "Jones", "Davis", "Miller", "Wilson"), 800, replace = TRUE),
                    sample(c("John", "Michael", "David", "James", "Robert", "Chris", "Matt", "Alex"), 800, replace = TRUE),
                    sep = ", "),
      ExitSpeed = rnorm(800, 85, 15),
      Angle = rnorm(800, 15, 20),
      PlayResult = sample(c("Single", "Double", "Triple", "HomeRun", "Out"), 800, 
                         replace = TRUE, prob = c(0.15, 0.08, 0.02, 0.05, 0.70)),
      Date = Sys.Date() - sample(1:90, 800, replace = TRUE),
      Inning = sample(1:9, 800, replace = TRUE),
      PAofInning = sample(1:4, 800, replace = TRUE),
      BatterTeam = sample(names(necbl_team_mapping), 800, replace = TRUE),
      KorBB = NA_character_,  # No K/BB for batted balls
      PitchCall = NA_character_,
      stringsAsFactors = FALSE
    )
    
    # Create walks and strikeouts (no tracking data)
    walks_ks <- data.frame(
      Batter = paste(sample(c("Smith", "Johnson", "Williams", "Brown", "Jones", "Davis", "Miller", "Wilson"), 400, replace = TRUE),
                    sample(c("John", "Michael", "David", "James", "Robert", "Chris", "Matt", "Alex"), 400, replace = TRUE),
                    sep = ", "),
      ExitSpeed = NA_real_,
      Angle = NA_real_,
      PlayResult = NA_character_,
      Date = Sys.Date() - sample(1:90, 400, replace = TRUE),
      Inning = sample(1:9, 400, replace = TRUE),
      PAofInning = sample(1:4, 400, replace = TRUE),
      BatterTeam = sample(names(necbl_team_mapping), 400, replace = TRUE),
      KorBB = sample(c("Walk", "Strikeout", "StrikeoutSwinging", "StrikeoutLooking"), 400, 
                    replace = TRUE, prob = c(0.3, 0.25, 0.25, 0.2)),
      PitchCall = ifelse(runif(400) < 0.05, "HitByPitch", NA_character_),
      stringsAsFactors = FALSE
    )
    
    # Combine all PAs
    raw_sample_data <- rbind(batted_balls, walks_ks)
    
    # Apply model calculations
    base_data <- calculate_model_xwoba_and_full(raw_sample_data, NULL)
  }
  
  # Ensure all required columns exist
  final_data <- base_data %>%
    mutate(
      # Model predictions with proper separation
      predicted_xwoba_final = if("predicted_xwoba_final" %in% names(.)) predicted_xwoba_final else 0.350,
      predicted_xwobacon_final = if("predicted_xwobacon_final" %in% names(.)) predicted_xwobacon_final else 0.400,
      
      # Pointstreak overlay (initially empty)
      actual_woba_final = NA_real_,
      actual_wobacon_final = NA_real_,
      
      # Tracking
      data_source = "Model Only",
      pointstreak_team_abbrev = NA_character_
    )
  
  cat("Final data initialized with", nrow(final_data), "total PAs\n")
  
  # Verify calculation by showing sample player
  sample_summary <- final_data %>%
    group_by(Batter) %>%
    summarise(
      Total_PAs = n(),
      Batted_Balls = sum(!is.na(ExitSpeed) | !is.na(PlayResult), na.rm = TRUE),
      Walks = sum(KorBB == "Walk", na.rm = TRUE),
      Strikeouts = sum(KorBB %in% c("Strikeout", "StrikeoutSwinging", "StrikeoutLooking"), na.rm = TRUE),
      xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
      xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
      .groups = "drop"
    ) %>%
    filter(Total_PAs >= 10) %>%
    slice_head(n = 3)
  
  cat("\nSample player verification:\n")
  print(sample_summary)
  
  return(final_data)
}

# ===================================================================
# SHINY UI
# ===================================================================

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .header-container {
        display: flex;
        align-items: center;
        padding: 15px 20px 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        margin-bottom: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .header-container h1 {
        font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        font-weight: 700;
        color: white;
        letter-spacing: 1px;
        font-size: 32px;
        margin: 0;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }
      .necbl-status {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .action-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
      }
    "))
  ),
  
  div(class = "content-wrapper",
    div(class = "header-container",
        h1("Enhanced xwOBA Dashboard")
    ),

    # Controls
    fluidRow(
      column(12,
        div(class = "necbl-status",
          h4("Data Controls", style = "margin: 0 0 10px 0;"),
          fluidRow(
            column(3, selectInput("necbl_season", "NECBL Season:", 
                         choices = c("2025", "2024", "2023", "2022", "2021"), selected = "2025")),
            column(3, selectInput("team_filter", "Filter by Team:", 
                         choices = c("All Teams" = "All"), selected = "All")),
            column(3, selectInput("pa_threshold", "Minimum PAs:", 
                         choices = c("All Players" = 0, "10+" = 10, "20+" = 20, "30+" = 30),
                         selected = 10)),
            column(3, selectInput("metric_type", "Primary Metric:", 
                         choices = c("xwOBA vs wOBA" = "xwoba", "xwOBACON vs wOBACON" = "xwobacon"), 
                         selected = "xwoba"))
          ),
          br(),
          actionButton("refresh_necbl", "🔄 Refresh NECBL Data", class = "action-button")
        )
      )
    ),

    # Main content
    sidebarLayout(
      sidebarPanel(
        conditionalPanel(
          condition = "input.tabs == 'Performance Analysis'",
          selectInput("scatter_player", "Select Player:", 
                      choices = c("All Players" = ""), selected = "")
        ),
        
        conditionalPanel(
          condition = "input.tabs == 'Player Comparison'",
          selectInput("comp_player1", "Select Player 1:", choices = c("Choose Player" = "")),
          selectInput("comp_player2", "Select Player 2:", choices = c("Choose Player" = "")),
          dateRangeInput("comp_date_range", "Date Range:", 
                        start = Sys.Date() - 90, end = Sys.Date())
        ),
        
        conditionalPanel(
          condition = "input.tabs == 'Team & Player Browser'",
          selectInput("browser_team", "Select Team:", choices = c("All Teams" = "All")),
          selectInput("browser_player", "Select Player:", choices = c("All Players" = "All")),
          selectInput("browser_sort", "Sort by:", 
                     choices = c("xwOBA" = "Avg_xwOBA", "wOBA" = "Avg_wOBA", "xwOBACON" = "Avg_xwOBACON", "wOBACON" = "Avg_wOBACON", "PAs" = "PA_Count"),
                     selected = "Avg_xwOBA")
        )
      ),

      mainPanel(
        tabsetPanel(
          id = "tabs",
          
          tabPanel("Performance Analysis", 
                   div(
                     h3("Expected vs Actual Performance Analysis"),
                     p("Compare model predictions (xwOBA/xwOBACON) with actual Pointstreak statistics (wOBA/wOBACON)."),
                     plotOutput("performance_plot", height = "500px")
                   )),
          
          tabPanel("Underperformers", 
                   div(
                     h3("Players Getting Unlucky (Expected > Actual)", style = "color: #28a745;"),
                     p("Players whose model predictions exceed their actual Pointstreak results."),
                     DT::dataTableOutput("underperformers")
                   )),
          
          tabPanel("Overperformers", 
                   div(
                     h3("Players Getting Lucky (Actual > Expected)", style = "color: #dc3545;"),
                     p("Players whose actual Pointstreak results exceed their model predictions."),
                     DT::dataTableOutput("overperformers")
                   )),
          
          tabPanel("Player Comparison",
                   div(
                     h3("Player Performance Comparison"),
                     p("Compare cumulative performance trends between two players."),
                     plotOutput("comparison_line_chart", height = "500px"),
                     hr(),
                     DT::dataTableOutput("comparison_summary")
                   )),
          
          tabPanel("Team & Player Browser",
                   div(
                     h3("Team and Player Browser"),
                     p("Browse all players and their performance metrics."),
                     DT::dataTableOutput("browser_table")
                   ))
        )
      )
    )
  )
)

# ===================================================================
# SHINY SERVER
# ===================================================================

server <- function(input, output, session) {
  
  # Reactive values
  values <- reactiveValues(
    necbl_data = NULL,
    combined_df_enhanced = NULL,
    last_update = NULL
  )
  
  # Initialize data on startup
  observe({
    if (is.null(values$combined_df_enhanced)) {
      values$combined_df_enhanced <- initialize_app_data()
      cat("Initialized app with", nrow(values$combined_df_enhanced), "records\n")
    }
  })
  
  # Helper function for filtered data
  get_filtered_data <- function() {
    req(values$combined_df_enhanced)
    
    current_data <- values$combined_df_enhanced
    
    if (is.null(current_data) || nrow(current_data) == 0) {
      return(data.frame())
    }
    
    # Apply PA threshold
    pa_threshold <- as.numeric(input$pa_threshold %||% 0)
    if (pa_threshold > 0) {
      current_data <- current_data %>%
        group_by(Batter) %>%
        filter(n() >= pa_threshold) %>%
        ungroup()
    }
    
    # Apply team filter
    if (!is.null(input$team_filter) && input$team_filter != "All") {
      if ("BatterTeam" %in% names(current_data)) {
        current_data <- current_data %>%
          filter(BatterTeam == input$team_filter)
      }
    }
    
    return(current_data)
  }
  
  # Update UI elements
  observe({
    tryCatch({
      current_data <- get_filtered_data()
      
      if (!is.null(current_data) && nrow(current_data) > 0) {
        player_choices <- c("All Players" = "", sort(unique(current_data$Batter)))
        
        updateSelectInput(session, "scatter_player", choices = player_choices)
        updateSelectInput(session, "comp_player1", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
        updateSelectInput(session, "comp_player2", choices = c("Choose Player" = "", sort(unique(current_data$Batter))))
        updateSelectInput(session, "browser_player", choices = c("All Players" = "All", sort(unique(current_data$Batter))))
        
        if ("BatterTeam" %in% names(current_data)) {
          team_choices <- c("All Teams" = "All", sort(unique(current_data$BatterTeam)))
          updateSelectInput(session, "team_filter", choices = team_choices)
          updateSelectInput(session, "browser_team", choices = team_choices)
        }
      }
    }, error = function(e) {
      cat("Error updating UI elements:", e$message, "\n")
    })
  })
  
  # NECBL data refresh with model integration
  observeEvent(input$refresh_necbl, {
    showModal(modalDialog(
      title = paste("Scraping NECBL", input$necbl_season, "Data"),
      div(
        h4("Downloading Pointstreak Statistics..."),
        p("Scraping wOBA (all PAs) and wOBACON (batted balls only) from team pages..."),
        p("This may take 1-2 minutes.")
      ),
      footer = NULL, easyClose = FALSE
    ))
    
    tryCatch({
      cat("=== STARTING NECBL REFRESH WITH MODEL INTEGRATION ===\n")
      
      # Step 1: Scrape NECBL data
      values$necbl_data <- get_necbl_woba_by_season(input$necbl_season)
      values$last_update <- Sys.time()
      
      if (!is.null(values$necbl_data) && nrow(values$necbl_data) > 0) {
        cat("NECBL data found:", nrow(values$necbl_data), "player records\n")
        
        # Step 2: Re-initialize base data with your model
        base_data <- initialize_app_data()
        
        # Step 3: Match and overlay Pointstreak data
        values$combined_df_enhanced <- match_necbl_data(base_data, values$necbl_data)
        
        # Step 4: Report results
        if (!is.null(values$combined_df_enhanced)) {
          total_records <- nrow(values$combined_df_enhanced)
          pointstreak_records <- sum(!is.na(values$combined_df_enhanced$actual_woba_final))
          
          removeModal()
          
          if (pointstreak_records > 0) {
            showNotification(
              HTML(paste0(
                "<strong>SUCCESS!</strong> Pointstreak data overlaid on your model!<br>",
                "📊 ", total_records, " total model records preserved<br>",
                "🎯 ", pointstreak_records, " records enhanced with Pointstreak stats<br>",
                "📈 Your model predictions remain primary data source"
              )), 
              type = "message", duration = 10
            )
          } else {
            showNotification(
              "⚠Pointstreak data scraped but NO MATCHES found. All data remains model-only.", 
              type = "warning", duration = 15
            )
          }
        } else {
          removeModal()
          showNotification(" Error in matching process", type = "error")
        }
      } else {
        removeModal()
        showNotification(
          paste(" No NECBL data found for", input$necbl_season, "season. Check network connection."), 
          type = "warning", duration = 10
        )
      }
    }, error = function(e) {
      removeModal()
      showNotification(paste(" Error scraping NECBL data:", e$message), type = "error", duration = 15)
    })
  })
  
  # Performance Analysis Plot
  output$performance_plot <- renderPlot({
    current_data <- get_filtered_data()
    
    if (nrow(current_data) == 0) {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data available"), size = 6) +
        theme_void()
      return()
    }
    
    # Filter for specific player if selected
    if (!is.null(input$scatter_player) && input$scatter_player != "") {
      current_data <- current_data %>% filter(Batter == input$scatter_player)
      plot_title <- paste("Performance Analysis:", input$scatter_player)
    } else {
      plot_title <- "Performance Analysis: All Players"
    }
    
    # Calculate player-level performance metrics
    player_performance <- current_data %>%
      group_by(Batter) %>%
      summarise(
        xwOBA = mean(predicted_xwoba_final, na.rm = TRUE),
        wOBA = mean(actual_woba_final, na.rm = TRUE),
        xwOBACON = mean(predicted_xwobacon_final, na.rm = TRUE),
        wOBACON = mean(actual_wobacon_final, na.rm = TRUE),
        PA_Count = n(),
        Has_Pointstreak = !all(is.na(actual_woba_final)),
        Data_Source = first(data_source),
        Team = first(BatterTeam),
        .groups = "drop"
      ) %>%
      filter(Has_Pointstreak)  # Only show players with Pointstreak data
    
    if (nrow(player_performance) == 0) {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, 
                     label = "No players with Pointstreak data found\n\nClick 'Refresh NECBL Data' to load actual statistics"), 
                  size = 6, color = "#667eea") +
        theme_void()
      return()
    }
    
    # Select metrics based on input
    if (input$metric_type == "xwoba") {
      plot_data <- player_performance %>%
        select(Batter, xwOBA, wOBA, PA_Count, Data_Source, Team) %>%
        rename(Expected = xwOBA, Actual = wOBA)
      x_label <- "wOBA (Pointstreak - All PAs)"
      y_label <- "xwOBA (Your Model - All PAs)"
      subtitle <- "Includes walks, HBP, and all plate appearances"
    } else {  # xwobacon
      plot_data <- player_performance %>%
        select(Batter, xwOBACON, wOBACON, PA_Count, Data_Source, Team) %>%
        rename(Expected = xwOBACON, Actual = wOBACON)
      x_label <- "wOBACON (Pointstreak - Batted Balls Only)"
      y_label <- "xwOBACON (Your Model - Batted Balls Only)"
      subtitle <- "Excludes walks, HBP - batted balls only"
    }
    
    # Create scatter plot
    ggplot(plot_data, aes(x = Actual, y = Expected)) +
      geom_point(aes(size = PA_Count, color = Data_Source), alpha = 0.7) +
      geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "#dc3545", size = 1) +
      scale_size_continuous(name = "PAs", range = c(2, 8)) +
      scale_color_manual(values = c(
        "Model + Pointstreak (Team+Name)" = "#28a745",
        "Model + Pointstreak (Name Only)" = "#fd7e14"
      )) +
      labs(title = plot_title,
           subtitle = paste("Dot size = Plate Appearances | Red line = perfect prediction |", subtitle),
           x = x_label, y = y_label, color = "Match Quality") +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 11),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "bottom"
      )
  })
  
  # Underperformers Table
  output$underperformers <- DT::renderDataTable({
    current_data <- get_filtered_data()
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    underperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(xwOBA - wOBA, 3),
        wOBACON_Diff = round(xwOBACON - wOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(underperformers, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#d4edda')
  })
  
  # Overperformers Table
  output$overperformers <- DT::renderDataTable({
    current_data <- get_filtered_data()
    pa_threshold <- max(20, as.numeric(input$pa_threshold %||% 0))
    
    overperformers <- current_data %>%
      filter(!is.na(actual_woba_final), !is.na(actual_wobacon_final)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Data_Source = first(data_source),
        .groups = "drop"
      ) %>%
      mutate(
        wOBA_Diff = round(wOBA - xwOBA, 3),
        wOBACON_Diff = round(wOBACON - xwOBACON, 3)
      ) %>%
      filter(PA >= pa_threshold, (wOBA_Diff > 0.025 | wOBACON_Diff > 0.025)) %>%
      arrange(desc(wOBA_Diff))
    
    DT::datatable(overperformers, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('xwOBA', 'wOBA', 'xwOBACON', 'wOBACON', 'wOBA_Diff', 'wOBACON_Diff'), digits = 3) %>%
      formatStyle(c('wOBA_Diff', 'wOBACON_Diff'), backgroundColor = '#f8d7da')
  })
  
  # Player Comparison Line Chart
  output$comparison_line_chart <- renderPlot({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_data <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      arrange(if("Date" %in% names(.)) Date else row_number()) %>%
      group_by(Batter) %>%
      mutate(
        PA_Number = row_number(),
        Cumulative_xwOBA = cummean(predicted_xwoba_final),
        Cumulative_wOBA = cummean(actual_woba_final),
        Cumulative_xwOBACON = cummean(predicted_xwobacon_final),
        Cumulative_wOBACON = cummean(actual_wobacon_final)
      ) %>%
      ungroup()
    
    if (nrow(comparison_data) > 0) {
      line_data <- comparison_data %>%
        select(Batter, PA_Number, Cumulative_xwOBA, Cumulative_wOBA, Cumulative_xwOBACON, Cumulative_wOBACON) %>%
        pivot_longer(cols = starts_with("Cumulative"), names_to = "Metric", values_to = "Value") %>%
        mutate(
          Metric = gsub("Cumulative_", "", Metric),
          Line_Type = ifelse(grepl("x", Metric), "Expected (Your Model)", "Actual (Pointstreak)"),
          Metric_Type = ifelse(grepl("OBACON", Metric), "wOBACON (Batted Balls)", "wOBA (All PAs)")
        ) %>%
        filter(!is.na(Value))
      
      ggplot(line_data, aes(x = PA_Number, y = Value, color = Batter, linetype = Line_Type)) +
        geom_line(size = 1.2, alpha = 0.8) +
        facet_wrap(~Metric_Type, scales = "free_y") +
        scale_color_manual(values = c("#667eea", "#764ba2")) +
        scale_linetype_manual(values = c("Expected (Your Model)" = "solid", "Actual (Pointstreak)" = "dashed")) +
        labs(title = paste("Performance Comparison:", input$comp_player1, "vs", input$comp_player2),
             subtitle = "Cumulative performance over plate appearances",
             x = "Plate Appearance Number", y = "Cumulative Value",
             color = "Player", linetype = "Type") +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 16, face = "bold"),
          legend.position = "top"
        )
    } else {
      ggplot() + 
        geom_text(aes(x = 0.5, y = 0.5, label = "No data for selected players"), size = 6) +
        theme_void()
    }
  })
  
  # Comparison Summary
  output$comparison_summary <- DT::renderDataTable({
    req(input$comp_player1, input$comp_player2)
    
    current_data <- get_filtered_data()
    
    if ("Date" %in% names(current_data)) {
      current_data <- current_data %>%
        filter(Date >= input$comp_date_range[1], Date <= input$comp_date_range[2])
    }
    
    comparison_summary <- current_data %>%
      filter(Batter %in% c(input$comp_player1, input$comp_player2)) %>%
      group_by(Batter) %>%
      summarise(
        PA = n(),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Data_Source = first(data_source),
        .groups = "drop"
      )
    
    DT::datatable(comparison_summary, options = list(pageLength = 15, scrollX = TRUE)) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3)
  })
  
  # Team & Player Browser
  output$browser_table <- DT::renderDataTable({
    current_data <- get_filtered_data()
    
    if (!is.null(input$browser_team) && input$browser_team != "All") {
      if ("BatterTeam" %in% names(current_data)) {
        current_data <- current_data %>% filter(BatterTeam == input$browser_team)
      }
    }
    
    if (!is.null(input$browser_player) && input$browser_player != "All") {
      current_data <- current_data %>% filter(Batter == input$browser_player)
    }
    
    browser_data <- current_data %>%
      group_by(Batter) %>%
      summarise(
        PA_Count = n(),
        Avg_xwOBA = round(mean(predicted_xwoba_final, na.rm = TRUE), 3),
        Avg_wOBA = round(mean(actual_woba_final, na.rm = TRUE), 3),
        Avg_xwOBACON = round(mean(predicted_xwobacon_final, na.rm = TRUE), 3),
        Avg_wOBACON = round(mean(actual_wobacon_final, na.rm = TRUE), 3),
        wOBA_Gap = round(mean(predicted_xwoba_final, na.rm = TRUE) - mean(actual_woba_final, na.rm = TRUE), 3),
        wOBACON_Gap = round(mean(predicted_xwobacon_final, na.rm = TRUE) - mean(actual_wobacon_final, na.rm = TRUE), 3),
        Team = first(BatterTeam),
        Pointstreak_Team = first(pointstreak_team_abbrev),
        Data_Source = first(data_source),
        Has_Pointstreak = !all(is.na(actual_woba_final)),
        .groups = "drop"
      ) %>%
      arrange(desc(!!sym(input$browser_sort)))
    
    DT::datatable(browser_data, options = list(pageLength = 20, scrollX = TRUE)) %>%
      formatRound(columns = c('Avg_xwOBA', 'Avg_wOBA', 'Avg_xwOBACON', 'Avg_wOBACON', 'wOBA_Gap', 'wOBACON_Gap'), digits = 3) %>%
      formatStyle("Has_Pointstreak", backgroundColor = styleEqual(TRUE, '#d4edda'))
  })
}

# ===================================================================
# RUN APPLICATION
# ===================================================================

shinyApp(ui = ui, server = server)

# ===================================================================
# USAGE INSTRUCTIONS
# ===================================================================
cat("🎯 Enhanced xwOBA Dashboard with Model Integration Ready!\n")
cat("\n📋 Key Features:\n")
cat(" Uses YOUR xwOBA model calculations as primary data source\n") 
cat("Overlays Pointstreak wOBA/wOBACON when available\n")
cat("Proper separation: wOBA (all PAs) vs wOBACON (batted balls only)\n")
cat("Team abbreviation matching (BatterTeam → NECBL teams)\n")
cat("Smart name parsing: 'Last, First' ↔ 'Last First_Initial'\n")
cat("Model predictions always preserved\n")
cat("\n Instructions:\n")
cat("1. Ensure your model data includes: Batter, BatterTeam, predicted_xwoba\n")
cat("2. Your existing calculate_full_xwoba() function is integrated\n") 
cat("3. Click 'Refresh NECBL Data' to overlay Pointstreak statistics\n")
cat("4. Green highlighting shows successful Pointstreak matches\n")
cat("5. Red line on scatter plot = perfect prediction\n")
cat("6. Compare Expected (your model) vs Actual (Pointstreak)\n")
